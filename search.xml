<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>四轴飞行器</title>
      <link href="/2023/10/21/%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8/"/>
      <url>/2023/10/21/%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32启动文件解析</title>
      <link href="/2023/10/21/STM32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/10/21/STM32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM体系架构</title>
      <link href="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
      <url>/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下内容部分摘录自《ARM Cortex-M3 权威指南》、韦东山老师的课程《深入理解ARM架构》，仅用于个人交流与学习，如涉及侵权请联系站长删除！</p></blockquote><h1 id="第一章-ARM架构版本及处理器系列介绍"><a href="#第一章-ARM架构版本及处理器系列介绍" class="headerlink" title="第一章 ARM架构版本及处理器系列介绍"></a>第一章 ARM架构版本及处理器系列介绍</h1><h2 id="1-ARM背景"><a href="#1-ARM背景" class="headerlink" title="1.ARM背景"></a>1.ARM背景</h2><p>ARM在1990年成立，当初的名字是“Advanced RISC Machines Ltd.,”，当时它是三家公司的合资——它们分别是苹果电脑，Acorn电脑公司，以及VLSI技术（公司）。</p><p>ARM的版本分为两类，一个是内核版本，一个处理器版本。</p><ul><li>内核版本也就是ARM架构，如ARMv1、ARMv2、ARMv3、ARMv4、ARMv5、ARMv6、ARMv7、ARMv8等。</li><li>处理器版本也就是ARM处理器，如ARM1、ARM9、ARM11、ARM Cortex-A（A7、A9、A15），ARM Cortex-M（M1、M3、M4）、ARM Cortex-R，这个也是我们通常意义上所指的ARM版本。</li></ul><h2 id="2-ARM架构与处理器的关系"><a href="#2-ARM架构与处理器的关系" class="headerlink" title="2.ARM架构与处理器的关系"></a>2.ARM架构与处理器的关系</h2><p>基于不同的ARM架构可以设计出不同特点的ARM处理器。比如基于ARMv3架构设计出的处理器ARM6、ARM7，这两款处理器适用于不同的场景，硬件可能不同，但是架构指令集是一样的。</p><p>举个例子，比如说盖房子，早期因为发展落后，盖的都是平房，这就是一种架构(ARMv5)，然后这种平房架构你可以设计出一款三室一厅的款式， 这叫ARM7处理器。 然后其他人(芯片设计公司)想盖房子的就买你这个款式去盖，接着过一段时间，有人觉得光三室一厅的不好， 我还想每个房间有独立卫! 于是，ARM就满足你们的要求，出个独卫的款式(ARM9)。</p><p>即ARMv5等是指令集的架构，ARM7&#x2F;9等是基于架构设计出的内核处理器。ARM的架构都是基于RISC指令集而设计的，内核处理器是实现这一指令集的硬件架构的基础。</p><h2 id="3-ARM版本"><a href="#3-ARM版本" class="headerlink" title="3.ARM版本"></a>3.ARM版本</h2><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/a.png"></p><p>最近的几年，基于从ARMv6开始的新设计理念，ARM进一步扩展了它的CPU设计，成果 就是ARMv7架构的闪亮登场。在这个版本中，内核架构首次从单一款式变成3种款式。 </p><ul><li><p>款式A：设计用于高性能的“开放应用平台”——越来越接近电脑了 </p></li><li><p>款式R：用于高端的嵌入式系统，尤其是那些带有实时要求的——又要快又要实时。 </p></li><li><p>款式M：用于深度嵌入的，单片机风格的系统中——本文章主要讲解的知识。</p></li></ul><p>让我们再进距离地考察这3种款式： </p><ul><li>款式A（ARMv7‐A）：需要运行复杂应用程序的“应用处理器” 。支持大型嵌入式操作系统，比如Symbian（诺基亚智能手机用），Linux，以及微软 的Windows CE和智能手机操作系统Windows Mobile。这些应用需要劲爆的处理性能，并 且需要硬件MMU实现的完整而强大的虚拟内存机制，还基本上会配有Java支持，有时 还要求一个安全程序执行环境。典型的产品包括高端手机和手持仪器，电子钱包以及金融事务处理机。 </li><li>款式R（ARMv7‐R）：硬实时且高性能的处理器。标的是高端实时市场。那些高级的玩意，像高档轿车的组件，大型发电机控制器，机器手臂控制器等，它们使用的处理 器不但要很好很强大，还要极其可靠，对事件的反应也要极其敏捷。 </li><li>款式M（ARMv7‐M）：认准了旧世代单片机的应用而量身定制。在这些应用中，尤其是 对于实时控制系统，低成本、低功耗、极速中断反应以及高处理效率，都是至关重要的。  Cortex系列是v7架构的第一次亮相，其中Cortex‐M3就是按款式M设计的。</li></ul><h1 id="第二章-ARM基础知识"><a href="#第二章-ARM基础知识" class="headerlink" title="第二章 ARM基础知识"></a>第二章 ARM基础知识</h1><h2 id="1-哈弗架构与冯诺伊曼架构"><a href="#1-哈弗架构与冯诺伊曼架构" class="headerlink" title="1.哈弗架构与冯诺伊曼架构"></a>1.<strong>哈弗架构与冯诺伊曼架构</strong></h2><p>CPU架构可以分为哈弗架构与冯诺伊曼架构，如下图所示。</p><ul><li><p><strong>哈弗架构</strong>中指令与数据分开存放，CPU可以同时读入指令、读写数据。</p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/b.png"></p></li><li><p><strong>冯诺伊曼架构</strong>中指令、数据混合存放，CPU依次读取指令、读写数据，不可同时操作指令和数据。</p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/c.png"></p></li></ul><blockquote><p>Cortex‐M3采用了哈佛结构，拥有独立的指令总线和数据总线，可以让取指与数据访问 并行不悖。</p></blockquote><h2 id="2-RISC与CISC"><a href="#2-RISC与CISC" class="headerlink" title="2. RISC与CISC"></a>2. RISC与CISC</h2><ul><li><strong>复杂指令集CISC</strong>:   以Intel、AMD的X86 CPU为代表，CISC也是要通过操作内存、寄存器、运算器来完成复杂指令的。它在实现时，是将复杂指令转换成了一个微程序，微程序在制造CPU时就已存储于微服务存储器。一个微程序包含若干条微指令（也称微码），执行复杂指令时，实际上是在执行一个微程序。这也带来两种指令集的一个差别，微程序的执行是不可被打断的，而RISC指令之间可以被打断，所以理论上RISC可更快响应中断。特点：</li><li><strong>精简指令集RISC</strong>：以ARM、IBM Power为代表，设计初衷针对CISC CPU复杂的弊端，选择一些可以在单个CPU周期完成的指令，以降低CPU的复杂度，将复杂性交给编译器</li></ul><blockquote><p><strong>ARM公司的芯片都使用RISC指令集，对内存只有load&#x2F;store操作，数据的处理是在CPU寄存器上进行。</strong></p></blockquote><ul><li>二者的比较：<ul><li>CISC的指令能力强，单多数指令使用率低却增加了CPU的复杂度，指令是可变长格式；</li><li>RISC的指令大部分为单周期指令，指令长度固定，操作寄存器，对于内存只有Load&#x2F;Store操作</li><li>CISC支持多种寻址方式；RISC支持的寻址方式</li><li>CISC通过微程序控制技术实现；</li><li>RISC增加了通用寄存器，硬布线逻辑控制为主，采用流水线</li><li>CISC的研制周期长</li><li>RISC优化编译，有效支持高级语言</li></ul></li></ul><h1 id="第三章-ARM-寄存器"><a href="#第三章-ARM-寄存器" class="headerlink" title="第三章 ARM 寄存器"></a>第三章 ARM 寄存器</h1><p>这里以Cortex‐M3 &#x2F;Cortex‐M4&#x2F;Cortex‐A7处理器为例，他们拥有 R0‐R15 的寄存器组。其中 R13 作为堆栈指针 SP。SP 有两个，但在同一 时刻只能有一个可以看到，这也就是所谓的“banked”寄存器。</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20231021162714042.png" alt="image-20231021162714042"></p><ul><li>R0-R12：通用寄存器 ，R0‐R12 都是 32 位通用寄存器，用于数据操作。但是注意：绝大多数 16 位 Thumb 指令只能访 问 R0‐R7，而 32 位 Thumb‐2 指令可以访问所有寄存器。</li><li>Banked R13: 两个堆栈指针 <ul><li>主堆栈指针（MSP）：复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程（包 括中断服务例程） </li><li>进程堆栈指针（PSP）：由用户的应用程序代码使用。</li></ul></li><li>R14：连接寄存器，当呼叫一个子程序时，由 R14 存储返回地址 </li><li>R15：程序计数寄存器 ，指向当前的程序地址。如果修改它的值，就能改变程序的执行流</li><li>特殊功能寄存器 <ul><li>程序状态字寄存器组（PSRs）  </li><li>中断屏蔽寄存器组（PRIMASK, FAULTMASK, BASEPRI）  </li><li>控制寄存器（CONTROL）</li></ul></li></ul><p><img src="/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20231021163136833.png" alt="image-20231021163136833"></p><p>功能如下表：</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20231021163233661.png" alt="image-20231021163233661"></p><h1 id="第四章-ARM汇编"><a href="#第四章-ARM汇编" class="headerlink" title="第四章 ARM汇编"></a>第四章 ARM汇编</h1><h2 id="1-ARM汇编概述"><a href="#1-ARM汇编概述" class="headerlink" title="1.ARM汇编概述"></a>1.ARM汇编概述</h2><p>①最初，ARM公司发布两类指令集：</p><ul><li><strong>Thumb指令集：</strong>这是16位的，每条指令占据16位，节省空间</li><li><strong>ARM指令集：</strong>这是32位的，每条指令占据32位，高效，但是太占空间</li></ul><p>要节省空间时用Thumb指令，要效率时用ARM指令</p><p>②一个CPU既可以运行Thumb指令，也能运行ARM指令。怎么区分当前指令是Thumb还是ARM指令呢？</p><p>​程序状态寄存器中有一位，名为“T”，它等于1时表示当前运行的是Thumb指令。</p><p>③假设函数A是使用Thumb指令写的，函数B是使用ARM指令写的，怎么调用A&#x2F;B？</p><p>​我们可以往PC寄存器里写入函数A或B的地址，就可以调用A或B，</p><p>④但是怎么让CPU在执行A函数是进入Thumb状态，在执行B函数时进入ARM状态？</p><p>​做个手脚：</p><p>​调用函数A时，让PC寄存器的BIT0等于1，即：PC&#x3D;函数A地址+(1&lt;&lt;0)；</p><p>​调用函数B时，让PC寄存器的BIT0等于0:，即：PC&#x3D;函数B地址</p><p>⑤但是这样做太麻烦，于是引入Thumb2指令集</p><ul><li><strong>Thumb2指令集：</strong>它支持16位指令、32位指令混合编程。</li></ul><h2 id="2-区分指令集"><a href="#2-区分指令集" class="headerlink" title="2.区分指令集"></a>2.区分指令集</h2><p>ARM公司推出了： Unified Assembly Language UAL，统一汇编语言，我们不需要去区分这些指令集</p><p>我们只需要在程序前面用CODE32&#x2F;CODE16&#x2F;THUMB表示指令集:ARM&#x2F;Thumb&#x2F;Thumb2</p><h2 id="3-汇编指令格式"><a href="#3-汇编指令格式" class="headerlink" title="3.汇编指令格式"></a>3.汇编指令格式</h2><blockquote><p>参考《DEN0013D_cortex_a_series_PG.pdf》P70</p><p>《ARM Cortex-M3与Cortex-M4权威指南.pdf》第5章汇编指令可以分为几大类：数据处理、内存访问、跳转、饱和运算、其他指令</p></blockquote><p>以“数据处理”指令为例，UAL汇编格式为：</p><p><img src="/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20231021175310394.png" alt="image-20231021175310394"></p><ul><li><p>Operation表示各类汇编指令，比如ADD、MOV；</p></li><li><p>cond表示conditon，即该指令执行的条件；</p></li><li><p>S表示该指令执行后，会去修改程序状态寄存器；</p></li><li><p>Rd为目的寄存器，用来存储运算的结果；</p></li><li><p>Rn、Operand2是两个源操作数</p></li></ul><h2 id="4-常用汇编指令"><a href="#4-常用汇编指令" class="headerlink" title="4.常用汇编指令"></a>4.常用汇编指令</h2><h3 id="1-内存访问指令"><a href="#1-内存访问指令" class="headerlink" title="1.内存访问指令"></a>1.内存访问指令</h3><p>加载指令LDR：Load Register<br>存储指令STR：Store Register</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, =0X20000</span><br><span class="line">LDR R1, =0X1234</span><br><span class="line">STR R1,[R0]      ;将R1里面的值写入到R0指向的地址里</span><br></pre></td></tr></table></figure><h3 id="2-数据处理指令"><a href="#2-数据处理指令" class="headerlink" title="2.数据处理指令"></a>2.数据处理指令</h3><p>加法指令ADD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV R2,#1</span><br><span class="line">MOV R3,#2</span><br><span class="line">ADD R1,R2,R3;R1 = R2 + R3</span><br></pre></td></tr></table></figure><p>减法指令SUB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV R2,#1</span><br><span class="line">MOV R3,#2</span><br><span class="line">ADD R1,R3,R2;R1 = R3 - R2</span><br></pre></td></tr></table></figure><p>位操作指令AND&#x2F;BIC&#x2F;ORR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, =0XFFFFFFFF</span><br><span class="line">AND R0,R0,#(1&lt;&lt;4);与：只保留第四位</span><br><span class="line">LDR R0, =0XFFFFFFFF</span><br><span class="line">BIC R0,R0,#(1&lt;&lt;4);位清除：清除第四位</span><br><span class="line">LDR R0, =0</span><br><span class="line">ORR R0,#(1&lt;&lt;2|1&lt;&lt;3);或：设置第2、3位为1</span><br></pre></td></tr></table></figure><p>比较指令CMP&#x2F;TST</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, =0X12</span><br><span class="line">LDR R1, =0X12</span><br><span class="line">CMP R0,R1;比较R0-R1里面的结果，结果存放在程序装载寄存器</span><br><span class="line">MOVEQ R0, #2；如果相等，执行这条指令，R0=2</span><br><span class="line"></span><br><span class="line">TST R0,R1;测试R0&amp;R1的结果</span><br></pre></td></tr></table></figure><h3 id="3-跳转指令"><a href="#3-跳转指令" class="headerlink" title="3.跳转指令"></a>3.跳转指令</h3><ul><li><p>B：Branch，跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B Delay</span><br><span class="line">Delay</span><br><span class="line">MOV R0, #5</span><br><span class="line">Loop</span><br><span class="line">SUBS R0,R0,#1</span><br><span class="line">BNE Loop;不等于0就一直循环</span><br><span class="line">MOV PC, LR;结束，将LR值返回给PC</span><br></pre></td></tr></table></figure></li><li><p>BL：Branch with Link，跳转前先把返回地址保持在LR寄存器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BL Delay</span><br><span class="line">MOV R1, #1;执行完之后会直接跳转到这条指令 PC=LR+4</span><br><span class="line">Delay</span><br><span class="line">MOV R0, #5</span><br><span class="line">Loop</span><br><span class="line">SUBS R0,R0,#1</span><br><span class="line">BNE Loop;不等于0就一直循环</span><br><span class="line">MOV PC, LR;结束，将LR值返回给PC</span><br></pre></td></tr></table></figure></li><li><p>BX：Branch and eXchange，根据跳转地址的BIT0切换为ARM或Thumb状态(0：ARM状态，1：Thumb状态)</p></li><li><p>BLX：Branch with Link and eXchange ，根据跳转地址的BIT0切换为ARM或Thumb状态(0：ARM状态，1：Thumb状态)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法基础教程</title>
      <link href="/2023/10/19/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2023/10/19/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h1><p>快捷键：</p><ul><li>一级标题：ctrl+1</li><li>二级标题：ctrl+2</li><li>三级标题：ctrl+3</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><h1 id="2、加黑"><a href="#2、加黑" class="headerlink" title="2、加黑"></a>2、加黑</h1><p>快捷键：ctrl+B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**加黑**</span><br></pre></td></tr></table></figure><h1 id="3、高亮"><a href="#3、高亮" class="headerlink" title="3、高亮"></a>3、高亮</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==高亮==</span><br></pre></td></tr></table></figure><h1 id="4、输入代码"><a href="#4、输入代码" class="headerlink" title="4、输入代码"></a>4、输入代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​```markdown </span><br></pre></td></tr></table></figure><h1 id="5、图片选项"><a href="#5、图片选项" class="headerlink" title="5、图片选项"></a>5、图片选项</h1><ul><li>点击左上角“文件”</li><li>进入“偏好设置”</li><li>点击图像，选择复制图像到当前文件夹</li><li>勾选下面的前三个选项</li></ul><h1 id="6、实心黑点（实心圆圈和空心圆）"><a href="#6、实心黑点（实心圆圈和空心圆）" class="headerlink" title="6、实心黑点（实心圆圈和空心圆）"></a>6、实心黑点（实心圆圈和空心圆）</h1><ul><li>先按shift+tab，让光标回到行首</li><li>按下一个减号（-），然后再按一个空格即可</li><li><strong>空心圆：</strong>在按下适应黑点后，再按一个tab键即可</li></ul><h1 id="7、更改字体大小和样式"><a href="#7、更改字体大小和样式" class="headerlink" title="7、更改字体大小和样式"></a>7、更改字体大小和样式</h1><ul><li><strong>字体大小</strong>：偏好设置里面自定义设置</li><li><strong>字体样式</strong>：打开主题文件夹。我们需要打开 .css文件更改里面的内容才可以！<strong>可以使用 notepad++编辑！</strong></li></ul><h1 id="8、小条状标题：-加空格"><a href="#8、小条状标题：-加空格" class="headerlink" title="8、小条状标题：&gt; 加空格"></a>8、小条状标题：&gt; 加空格</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; </span><br></pre></td></tr></table></figure><ul><li>打开<strong>github.css</strong>文件</li><li>找到blockquote，修改solid的值即可</li></ul><h1 id="9、图片"><a href="#9、图片" class="headerlink" title="9、图片"></a>9、图片</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 本地图片</span><br><span class="line">&lt;img src=&quot;/assets/pusheencode.webp&quot; alt=&quot;示例图片&quot; style=&quot;zoom:50%;&quot; /&gt;  #无法使用</span><br><span class="line">![](图片名)</span><br><span class="line"># 在线图片</span><br><span class="line">![code](https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png)</span><br><span class="line">#hexo插入图片的方法</span><br><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
