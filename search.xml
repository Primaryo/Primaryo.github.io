<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="何为进程和线程"><a href="#何为进程和线程" class="headerlink" title="何为进程和线程"></a>何为进程和线程</h2><ul><li><p>进程</p><p>是<strong>资源分配</strong>的最小单位，它是程序执行时的一个实例，在程序运行时创建</p></li><li><p>线程</p><p>是<strong>程序执行</strong>的最小单位，也是<strong>处理器调度</strong>的基本单位，是进程的一个执行流，<strong>一个进程由多个线程组成的</strong></p></li></ul><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li><p><strong>进程有自己的独立地址空间</strong>，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代 码段、堆栈段和数据段，这种操作非常昂贵；而<strong>线程是共享进程中的数据</strong>，<strong>使用相同的地址空间</strong>， 因此，CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也比进程小很多</p></li><li><p><strong>线程之间的通信更方便</strong>，同一进程下的线程共享全局变量、静态变量等数据，而<strong>进程之间的通信需 要以通信的方式（IPC）进行</strong>。不过如何处理好同步与互斥是编写多线程程序的难点。但是<strong>多进程程序更健壮</strong>，<strong>多线程程序只要有一个线程死掉，整个进程也跟着死掉了，而一个进程死掉并不会对另 外一个进程造成影响，因为进程有自己独立的地址空间</strong>**</p></li><li><p><strong>进程切换时，消耗的资源大，效率低</strong>。所以涉及到频繁的切换时，使用线程要好于进程。同样如果 要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程</p></li><li><p>执行过程：<strong>每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口</strong>。但是<strong>线程不能独立执行</strong>，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p></li><li><p><strong>线程执行开销小，但是不利于资源的管理和保护</strong>。线程适合在SMP机器（双CPU系统）上运行。进<strong>程执行开销大，但是能够很好的进行资源管理和保护</strong>，可以跨机器迁移。</p></li></ul><h2 id="何时使用多进程，何时使用多线程？"><a href="#何时使用多进程，何时使用多线程？" class="headerlink" title="何时使用多进程，何时使用多线程？"></a>何时使用多进程，何时使用多线程？</h2><p>对资源的管理和保护要求高，不限制开销和效率时，使用<strong>多进程</strong>。 </p><p>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用<strong>多线程</strong>。</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231212142116596.png" alt="image-20231212142116596"></p><ul><li><p>创建态</p><p>一个应用程序从系统上启动，首先就是进入创建状态，需要获取系统资源创建进程管理块（PCB： Process Control Block）完成资源分配</p></li><li><p>就绪态</p><p>在创建状态完成之后，进程已经准备好，但是还未获得处理器资源，无法运行</p></li><li><p>运行态</p><p>获取处理器资源，被系统调度，开始进入运行状态。如果进程的时间片用完了就进入就绪状态</p></li><li><p>阻塞态</p><p>在运行状态期间，如果进行了阻塞的操作，如耗时的I&#x2F;O操作，此时进程暂时无法操作就进入到了阻塞状 态，在这些操作完成后就进入就绪状态</p></li><li><p>终止态</p><p>进程结束或者被系统终止，进入终止状态</p></li></ul><h2 id="linux创建进程的方式"><a href="#linux创建进程的方式" class="headerlink" title="linux创建进程的方式"></a>linux创建进程的方式</h2><ul><li><p><strong>fork创建</strong></p><p>⼀个进程时，⼦进程只是完全复制⽗进程的资源，复制出来的⼦进程 有⾃⼰的t ask_struct结构和pi d, 但却复制⽗进程其它所有的资源。 </p></li><li><p><strong>vfork创建：</strong></p><p>系统调⽤不同于fork，⽤vfork创建的⼦进程与⽗进程共享地址空间， 也就是说⼦进程完全运⾏在⽗进程的地址空间上，如果这时⼦进程修改了某个变量， 这将影响到⽗进程 </p></li><li><p><strong>clone（）是带有参数的</strong></p></li></ul><p><strong>fork( ) 是全部复制，vfor k( ) 是共享内存，⽽clone( ) 是则可以将⽗进程资源有选择地复制给⼦进程</strong></p><h2 id="进程间的通信方式以及特点"><a href="#进程间的通信方式以及特点" class="headerlink" title="进程间的通信方式以及特点"></a>进程间的通信方式以及特点</h2><ul><li><p>管道（pipe ）</p><ul><li><p>管道（无名管道）</p><p>这种通讯方式<strong>有两种限制</strong>，<strong>一是</strong>半双工的通信，数据只能单向流动，<strong>二是</strong>只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系</p></li><li><p>流管道（s_pipe）</p><p>去除了第一种限制,<strong>可以双向传输</strong>（全双工）</p></li><li><p>命名管道（FIFO）</p><p>克服了管道没有名字的限制，因此，除 具有管道所具有的功能外，它还<strong>允许无亲缘关系进程间的通信</strong></p></li></ul></li><li><p>信号量（semaphore）</p><p>信号量是一个<strong>计数器</strong>，可以用来<strong>控制多个进程对共享资源的访问</strong>。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为<strong>进程间</strong>以及<strong>同一进程内不同线程之间</strong>的同步手段</p></li><li><p>消息队列（message queue）</p><p><strong>消息队列是由消息组成的链表</strong>，存放在内核中并由消息队列标识符标识。</p><p>消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加 消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承 载无格式字节流以及缓冲区大小受限等缺点。</p><p>息发送后可以⽴即返回，有消息系统来确保信息的可靠专递，消息发布者只管把消息发布到MQ中⽽不管谁来取， 消息使⽤者只管从MQ中取消息⽽不管谁发布的，这样发布者和使⽤者都不⽤知道对⽅的存在。</p></li><li><p>信号</p><p>信号是通讯⽅式，信号量是⼀个计数器，限制资源访问线程的数</p><p>信号是一种比较复杂的通信方式，用于<strong>通知接收进程某个事件已经发生</strong>。主要作为进程间以及同一进程 不同线程之间的同步手段。</p></li><li><p>共享内存</p><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以 访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与 其他通信机制，如信号量，配合使用，来实现进程间的同步和通信</p></li><li><p>套字节</p><p>套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信</p><p>由I P地址可以唯⼀确定⼀台主机，但是准确来说，⽹络通讯中的双⽅并不是主机，⽽是运⾏在主机上的进程， 这样就需要进⼀步确定是主机中的哪个进程要进⾏⽹络通讯。因此，除了I P地址之外，还需要端⼝号来唯⼀确定主机中的通讯进程。 I P地址和端⼝号就构成了⼀个⽹络中的唯⼀标识符，即套接字</p></li></ul><p><strong>各通信方式的比较和优缺点：</strong></p><ul><li>管道 ：速度慢，容量有限，只有父子进程能通讯</li><li>FIFO ：任何进程间都能通讯，但速度慢。</li><li>消息队列 ：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题，消息队列可以不再 局限于父子进程，而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息 发送和接收之间的同步，从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用方便， 但是<strong>信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合</strong>。此种方法不太常用</li><li>信号量 ：不能用来传递复杂消息，只能用来同步</li><li>共享内存：利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。共享内存块提供了在任意数量的 进程之间进行高效双向通信的机制。每个使用者都可以读取写入数据，但是所有程序之间必须达成并遵 守一定的协议，以防止诸如在读取信息之前覆写内存空间等竞争状态的出现</li></ul><p><strong>进程间通信方式的选择</strong>：</p><p>PIPE和FIFO(有名管道)用来实现进程间相互发送非常短小的、频率很高的消息，这两种方式通常适用于 <strong>两个进程间</strong>的通信。</p><p>共享内存用来实现进程间共享的、非常庞大的、读写操作频率很高的数据；这种方法适用于<strong>多进程间</strong>的 通信。</p><p>其他考虑用socket。主要应用在分布式开发中</p><h2 id="线程间的同步方式"><a href="#线程间的同步方式" class="headerlink" title="线程间的同步方式"></a>线程间的同步方式</h2><p>现在流行的进程线程同步互斥的控制机制，其实是由最原始、最基本的4种方法（临界区、互斥量、信号 量和事件）实现的</p><ul><li><p>临界区</p><p>通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意 时刻只允许一个线程访问共享资源，如果有多个线程试图访问共享资源，那么当有一个线程进入 后，其他试图访问共享资源的线程将会被挂起，并一直等到进入临界区的线程离开，临界在被释放 后，其他线程才可以抢占</p></li><li><p>互斥量</p><p>为协调对一个共享资源的单独访问而设计，只有拥有互斥量的线程，才有权限去访问系统 的公共资源，因为互斥量只有一个，所以能够保证资源不会同时被多个线程访问。互斥不仅能实现 同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享</p></li><li><p>信号量</p><p>为控制一个具有有限数量的用户资源而设计。它允许多个线程在同一个时刻去访问同一个 资源，但一般需要限制同一时刻访问此资源的最大线程数目</p></li><li><p>事件</p><p>用来通知线程有一些事件已发生，从而启动后继任务的开始</p></li></ul><h2 id="内核线程和用户线程"><a href="#内核线程和用户线程" class="headerlink" title="内核线程和用户线程"></a>内核线程和用户线程</h2><ul><li><p>内核线程</p><p>由操作系统内核创建和撤销。内核维护进程及线程的上下文信息以及线程切换。一个内核线 程由于I&#x2F;O操作而阻塞，不会影响其它线程的运行</p></li><li><p>用户线程、</p><p>不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态&#x2F;核心态切换，速度快，操作 系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这 里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少</p></li></ul><h2 id="内核线程和用户线程的优缺点"><a href="#内核线程和用户线程的优缺点" class="headerlink" title="内核线程和用户线程的优缺点"></a>内核线程和用户线程的优缺点</h2><ol><li>内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。 </li><li>用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核 支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同 的。 </li><li>用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时， 只导致该线程被中断。 </li><li>在只有<strong>用户级线程的系统</strong>内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由 用户程序控制线程的轮换运行；在有<strong>内核支持线程的系统</strong>内，CPU调度则以线程为单位，由OS的线 程调度程序负责线程的调度。 </li><li>用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何 状态下的程序。</li></ol><p><strong>内核线程的优点：</strong> 当有多个处理机时，一个进程的多个线程可以同时执行。</p><p><strong>内核线程的缺点：</strong> 由内核进行调度。</p><p><strong>用户线程的优点：</strong></p><ol><li>线程的调度不需要内核直接参与，控制简单。 </li><li>可以在不支持线程的操作系统中实现。 </li><li>创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。 </li><li>允许每个进程定制自己的调度算法，线程管理比较灵活。这就是必须自己写管理程序，与内核线程 的区别 </li><li>线程能够利用的表空间和堆栈空间比内核级线程多。 </li><li>同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都 会被挂起。另外，页面失效也会产生同样的问题。</li></ol><p><strong>用户线程的缺点：</strong>资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</p><h2 id="僵尸进程、孤儿进程、守护进程"><a href="#僵尸进程、孤儿进程、守护进程" class="headerlink" title="僵尸进程、孤儿进程、守护进程"></a>僵尸进程、孤儿进程、守护进程</h2><ul><li><p>僵尸进程</p><p>是 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子 进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程</p><p>fork的本质，就是复制，把当前进程复制⼀份，然后两个进程并发地执⾏for k后⾯的语句，</p></li><li><p>孤儿进程</p><p>⽗进程结束了，⽽它的⼀个或多个⼦进程还在运⾏，那么这些⼦进程就成为孤⼉进程(fat her di ed) 。⼦进程的资源由init进程( 进程号PID &#x3D; 1) 回收</p></li><li><p>守护进程</p><p>建守护进程时有意把父进程结束，然后被1号进程init收养</p><p>是运⾏在后台的⼀种特殊进程。它独⽴于控制终端并且周期性地执⾏某种任务或等待处理某些发⽣的事件</p></li></ul><p><strong>区分：</strong> 一个正常运行的子进程，如果此刻子进程退出，父进程没有及时调用wait或waitpid收回子进程 的系统资源，该进程就是僵尸进程，如果系统收回了，就是正常退出，如果一个正常运行的子进程，父 进程退出了但是子进程还在，该进程此刻是孤儿进程，被init收养，如果父进程是故意被杀掉，子进程做 相应处理后就是守护进程</p><h2 id="僵尸进程的危害"><a href="#僵尸进程的危害" class="headerlink" title="僵尸进程的危害"></a>僵尸进程的危害</h2><p>在进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留 一定的信息(包括进程号 PID，退出状态 the termination status of the process，运行时间 the amount  of CPU time taken by the process 等)。直到父进程通过 wait &#x2F; waitpid 来取时才释放。 </p><p>如果进程不调用 wait &#x2F; waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但 是系统所能使用的进程号是有限的，<strong>如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不 能产生新的进程</strong></p><h2 id="如何清理僵尸进程"><a href="#如何清理僵尸进程" class="headerlink" title="如何清理僵尸进程"></a>如何清理僵尸进程</h2><p>僵尸进程的产生是因为父进程没有 wait() 子进程。所以如果我们自己写程序的话一定要在父进程中通过  wait() 来避免僵尸进程的产生</p><p>当系统中出现了僵尸进程时，我们是无法通过 kill 命令把它清除掉的。但是我们可以杀死它的父进程， 让它变成孤儿进程，并进一步被系统中管理孤儿进程的进程收养并清理。</p><p>1.kill 杀死元凶⽗进程( ⼀般不⽤) 严格的说，僵⼫进程并不是问题的根源，罪魁祸⾸是产⽣⼤量僵死进程的⽗进程。 因此，我们可以直接除掉元凶，通过ki l l 发送SI GTERM或者SI GKI LL信号。元凶死后，僵⼫进程进程变成孤⼉进程，由i ni t充当⽗进程，并回收资源。 或者运⾏：ki l l -9 ⽗进程的pi d值</p><p>2.⽗进程⽤wai t或wai tpi d去回收资源( ⽅案不好) ⽗进程通过wai t或wai tpi d等函数去等待⼦进程结束，但是不好，会导致⽗进程⼀直等待被挂起，相当于⼀个进程在⼲活，没有起到多进程的作⽤。 </p><p>3.通过信号机制，在处理函数中调⽤wai t，回收资源 通过信号机制，⼦进程退出时向⽗进程发送SI GCHLD信号，⽗进程调⽤si gnal ( SI GCHLD, si g_chi l d) 去处理SI GCHLD信号， 在信号处理函数si g_chi l d( ) 中调⽤wai t进⾏处理僵⼫进程。什么时候得到⼦进程信号，什么时候进⾏信号处理，⽗进程可以继续⼲其他活，不⽤去阻塞等待。</p><h2 id="如何唤醒被阻塞的socket线程"><a href="#如何唤醒被阻塞的socket线程" class="headerlink" title="如何唤醒被阻塞的socket线程"></a>如何唤醒被阻塞的socket线程</h2><ul><li><p>同步阻塞</p><p>等待锁的释放</p></li><li><p>等待阻塞</p><ul><li>使用Thread.sleep造成的阻塞:时间结束后自动进入RUNNABLE状态 </li><li>使用Thread.wait造成的阻塞:使用Thread.notify或者Thread.notifyAll唤醒 </li><li>使用Thread.join造成的阻塞:等待上一个线程执行完后自动进入RUNNABLE状态 </li><li>使用Thread.suspend造成的阻塞:使用Thread.resum唤醒 </li><li>使用LockSupport.park造成的阻塞:使用LockSupport.unpark唤醒 </li><li>使用LockSupport.parkNanos造成的阻塞:指定时间结束后，自动唤醒 </li><li>使用LockSupport.parkUntil造成的阻塞:到达指定的时间，自动唤醒</li></ul></li></ul><h2 id="确定当前线程是繁忙还是阻塞"><a href="#确定当前线程是繁忙还是阻塞" class="headerlink" title="确定当前线程是繁忙还是阻塞"></a>确定当前线程是繁忙还是阻塞</h2><p>使用ps命令查看</p><h2 id="空闲和阻塞的进程会在唤醒的时候判误吗"><a href="#空闲和阻塞的进程会在唤醒的时候判误吗" class="headerlink" title="空闲和阻塞的进程会在唤醒的时候判误吗"></a>空闲和阻塞的进程会在唤醒的时候判误吗</h2><p>不会。每个进程有个进程控制块PCB，两种状态的进程分别处于两种队列。唤醒应该是找阻塞队列的进 程</p><h2 id="就绪态的进程在等待什么"><a href="#就绪态的进程在等待什么" class="headerlink" title="就绪态的进程在等待什么"></a>就绪态的进程在等待什么</h2><p>被调度使用cpu的运行权</p><h2 id="如何实现线程池"><a href="#如何实现线程池" class="headerlink" title="如何实现线程池"></a>如何实现线程池</h2><ol><li>设置一个生产者消费者队列，作为临界资源 </li><li>初始化n个线程，并让其运行起来，加锁去队列取任务运行 </li><li>当任务队列为空的时候，所有线程阻塞 </li><li>当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻 塞中的一个线程</li></ol><h2 id="fork和vfork"><a href="#fork和vfork" class="headerlink" title="fork和vfork"></a>fork和vfork</h2><p><strong>fork的基础知识：</strong></p><p>创建一个和当前进程映像一样的进程可以通过fork( )系统调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br></pre></td></tr></table></figure><p><strong>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续 运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错 误，fork( )返回一个负值</strong>。 最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二 进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一 个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。 在早期的Unix系统 中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表 项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐 页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的 方法，而不是对父进程空间进程整体复制。</p><p><strong>vfork的基础知识：</strong></p><p>在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成 的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t vfork(void);</span><br></pre></td></tr></table></figure><p>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用 所产生的结果和fork( )是一样的。vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行 文件的映像。通过这样的方式，vfork( )避免了地址空间的按页复制。在这个过程中，父进程和子 进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。 因此，子进程也就不能修改地址空间中的任何内存。 vfork( )是一个历史遗留产物，Linux本 不应该实现它。需要注意的是，即使<strong>增加了写时复制，</strong>vfork( )也要比fork( )快，因为它没有进行页 表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork(  )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可 行的。 </p><p><strong>fork和vfork的区别：</strong> </p><ol><li>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段 </li><li>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程 数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。 </li><li>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个 函数之前子进程依赖于父进程的进一步动作，则会导致死锁。  </li><li>当需要改变共享数据段中变量的值，则拷贝父进程。</li></ol><h2 id="server端监听端口，此时进程处于什么状态"><a href="#server端监听端口，此时进程处于什么状态" class="headerlink" title="server端监听端口，此时进程处于什么状态"></a>server端监听端口，此时进程处于什么状态</h2><p>最普通的Server模型，则处于阻塞状态；如果使用IO复用中epoll、select等，则处于运行状态</p><h2 id="阻塞态和挂起态"><a href="#阻塞态和挂起态" class="headerlink" title="阻塞态和挂起态"></a>阻塞态和挂起态</h2><p>线程在运⾏的过程中因为某些原因⽽发⽣阻塞，阻塞状态的线程的特点是：该线程放弃CPU的使⽤， 暂停运⾏，只有等到导致阻塞的原因消除之后才回复运⾏。或者是被其他的线程中断，该线程也会退出阻塞状态. 正在执⾏的进程由于发⽣某时间（如I &#x2F;O请求、申请缓冲区失败等）暂时⽆法继续执⾏。此时引起进程调度， OS把处理机分配给另⼀个就绪进程，⽽让受阻进程处于暂停状态，⼀般将这种状态称为阻塞状态。</p><p>挂起进程在操作系统中可以定义为暂时被淘汰出内存的进程，机器的资源是有限的，在资源不⾜的情况下， 操作系统对在内存中的程序进⾏合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存， 重新进⼊等待被执⾏的状态即就绪态</p><p>共同点： 1. 进程都暂停执⾏ 2. 进程都释放CPU，即两个过程都会涉及上下⽂切换</p><h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><h2 id="代码段、数据段、bss段、堆、栈"><a href="#代码段、数据段、bss段、堆、栈" class="headerlink" title="代码段、数据段、bss段、堆、栈"></a>代码段、数据段、bss段、堆、栈</h2><ul><li><p><strong>代码段</strong></p><p>代码段通常用来存放程序<strong>执行代码</strong>的一块区域。这部分区域的大小在程序运行前就已经确定了，通常这块内存区域属于只读，有些架构也允许可写，在代码段中也有可能包含以下只读的常数变量，例如字符串常量等。程序段为程序代码在内存中映射一个程序可以在内存中有多个副本</p></li><li><p><strong>数据段</strong></p><p>数据段通常用来存放程序中<strong>已初始化的全局变量和已初始化为非0的静态变量</strong>的一块内存区域，属于静态内存分配。直观理解就是C语言程序中的全局变量（注意：<strong>全局变量才算是程序的数据， 局部变量不算程序的数据，只能算是函数的数据</strong>）</p></li><li><p><strong>bss段</strong></p><p>bss段通常是指用来存放程序中<strong>未初始化的全局变量和未初始化的静态变量或者初始化为0的静 态变量</strong>一块区域。bss英文Block started by symbol，bss属于静态内存分配。bss段的特点就是被初始 化为0，<strong>bss段本质上也是属于数据段</strong>，bss段就是被初始化为0的数据段。 注意区分</p><p><strong>数据段（.data）和bss段的区别和联系：</strong>二者本来没有本质区别，都是用来存放C程序中的全局变量的。区别在于把显示初始化为非零的全局变量存在**.data段<strong>中，而把显式初始化为0或者并未显式 初始化（C语言规定未显式初始化的全局变量值默认为0）的全局变量存在</strong>bss段**</p></li><li><p><strong>堆</strong></p><p>堆是用来存放进程中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用 malloc等函数分配内存时，新分配的内存就被动态分配到堆上，当利用free等函数释放内存时，被释放 的内存从堆中被剔除</p></li><li><p><strong>栈</strong></p><p>栈又称堆栈，是用户存放程序临时创建的变量，也就是我们函数{}中定义的变量，但不包括static声 明的变量，static意味着在数据段中存放变量。除此之外，在函数被调用时，其参数也会被压入发起调用 的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中，由于栈的先进后出特点，所以栈 特别方便用来保存、恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存，交换临时数据的 内存区</p></li></ul><h2 id="为什么堆的空间不连续"><a href="#为什么堆的空间不连续" class="headerlink" title="为什么堆的空间不连续"></a>为什么堆的空间不连续</h2><p>堆包含一个链表来维护已用和空闲的内存块。在堆上新分配（用 new 或者 malloc）内存是从空闲的内 存块中找到一些满足要求的合适块。所以可能让人觉得只要有很多不连续的零散的小区域，只要总数达 到申请的内存块，就可以分配。</p><p>但事实上是不行的，这又让人觉得是不是零散的内存块不能连接成一个大的空间，而必须要一整块连续 的内存空间才能申请成功呢</p><p>申请和释放许多小的块可能会产生如下状态：在已用块之间存在很多小的空闲块。进而申请大块内存失 败，虽然空闲块的总和足够，但是<strong>空闲的小块是零散的，不连续的</strong>，不能满足申请的大小，这叫做“堆碎 片”</p><p>当旁边有空闲块的已用块被释放时，新的空闲块会与相连的空闲块合并成一个大的空闲块，这样就可以 有效的减少”堆碎片”的产生</p><p><strong>堆分配的空间在逻辑地址（虚拟地址）上是连续的，但在物理地址上是不连续的</strong>（因为采用了页式内存 管理,windows下有段机制、分页机制），如果逻辑地址空间上已经没有一段连续且足够大的空间，则分 配内存失败</p><h2 id="用户栈和内核栈"><a href="#用户栈和内核栈" class="headerlink" title="用户栈和内核栈"></a>用户栈和内核栈</h2><ul><li><p>内核栈、</p><p>内存中属于操作系统空间的一块区域</p><p>作用：</p><pre><code>1. 保存中断现场，对于嵌套中断，被中断程序的现场信息一次压入系统栈，中断返回时逆序弹出 2. 保存操作系统程序相互调用的参数，返回值，以及函数的局部变量</code></pre></li><li><p>用户栈</p><p>用户进程空间的一块区域，用于保存用户空间子程序间调用的参数，返回值以及局部变量。</p></li></ul><h2 id="为什么用户栈和内核栈不能共用一个栈"><a href="#为什么用户栈和内核栈不能共用一个栈" class="headerlink" title="为什么用户栈和内核栈不能共用一个栈"></a>为什么用户栈和内核栈不能共用一个栈</h2><ol><li>如果只用系统栈，系统栈一般大小有限，用户程序调用次数可能很多。如果中断有16个优先级，那 么系统栈一般大小为15（只需保存15个低优先级中断，另一个高优先级中断在运行）用户程序调用 次数很多，那样15次子程序调用以后的子程序的参数，返回值，局部变量就不能保存，用户程序也 就不能正常运行。</li><li>如果只用用户栈，系统程序需要在某种保护下运行，而用户栈在用户空间不能提供相应的保护措 施</li></ol><h2 id="线程是否有相同的堆栈"><a href="#线程是否有相同的堆栈" class="headerlink" title="线程是否有相同的堆栈"></a>线程是否有相同的堆栈</h2><p>真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。 每个线程有自己的堆栈</p><h1 id="并发和互斥"><a href="#并发和互斥" class="headerlink" title="并发和互斥"></a>并发和互斥</h1><h2 id="并发和互斥如何实现"><a href="#并发和互斥如何实现" class="headerlink" title="并发和互斥如何实现"></a>并发和互斥如何实现</h2><p>并发，指的是多个执行单元同时、并行被执行，而并发的执行单元对共享资源（硬件资源和软件上的全 局变量、静态变量等）的访问则很容易导致竞态</p><p>解决竞态问题的途径是保证对共享资源的互斥访问，所谓互斥访问就是指一个执行单元在访问共享资源 的时候，其他的执行单元都被禁止访问</p><p>访问共享资源的代码区域被称为临界区，临界区需要以某种互斥机制加以保护。中断屏蔽，原子操作， 自旋锁，和信号量都是linux设备驱动中可采用的互斥途径</p><h2 id="自旋锁、信号量"><a href="#自旋锁、信号量" class="headerlink" title="自旋锁、信号量"></a>自旋锁、信号量</h2><ul><li><p><strong>自旋锁</strong></p><p>自旋锁，顾名思义，我们可以把他理解成厕所门上的一把锁。这个厕所门只有一把钥匙，当我们进去 时，把钥匙取下来，进去后反锁。那么当第二个人想进来，必须等我们出去后才可以。当第二个人在外 面等待时，可能会一直等待在门口转圈。 </p><p>我们的自旋锁也是这样，自旋锁只有锁定和解锁两个状态。当我们进入拿上钥匙进入厕所，这就相当于 自旋锁锁定的状态，期间谁也不可以进来。当第二个人想要进来，这相当于线程B想要访问这个共享资 源，但是目前不能访问，所以线程B就一直在原地等待，一直查询是否可以访问这个共享资源。当我们 从厕所出来后，这个时候就“解锁”了，只有再这个时候线程B才能访问。 </p><p>假如，在厕所的人待的时间太长怎么办？外面的人一直等待吗？如果换做是我们，肯定不会这样，简直 浪费时间，可能我们会寻找其他方法解决问题。自旋锁也是这样的，如果线程A<strong>持有自旋锁时间过长， 显然会浪费处理器的时间，降低了系统性能</strong>。我们知道CPU最伟大的发明就在于多线程操作，这个时候 让线程B在这里傻傻的不知道还要等待多久，显然是不合理的。因此，如果<strong>自旋锁只适合短期持有</strong>，如果遇到需要长时间持有的情况，我们就要换一种方式了（互斥体）</p></li><li><p><strong>信号量</strong></p><p>信号量和自旋锁有些相似，不同的是信号量会发出一个信号告诉你还需要等多久。因此，不会出现傻傻 等待的情况。比如，有100个停车位的停车场，门口电子显示屏上实时更新的停车数量就是一个信号 量。这个停车的数量就是一个信号量，他告诉我们是否可以停车进去。当有车开进去，信号量加一，当 有车开出来，信号量减一</p><p>比如，厕所一次只能让一个人进去，当A在里面的时候，B想进去，如果是自旋锁，那么B就会一直在门 口傻傻等待。如果是信号量，A就会给B一个信号，你先回去吧，我出来了叫你。这就是一个信号量的例 子，B听到A发出的信号后，可以先回去睡觉，等待A出来</p><p>因此，信号量显然可以提高系统的执行效率，避免了许多无用功。</p></li><li><p><strong>区别</strong></p><ol><li>由于争用信号量的进程在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情 况。 </li><li>相反，锁被短时间持有时，使用信号量就不太适宜了，因为睡眠引起的耗时可能比锁被占用的全部 时间还要长。 </li><li>由于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号量锁，因为在中断上下 文中（使用自旋锁）是不能进行调度的。 </li><li>你可以在持有信号量时去睡眠（当然你也可能并不需要睡眠），因为当其它进程试图获得同一信号 量时不会因此而死锁，（因为该进程也只是去睡眠而已，而你最终会继续执行的）。 </li><li>在你占用信号量的同时不能占用自旋锁，因为在你等待信号量时可能会睡眠，而在持有自旋锁时是 不允许睡眠的</li><li>信号量锁保护的临界区可包含可能引起阻塞的代码，而自旋锁则绝对要避免用来保护包含这样代码 的临界区，因为阻塞意味着要进行进程的切换，如果进程被切换出去后，另一进程企图获取本自旋 锁，死锁就会发生。 </li><li>信号量不同于自旋锁，它不会禁止内核抢占（自旋锁被持有时，内核不能被抢占），所以持有信号 量的代码可以被抢占，这意味着信号量不会对调度的等待时间带来负面影响</li></ol></li></ul><h2 id="自旋锁和信号量可以睡眠吗"><a href="#自旋锁和信号量可以睡眠吗" class="headerlink" title="自旋锁和信号量可以睡眠吗"></a>自旋锁和信号量可以睡眠吗</h2><p>自旋锁不能睡眠，信号量可以</p><p>自旋锁自旋锁禁止处理器抢占；而信号量不禁止处理器抢占</p><p>基于这个原因，如果自旋锁在锁住以后进入睡眠，由于不能进行处理器抢占，其他系统进程将都不能获 得CPU而运行，因此不能唤醒睡眠的自旋锁，因此系统将不响应任何操作（除了中断或多核的情况，下 面会讨论）。而信号量在临界区睡眠后，其他进程可以用抢占的方式继续运行，从而可以实现内存拷贝 等功能而使得睡眠的信号量程序由于获得了等待的资源而被唤醒，从而恢复了正常的代码运行</p><p>当然，自旋锁的睡眠的情况包含考虑多核CPU和中断的因素。自旋锁睡眠时，只是当前CPU的睡眠以及 当前CPU的禁止处理器抢占，所以，如果存在多个CPU，那么其他活动的CPU可以继续运行使操作系统 功能正常，并有可能完成相应工作而唤醒睡眠了的自旋锁，从而没有造成系统死机；自旋锁睡眠时，如 果允许中断处理，那么中断的代码是可以正常运行的，但是中断通常不会唤醒睡眠的自旋锁，因此系统 仍然运行不正常</p><h2 id="自旋锁和信号量可以用于中断中吗？"><a href="#自旋锁和信号量可以用于中断中吗？" class="headerlink" title="自旋锁和信号量可以用于中断中吗？"></a>自旋锁和信号量可以用于中断中吗？</h2><p>信号量不能用于中断中，因为信号量会引起休眠，<strong>中断不能休眠</strong></p><p>自旋锁可以用于中断。在获取锁之前<strong>一定要先禁止本地中断</strong>（也就是本CPU中断，对于多核SOC来说会 有多个CPU核），否则可能导致锁死现象的发生</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>临界区的一个文件可以被<strong>同时读取</strong>，但是并不能被同时读和写。如果一个线程在读，另一个线程在 写，那么很可能会读取到错误的不完整的数据。读写自旋锁是可以<strong>允许对临界区的共享资源进行并发读操作的。但是并不允许多个线程并发读写操作</strong></p><h2 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h2><p><strong>多个并发进程因争夺系统资源而产生相互等待的现象</strong>。即：一组进程中的每个进程都在等待某个事件发 生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。</p><p>死锁: 是指多个线程因竞争资源⽽造成的⼀种僵局（互相等待）</p><p><strong>产生死锁的本质原因为：</strong></p><ol><li>系统资源有限。 </li><li>进程推进顺序不合理。</li><li>信号量使⽤不当也会造成死锁。进程间彼此相互等待对⽅发来的消息，结果也会使得这 些进程间⽆法继续向前推进。例如， 进程A等待进程B发的消息，进程B⼜在等待进程A 发的消息，可以看出进程A和B不是因为竞争同⼀资源，⽽是在等待对⽅的资源导致死锁。</li></ol><h2 id="死锁的四个必要的条件"><a href="#死锁的四个必要的条件" class="headerlink" title="死锁的四个必要的条件"></a>死锁的四个必要的条件</h2><p>产⽣死锁必须同时满⾜以下四个条件，只要其中任⼀条件不成⽴，死锁就不会发⽣。</p><ol><li><strong>互斥</strong>：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访 问，直到该进程访问结束。</li><li><strong>占有且等待</strong>：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进 程释放该资源。</li><li><strong>不可抢占</strong>：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。 </li><li><strong>循环等待</strong>：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源</li></ol><p>当以上四个条件均满足，必然会造成死锁，发生死锁的进程无法进行下去，它们所持有的资源也无 法释放。这样会导致CPU的吞吐量下降。所以死锁情况是会浪费系统资源和影响计算机的使用性能的。 那么，解决死锁问题就是相当有必要的了</p><h2 id="死锁的处理方式"><a href="#死锁的处理方式" class="headerlink" title="死锁的处理方式"></a>死锁的处理方式</h2><p>死锁的处理方式主要从预防死锁、避免死锁、检测与解除死锁这四个方面来进行处理</p><ul><li><p>预防死锁</p></li><li><p>避免死锁</p></li><li><p>检测死锁</p><p>首先为每个进程和每个资源指定一个唯一的号码；然后建立资源分配表和进程等待表</p></li><li><p>解除死锁</p></li></ul><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><ul><li>加锁顺序（线程按照一定的顺序加锁）</li><li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的 锁）</li><li>死锁检测</li></ul><h2 id="单核机器上写多线程程序是否需要加锁"><a href="#单核机器上写多线程程序是否需要加锁" class="headerlink" title="单核机器上写多线程程序是否需要加锁"></a>单核机器上写多线程程序是否需要加锁</h2><p>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机 器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时 间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某 些数据，不使用线程锁的前提下，<strong>可能会导致共享数据修改引起冲突</strong></p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="1G的计算机中可以malloc-1-2G-吗"><a href="#1G的计算机中可以malloc-1-2G-吗" class="headerlink" title="1G的计算机中可以malloc(1.2G)吗"></a>1G的计算机中可以malloc(1.2G)吗</h2><p><strong>malloc能够申请的空间大小与物理内存的大小没有直接关系，仅与程序的虚拟地址空间相关</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;     </span><br><span class="line">      char*p;</span><br><span class="line">       constunsigned k= 1024*1024*1024*1.2;    </span><br><span class="line">       printf(&quot;%x\n&quot;,k);</span><br><span class="line">       p= (char *)malloc( k );</span><br><span class="line">       if( p!=NULL )</span><br><span class="line">              printf(&quot;OK&quot;);</span><br><span class="line">       else</span><br><span class="line">              printf(&quot;error&quot;);</span><br><span class="line">       return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="malloc能申请多大的空间"><a href="#malloc能申请多大的空间" class="headerlink" title="malloc能申请多大的空间"></a>malloc能申请多大的空间</h2><p>malloc能够申请的空间到底能达到多大，还真是一个比较复杂的问题。想知道在一台机器上malloc能够 申请的最大空间到底是多少，可以使用下面的程序进行测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">unsigned maximum = 1024*1024*1024;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">       unsignedblocksize[] = &#123;1024*1024, 1024, 1&#125;;</span><br><span class="line">       inti, count;</span><br><span class="line">       void* block;</span><br><span class="line">       for(i=0; i&lt;sizeof(blocksize)/sizeof(unsigned); i++ )</span><br><span class="line">       &#123;     for( count = 1; ;count++ )</span><br><span class="line">              &#123;     block = malloc( maximum +blocksize[i]*count );</span><br><span class="line">                     if( block!=NULL ) &#123;</span><br><span class="line">                            maximum= maximum + blocksize[i]*count;</span><br><span class="line">                            free(block );</span><br><span class="line">                     &#125;else &#123;</span><br><span class="line">                            break;</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       printf(&quot;maximummalloc size = %u bytes\n&quot;, maximum);</span><br><span class="line">       return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前正在使用的Windows环境中，可申请的最大空间超过1.9G。实际上，具体的数值会受到操作系统 版本、程序本身的大小、用到的动态&#x2F;共享库数量、大小、程序栈数量、大小等的影响，甚至每次运行的 结果都可能存在差异，因为有些操作系统使用了一种叫做随机地址分布的技术，使得进程的堆空间变 小。感兴趣的读者可以去研究操作系统中的相关内容</p><h2 id="内存管理的方式"><a href="#内存管理的方式" class="headerlink" title="内存管理的方式"></a>内存管理的方式</h2><p>常见的内存管理方式有<strong>块式管理、页式管理、段式管理和段页式管理</strong>。最常用的是段页式管理。</p><ul><li><p>块式管理</p><p>把主存分为一大块一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断载入主 存，就算所需的程序片段只有几个字节，也只能把这一块分配给它。这样会造成很大的浪费，平均浪费 了50%的内存空间，但是易于管理</p></li><li><p>页式管理</p><p>用户程序的地址空间被划分成若干个固定大小的区域，这个区域被称为页”，相应地，内存空间也被划分 为若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，从而实现了离散分 配。这种方式的优点是页的大小是固定的，因此便于管理；缺点是页长与程序的逻辑大小没有任何关 系。这就导致在某个时刻一个程序可能只有一部分在主存中，而另一部分则在辅存中。这不利于编程时 的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦</p></li><li><p>段式管理</p><p>段是按照程序的自然分界划分的并且长度可以动态改变的区域。使用这种方式，程序员可以把子程序、 操作数和不同类型的数据和函数划分到不同的段中。这种方式将用户程序地址空间分成若干个大小不等 的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻 接，也实现了离散分配。</p></li></ul><blockquote><p>分页对程序员而言是不可见的，而分段通常对程序员而言是可见的，因而分段为组织程序和数据提 供了方便，但是对程序员的要求也比较高。 </p><p>分段存储主要有如下优点： </p><ol><li>段的逻辑独立性不仅使其易于编译、管理、修改和保护，也便于多道程序共享。 </li><li>段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。 </li><li>方便分段共享、分段保护、动态链接、动态增长。</li></ol><p>分段存储的缺点如下： </p><ol><li>由于段的大小不固定，因此存储管理比较麻烦。 </li><li>会生成段内碎片，这会造成存储空间利用率降低。而且段式存储管理比页式存储管理方式需 要更多的硬件支持。</li></ol><p>正是由于页式管理和段式管理都有各种各样的缺点，因此，为了把这两种存储方式的优点结合起 来，新引入了段页式管理。</p></blockquote><ul><li><p>段页式管理</p><p>段页式存储组织是分段式和分页式结合的存储组织方法，这样可充分利用分段管理和分页管理的优点。</p><ol><li>用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有 自己的段名，再把每段分成固定大小的若干页 </li><li>用分页方法来分配和管理内存，即把整个主存分成与上述页大小相等的存储块，可装入作业的任何 一页。程序对内存的调入或调出是按页进行的，但它又可按段实现共享和保护</li></ol></li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存简称虚存，是计算机系统内存管理的一种技术。它是相对于物理内存而言的，可以理解为“假 的”内存。它使得<strong>应用程序认为它拥有连续可用的内存（一个连续完整的地址空间）</strong>，允许程序员编写并 运行比实际系统拥有的内存大得多的程序，这使得许多大型软件项目能够在具有有限内存资源的系统上 实现。而实际上，它通常被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要 时进行数据交换。</p><p>相比实存，虚存有以下好处：</p><ol><li>扩大了地址空间。无论是段式虚存，还是页式虚存，或是段页式虚存，寻址空间都比实存大。 </li><li>内存保护。每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。另外，虚存还对特定的 内存地址提供写保护，可以防止代码或数据被恶意篡改。 </li><li>公平分配内存。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。 </li><li>当进程需要通信时，可采用虚存共享的方式实现不过，使用虚存也是有代价的，主要表现在以下几 个方面。<ol><li>虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</li><li>虚拟地址到物理地址的转换，增加了指令的执行时间</li><li>页面的换入换出需要磁盘IO，这是很耗时间的</li><li>如果一页中只有一部分数据，会浪费内存</li></ol></li></ol><h2 id="内存碎片、内碎片、外碎片"><a href="#内存碎片、内碎片、外碎片" class="headerlink" title="内存碎片、内碎片、外碎片"></a>内存碎片、内碎片、外碎片</h2><ul><li><p>内存碎片</p><p>是由于多次进行内存分配造成的，当进行内存分配时，内存格式一般为：（用户使用段）（空 白段）（用户使用段），当空白段很小的时候，可能不能提供给用户足够多的空间，如夹在中间的空白 段的大小为5，而用户需要的内存大小为6，这样会产生很多的间隙，造成使用效率下降，这些很小的空 隙叫碎片</p></li><li><p>内碎片</p><p>分配给程序的存储空间没有用完，有一部分是程序不使用，但其他程序也没法用的空间。内碎 片是处于区域内部或页面内部的存储块，占有这些区域或页面的进程并不使用这个存储块，而在进程占 有这块存储块时，系统无法利用它，直到进程释放它，或进程结束时，系统才有可能利用这个存储块</p></li><li><p>外碎片</p><p>空间太小，小到无法给任何程序分配（不属于任何进程）的存储空间。外部碎片是出于任何已 分配区域或页面外部的空闲存储块，这些存储块的总和可以满足当前申请的长度要求，但是它们的地址 不连续或其他原因，使得系统无法满足当前申请</p></li></ul><p>内碎片和外碎片是一对矛盾体，一种特定的内存分配算法，很难同时解决好内碎片和外碎片的问题，只 能根据应用特点进行取舍</p><h2 id="虚拟地址、逻辑地址、线性地址、物理地址"><a href="#虚拟地址、逻辑地址、线性地址、物理地址" class="headerlink" title="虚拟地址、逻辑地址、线性地址、物理地址"></a>虚拟地址、逻辑地址、线性地址、物理地址</h2><ul><li><p>虚拟地址</p><p>是指由程序产生的由段选择符和段内偏移地址组成的地址。这两部分组成的地址并没有直接访 问物理内存，而是通过分段地址的变换处理后才会对应到相应的物理内存地址</p></li><li><p>逻辑地址</p><p>由程序产生的段内偏移地址。有时直接把逻辑地址当成虚拟地址，两者并没有明确的界限</p></li><li><p>线性地址</p><p>是指<strong>虚拟地址到物理地址变换之间的中间层</strong>，是处理器可寻址的内存空间（称为线性地址空 间）中的地址。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段基址就生成了一个线 性地址。如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若没有采用分页机制，那 么线性地址就是物理地址</p></li><li><p>物理地址</p><p>指现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。虚拟地址 到物理地址的转化方法是与体系结构相关的，一般有分段与分页两种方式。以x86CPU为例，分段、分 页都是支持的。内存管理单元负责从虚拟地址到物理地址的转化。逻辑地址是段标识+段内偏移量的形 式，MMU通过査询段表，可以把逻辑地址转化为线性地址。如果CPU没有开启分页功能，那么线性地址 就是物理地址；如果CPU开启了分页功能MMU还需要查询页表来将线性地址转化为物理地址：逻辑地址 （段表）→线性地址（页表）→物理地址。</p></li></ul><p>映射是一种多对一的关系，即不同的逻辑地址可以映射到同一个线性地址上；不同的线性地址也可以映 射到同一个物理地址上。而且，同一个线性地址在发生换页以后，也可能被重新装载到另外一个物理地 址上，所以这种多对一的映射关系也会随时间发生变化</p><h2 id="虚拟内存的置换方式（？）"><a href="#虚拟内存的置换方式（？）" class="headerlink" title="虚拟内存的置换方式（？）"></a>虚拟内存的置换方式（？）</h2><h2 id="类里面有static、virtual，其内存分布"><a href="#类里面有static、virtual，其内存分布" class="headerlink" title="类里面有static、virtual，其内存分布"></a>类里面有static、virtual，其内存分布</h2><ul><li><p>static修饰符</p><ul><li><p>static修饰成员变量</p><p>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被 定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态 数据成员的值对每个对象都是一样的，它的值可以更新</p><p>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在 没有产生类对象前就可以使用</p></li><li><p>static修饰成员函数</p><p>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个 意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的 静态成员函数。static修饰的成员函数，在代码区分配内存</p></li></ul></li><li><p>C++继承和虚函数</p><p>C++多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多 态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定</p><p>动态多态实现有几个条件：</p><ul><li>虚函数</li><li>一个基类的指针或引用指向派生类的对象</li></ul><p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地 址。查找该虚函数表中该函数的指针进行调用。 </p><p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都 指向这同一个虚函数表。</p><p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承 过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该 调用哪个函数</p></li><li><p>virtual修饰符</p><p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new&#x2F;malloc动态申请的，则该类数据 存储在堆区。 </p><p>如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指 向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。 </p><p>如果类中成员是virtual属性，会隐藏父类对应的属性</p></li></ul><h2 id="假设临界区资源释放，如何保证只让一个线程获取临界区资源"><a href="#假设临界区资源释放，如何保证只让一个线程获取临界区资源" class="headerlink" title="假设临界区资源释放，如何保证只让一个线程获取临界区资源"></a>假设临界区资源释放，如何保证只让一个线程获取临界区资源</h2><p>给临界区资源加互斥锁，可以保证临界区资源释放时，只有一个线程获得临界区资源。</p><h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h2><p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应 的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常</p><p>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存 中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在 外存中找到所缺的一页，将其调入内存</p><p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p><ol><li>保护CPU现场 </li><li>分析中断原因 </li><li>转入缺页中断处理程序进行处理 </li><li>恢复CPU现场，继续执行</li></ol><p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般 的中断存在区别： </p><ol><li>在指令执行期间产生和处理缺页中断信号 </li><li>一条指令在执行期间，可能产生多次缺页中断 </li><li>缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</li></ol><h2 id="OS缺页置换算法"><a href="#OS缺页置换算法" class="headerlink" title="OS缺页置换算法"></a>OS缺页置换算法</h2><p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区， 替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：</p><p> <strong>先进先出(FIFO)算法</strong>：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存 的先后次序排列成队列，从队尾进入，从队首删除。 </p><p>最近最少使用<strong>（LRU）算法</strong>: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚 被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。当前最 常采用的就是LRU算法。</p><h2 id="系统调用和库函数"><a href="#系统调用和库函数" class="headerlink" title="系统调用和库函数"></a>系统调用和库函数</h2><ul><li><p>系统调用</p><p>系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程 与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。下面为适用于访 问设备驱动程序的系统调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">open: 打开文件或设备 </span><br><span class="line">read: 从打开的文件或设备中读取数据 </span><br><span class="line">write: 向打开的文件或设备中写入数据 </span><br><span class="line">close: 关闭文件或设备 </span><br><span class="line">ioctl: 把控制信息传递给设备驱动文件</span><br></pre></td></tr></table></figure></li><li><p>库函数</p><p>库函数（Library function）是把函数放到库里，供别人使用的一种方式。.方法是把一些常用到的函数 编完放到一个文件里，供不同的人进行调用。一般放在.lib文件中。库函数调用则是面向应用开发的，库 函数可分为两类，一类是C语言标准规定的库函数，一类是编译器特定的库函数。</p></li></ul><p><strong>系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便</strong></p><p>库函数调用与系统无关，不同的系统，调用库函数，库函数会调用不同的底层函数实现，因此可移植性 好。</p><p>由于库函数是基于c库的，因此不能用于内核对于底层驱动设备的操作</p><p><strong>区别：</strong></p><ol><li>库函数是语言或应用程序的一部分，而系统调用是内核提供给应用程序的接口，属于系统的一部分 </li><li>库函数在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行时间属于用户时间，系 统调用属于系统时间，库函数开销较小，系统调用开销较大 </li><li>库函数是有缓冲的，系统调用是无缓冲的 </li><li>系统调用依赖于平台，库函数并不依赖</li></ol><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231213192034154.png" alt="image-20231213192034154"></p><h2 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h2><p>加快从磁盘读取文件的速率。page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢， 所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。 </p><p>在Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这 些 Cache项，一个是radix tree，另一个是双向链表。Radix tree 是一种搜索树，Linux内核利用这个数 据结构来通过文件内偏移快速定位Cache 项</p><h1 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h1><h2 id="上下文有哪些"><a href="#上下文有哪些" class="headerlink" title="上下文有哪些"></a>上下文有哪些</h2><p>上下文简单说来就是一个环境</p><p>用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递 很多变量、参数 的值给内核，内核态运行的时候也要保存用户进程的一些寄存 器值、变量等。所谓的“进程上下文”，可 以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境 等。</p><p>相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进 程打开的文件、内存信息等</p><p>一个进程的上下文可以分为三个部分:<strong>用户级上下文、寄存器上下文以及系统级上下文</strong></p><ol><li>用户级上下文: 正文、数据、用户堆栈以及共享存储区； </li><li>寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)； </li><li>系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、 pte)、内核栈</li></ol><p><strong>当发生进程调度时，进行进程切换就是上下文切换(context switch).操作系统必须对上面提到的全部信 息进行切换，新调度的进程才能运行。而系统调用进行的模式切换(mode switch)。模式切换与进程切 换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换进程寄存器上下文的切 换</strong></p><p>硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的 一些变量和参数 也要传递给内核，内核通过这些参数进行中断处理。所谓的“ 中断上下文”，其实也可以看作就是硬件传 递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。中断时，内 核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一 般不会阻塞</p><h2 id="为什么会有上下文"><a href="#为什么会有上下文" class="headerlink" title="为什么会有上下文"></a>为什么会有上下文</h2><p>内核空间和用户空间是现代操作系统的两种工作模式，内核模块运行在内核空间，而用户态应用程序运 行在用户空间。它们代表不同的级别，而对系统资源具有不同的访问权限。内核模块运行在最高级别 （内核态），这个级下所有的操作都受系统信任，而应用程序运行在较低级别（用户态）。在这个级 别，处理器控制着对硬件的直接访问以及对内存的非授权访问。内核态和用户态有自己的内存映射，即 自己的地址空间。</p><p>其中，处理器总处于以下状态中的一种： </p><p>内核态，运行于进程上下文，内核代表进程运行于内核空间； </p><p>用户态，运行于用户空间。</p><p>系统的两种不同运行状态，才有了上下文的概念。用户空间的应用程序，如果想请求系统服务，比如操 作某个物理设备，映射设备的地址到用户空间，必须通过系统调用来实现。（系统调用是操作系统提供 给用户空间的接口函数）。</p><p>通过系统调用，用户空间的应用程序就会进入内核空间，由内核代表该进程运行于内核空间，这就涉及 到上下文的切换，用户空间和内核空间具有不同的 地址映射，通用或专用的寄存器组，而<strong>用户空间的进 程要传递很多变量、参数给内核，内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后 回到用户空间继续执行</strong></p><h2 id="用户态到内核态什么情况下会切换"><a href="#用户态到内核态什么情况下会切换" class="headerlink" title="用户态到内核态什么情况下会切换"></a>用户态到内核态什么情况下会切换</h2><ol><li>进程上下文主要是异常处理程序和内核线程。内核之所以进入进程上下文是因为进程自身的一些工 作需要在内核中做。例如，系统调用是为当前进程服务的，异常通常是处理进程导致的错误状态 等。 </li><li>中断上下文是由于硬件发生中断时会触发中断信号请求，请求系统处理中断，执行中断服务子程 序。</li></ol><h2 id="中断上下文代码中有哪些注意事项"><a href="#中断上下文代码中有哪些注意事项" class="headerlink" title="中断上下文代码中有哪些注意事项"></a>中断上下文代码中有哪些注意事项</h2><p>运行于进程上下文的内核代码是可抢占的，但中断上下文则会一直运行至结束，不会被抢占。所以中断 处理程序代码要受到一些限制，在中断代码中不能出现实现下面功能的代码：</p><ol><li><strong>睡眠或者放弃CPU</strong> ，因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来 执行，系统就会死掉。牢记：中断服务子程序一定不能睡眠（或者阻塞）。 </li><li><strong>尝试获得信号量</strong> ，如果获得不到信号量，代码就会睡眠，导致（1）中的结果。 </li><li><strong>执行耗时的任务</strong> ，中断处理应该尽可能快，因为如果一个处理程序是IRQF_DISABLED类型，他执行的时候会禁止所有 本地中断线，而内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。 中断处理程序的任务尽可能放在中断下半部执行</li><li><strong>访问用户空间的虚拟地址</strong> ，因为中断运行在内核空间。</li></ol><h2 id="线程需要保存哪些上下文，SP、PC、EAX寄存器的作用"><a href="#线程需要保存哪些上下文，SP、PC、EAX寄存器的作用" class="headerlink" title="线程需要保存哪些上下文，SP、PC、EAX寄存器的作用"></a>线程需要保存哪些上下文，SP、PC、EAX寄存器的作用</h2><p>线程在切换的过程中需要保存当前线程id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括 SP、PC、EAX等寄存器，其主要功能如下：</p><p>SP:堆栈指针，指向当前栈的栈顶地址 </p><p>PC:程序计数器，存储下一条将要执行的指令 </p><p>EAX:累加寄存器，用于加法乘法的缺省寄存器</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动入门笔记</title>
      <link href="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-单片机和Linux程序从上层到底层的比较"><a href="#1-单片机和Linux程序从上层到底层的比较" class="headerlink" title="1 单片机和Linux程序从上层到底层的比较"></a>1 单片机和Linux程序从上层到底层的比较</h1><h2 id="1-程序比较"><a href="#1-程序比较" class="headerlink" title="1 程序比较"></a>1 程序比较</h2><ul><li><p>单片机程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">HAL库 / 寄存器操作//直接操作硬件</span><br><span class="line">R/W寄存器  //可以直接读写寄存器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Linux程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">应用程序：</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">无法直接R/W寄存器  //不可以直接读写寄存器，因为有MMU，禁止直接访问内存</span><br><span class="line">调用驱动程序 open/read/write...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">驱动程序：</span><br><span class="line">open/read/write...</span><br><span class="line">硬件操作</span><br><span class="line">R/W寄存器  //可以直接读写寄存器</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20231121150452014.png" alt="image-20231121150452014"></p><h2 id="2-调用过程"><a href="#2-调用过程" class="headerlink" title="2 调用过程"></a>2 调用过程</h2><ul><li>①应用程序<strong>调用open函数</strong></li><li>②open的实质是<strong>设置寄存器</strong>，<strong>执行一条汇编指令</strong>：swi #0，<strong>触发异常</strong>，还会在寄存器中保存一个值，如R0&#x3D;open</li><li>③cpu就会去执行swi异常处理函数，于是就从<strong>用户态陷入内核态</strong></li><li>④根据寄存器R0分辨调用的是什么函数，然后<strong>调用sys_open函数</strong>，判断文件名，通过主设备号找到驱动</li><li>⑤最后找到<strong>drv_open函数</strong></li></ul><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20231121160513624.png" alt="image-20231121160513624"></p><h2 id="3-打开设备节点"><a href="#3-打开设备节点" class="headerlink" title="3 打开设备节点"></a>3 打开设备节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd dev</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20231121154233396.png" alt="image-20231121154233396"></p><h2 id="4-查看支持的设备"><a href="#4-查看支持的设备" class="headerlink" title="4 查看支持的设备"></a>4 查看支持的设备</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/devices</span><br></pre></td></tr></table></figure><h2 id="5-如何写驱动"><a href="#5-如何写驱动" class="headerlink" title="5 如何写驱动"></a>5 如何写驱动</h2><ul><li>确定主设备号</li><li>构造结构体file_operations，实现其中的函数</li><li>注册结构体，放入到chrdev[]数组中</li><li>入口</li></ul><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20231121160006224.png" alt="image-20231121160006224"></p><h1 id="2-彻底分析第一个驱动程序"><a href="#2-彻底分析第一个驱动程序" class="headerlink" title="2 彻底分析第一个驱动程序"></a>2 彻底分析第一个驱动程序</h1><h2 id="1-在Ubuntu中速体验驱动开发"><a href="#1-在Ubuntu中速体验驱动开发" class="headerlink" title="1 在Ubuntu中速体验驱动开发"></a>1 在Ubuntu中速体验驱动开发</h2><ul><li><p>下载内核头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uname -r // 查看内核版本</span><br><span class="line">apt-cache search linux-headers-$(uname -r)       // 确认有没有</span><br><span class="line">sudo apt-get install linux-headers-$(uname -r) // 下载安装</span><br><span class="line">/lib/modules/5.19.0-41-generic/build // ubuntu内核头文件所在目录</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-驱动程序"><a href="#2-驱动程序" class="headerlink" title="2 驱动程序"></a>2 驱动程序</h2><h4 id="V1-最简单的驱动程序"><a href="#V1-最简单的驱动程序" class="headerlink" title="V1 最简单的驱动程序"></a>V1 最简单的驱动程序</h4><p>hello_drv.c：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line"></span><br><span class="line">int init_module(void)  //直接使用init_module</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cleanup_module(void)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line"></span><br><span class="line">//module_init(hello_init);</span><br><span class="line">//int init_module(void) __attribute__((alias(hello_init)));</span><br></pre></td></tr></table></figure><p>Makefile:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ARCH = x86</span><br><span class="line">CROSS_COMPILE =</span><br><span class="line"></span><br><span class="line">KVERSION = $(shell uname -r)</span><br><span class="line">KERN_DIR =  /lib/modules/$(KVERSION)/build </span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">make -C $(KERN_DIR) M=`pwd` modules </span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">make -C $(KERN_DIR) M=`pwd` modules clean</span><br><span class="line">rm -rf modules.order</span><br><span class="line"></span><br><span class="line">obj-m+= hello_drv.o</span><br></pre></td></tr></table></figure><h4 id="V2-驱动入口、出口详解"><a href="#V2-驱动入口、出口详解" class="headerlink" title="V2 驱动入口、出口详解"></a>V2 驱动入口、出口详解</h4><ul><li>__init 段属性，只用一次，可释放</li><li>__exit 段属性，驱动编进内核里才有意义，无需出口，出口函数无意义，在一般的ko文件中无意义，段属性，但是不会链接进内核</li></ul><p>hello_drv.c：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line"></span><br><span class="line">//__init 段属性，只用一次，可释放</span><br><span class="line">int __init hello_init(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;hello drv init\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//__exit 段属性，但是不会链接进内核</span><br><span class="line">//驱动编进内核里才有意义，无需出口，出口函数无意义，在一般的ko文件中无意义</span><br><span class="line">void __exit hello_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;hello drv exit\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">//int init_module(void) __attribute__((alias(hello_init)));</span><br></pre></td></tr></table></figure><p>Makefile:同上</p><h4 id="V3-字符设备调用关系"><a href="#V3-字符设备调用关系" class="headerlink" title="V3 字符设备调用关系"></a>V3 字符设备调用关系</h4><ul><li>驱动不提供open，应用程序调用open也能打开驱动文件</li><li>但是不提供read、write，应用程序调用read、write就会报错</li></ul><p>hello_drv.c：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line"></span><br><span class="line">static int major = 0;</span><br><span class="line"></span><br><span class="line">static struct file_operations hello_fops = &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int __init hello_init(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;hello drv init\n&quot;);</span><br><span class="line">major = register_chrdev(0, &quot;hello_drv&quot;, &amp;hello_fops);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __exit hello_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;hello drv exit\n&quot;);</span><br><span class="line">unregister_chrdev(major, &quot;hello_drv&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure><p>hello_test.c:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * ./hello_drv_test -w abc</span><br><span class="line"> * ./hello_drv_test -r</span><br><span class="line"> */</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">int fd;</span><br><span class="line">char buf[1024];</span><br><span class="line">int len;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">/* 1. 判断参数 */</span><br><span class="line">if (argc &lt; 2) </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Usage: %s -w &lt;string&gt;\n&quot;, argv[0]);</span><br><span class="line">printf(&quot;       %s -r\n&quot;, argv[0]);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 2. 打开文件 */</span><br><span class="line">fd = open(&quot;/dev/xyz&quot;, O_RDWR);</span><br><span class="line">if (fd == -1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;can not open file /dev/xyz\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;open file /dev/xyz ok\n&quot;);</span><br><span class="line"></span><br><span class="line">/* 3. 写文件或读文件 */</span><br><span class="line">if ((0 == strcmp(argv[1], &quot;-w&quot;)) &amp;&amp; (argc == 3))</span><br><span class="line">&#123;</span><br><span class="line">len = strlen(argv[2]) + 1;</span><br><span class="line">len = len &lt; 1024 ? len : 1024;</span><br><span class="line">ret = write(fd, argv[2], len);</span><br><span class="line">printf(&quot;write driver: %d\n&quot;, ret);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">len = read(fd, buf, 1024);</span><br><span class="line">printf(&quot;read driver: %d\n&quot;, len);</span><br><span class="line">buf[1023] = &#x27;\0&#x27;;</span><br><span class="line">printf(&quot;APP read : %s\n&quot;, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="V4-数据交互"><a href="#V4-数据交互" class="headerlink" title="V4 数据交互"></a>V4 数据交互</h4><ul><li>copy_to_user</li><li>copy_from_user</li></ul><p>hello_drv.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">#include &lt;linux/uaccess.h&gt;</span><br><span class="line">//#include &lt;asm/uaccess.h&gt;</span><br><span class="line"></span><br><span class="line">static int major = 0;</span><br><span class="line">static int ker_val = 123;</span><br><span class="line"></span><br><span class="line">static ssize_t hello_read (struct file *file, char __user *buf, size_t size, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">int err;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">copy_to_user(buf, &amp;ker_val, 4);</span><br><span class="line">return 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t hello_write (struct file *file, const char __user *buf, size_t size, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">int err;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">copy_from_user(&amp;ker_val, buf, 4);</span><br><span class="line">return 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static struct file_operations hello_fops = &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.read       = hello_read,</span><br><span class="line">.write      = hello_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int __init hello_init(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;hello drv init\n&quot;);</span><br><span class="line">major = register_chrdev(0, &quot;hello_drv&quot;, &amp;hello_fops);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __exit hello_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;hello drv exit\n&quot;);</span><br><span class="line">unregister_chrdev(major, &quot;hello_drv&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure><h1 id="3-驱动程序辅助信息及地址空间概念"><a href="#3-驱动程序辅助信息及地址空间概念" class="headerlink" title="3 驱动程序辅助信息及地址空间概念"></a>3 驱动程序辅助信息及地址空间概念</h1><h2 id="1-思考"><a href="#1-思考" class="headerlink" title="1 思考"></a>1 思考</h2><p>GIT仓库中有如下程序：</p><p>adress.c源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;val&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a&#x27;s address = 0x%lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main&#x27;s address = 0x%lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)main);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把它放到Ubuntu后，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./address 124&amp;</span></span><br><span class="line">a = 124</span><br><span class="line">a&#x27;s address = 0x6bc3a0</span><br><span class="line">main&#x27;s address = 0x400b5d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./address 123&amp;</span></span><br><span class="line">a = 123</span><br><span class="line">a&#x27;s address = 0x6bc3a0</span><br><span class="line">main&#x27;s address = 0x400b5d</span><br></pre></td></tr></table></figure><p>观察到：现在内存里有2个address程序，它们的变量a地址相同、值不同</p><p>问：为什么同一个地址的内存里，同一时间点，竟然值不一样？</p><h2 id="2-地址空间"><a href="#2-地址空间" class="headerlink" title="2. 地址空间"></a>2. 地址空间</h2><h3 id="1-CPU怎么访问多个外设"><a href="#1-CPU怎么访问多个外设" class="headerlink" title="1 CPU怎么访问多个外设"></a>1 CPU怎么访问多个外设</h3><h4 id="MCU"><a href="#MCU" class="headerlink" title="MCU"></a>MCU</h4><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20231121185750327.png" alt="image-20231121185750327"></p><h4 id="MPU"><a href="#MPU" class="headerlink" title="MPU"></a>MPU</h4><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20231121190133851.png" alt="image-20231121190133851"></p><h3 id="2-为什么要引入虚拟地址"><a href="#2-为什么要引入虚拟地址" class="headerlink" title="2 为什么要引入虚拟地址"></a>2 为什么要引入虚拟地址</h3><ul><li>如果main函数调用 f 函数，就需要用到 f1 的地址（虚拟地址）</li><li>链接时，要确定 f1 的地址（虚拟地址）</li><li>运行时，f1 所在内存的地址可能不一样（物理地址）</li></ul><p>当引入虚拟地址后：</p><ul><li>加载程序（物理地址）</li><li>映射，链接地址（虚拟地址）</li><li>运行，跳到虚拟地址去运行</li></ul><h3 id="3-虚拟地址怎么对应到物理地址"><a href="#3-虚拟地址怎么对应到物理地址" class="headerlink" title="3 虚拟地址怎么对应到物理地址"></a>3 虚拟地址怎么对应到物理地址</h3><p>virAdress &#x3D; ioremap（phyAdress，4）</p><h3 id="4-Linux驱动中怎么访问硬件寄存器"><a href="#4-Linux驱动中怎么访问硬件寄存器" class="headerlink" title="4 Linux驱动中怎么访问硬件寄存器"></a>4 Linux驱动中怎么访问硬件寄存器</h3><h2 id="3-驱动程序辅助信息"><a href="#3-驱动程序辅助信息" class="headerlink" title="3 驱动程序辅助信息"></a>3 驱动程序辅助信息</h2><p>自动创建设备节点的流程：</p><ul><li>内核提供信息<ul><li>class_create</li><li>device_create</li></ul></li><li>APP根据信息创建设备节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">#include &lt;linux/uaccess.h&gt;</span><br><span class="line">//#include &lt;asm/uaccess.h&gt;</span><br><span class="line">#include &lt;linux/device.h&gt;</span><br><span class="line"></span><br><span class="line">static int major = 0;</span><br><span class="line">static int ker_val = 123;</span><br><span class="line">static struct class *class_for_hello;</span><br><span class="line"></span><br><span class="line">static ssize_t hello_read (struct file *file, char __user *buf, size_t size, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">int err;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">copy_to_user(buf, &amp;ker_val, 4);</span><br><span class="line">return 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t hello_write (struct file *file, const char __user *buf, size_t size, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">int err;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">copy_from_user(&amp;ker_val, buf, 4);</span><br><span class="line">return 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static struct file_operations hello_fops = &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.read       = hello_read,</span><br><span class="line">.write      = hello_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int __init hello_init(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;hello drv init\n&quot;);</span><br><span class="line">major = register_chrdev(0, &quot;hello_drv&quot;, &amp;hello_fops);</span><br><span class="line">class_for_hello = class_create(THIS_MODULE, &quot;hello_class&quot;); /* /sys/class/hello_class/ */</span><br><span class="line">device_create(class_for_hello, NULL, MKDEV(major, 0), NULL, &quot;myhello&quot;); /* /dev/myhello */</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __exit hello_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;hello drv exit\n&quot;);</span><br><span class="line">device_destroy(class_for_hello, MKDEV(major, 0)); /* /dev/myhello */</span><br><span class="line"></span><br><span class="line">class_destroy(class_for_hello);</span><br><span class="line"></span><br><span class="line">unregister_chrdev(major, &quot;hello_drv&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">//int init_module(void) __attribute__((alias(hello_init)));</span><br></pre></td></tr></table></figure><h1 id="4-板子上驱动程序实际操作及编译过程"><a href="#4-板子上驱动程序实际操作及编译过程" class="headerlink" title="4 板子上驱动程序实际操作及编译过程"></a>4 板子上驱动程序实际操作及编译过程</h1><h3 id="1-在内核目录外编译模块"><a href="#1-在内核目录外编译模块" class="headerlink" title="1 在内核目录外编译模块"></a>1 在内核目录外编译模块</h3><p>led_drv.c源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;linux/kernel.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/slab.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">#include &lt;linux/delay.h&gt;</span><br><span class="line">#include &lt;linux/poll.h&gt;</span><br><span class="line">#include &lt;linux/mutex.h&gt;</span><br><span class="line">#include &lt;linux/wait.h&gt;</span><br><span class="line">#include &lt;linux/uaccess.h&gt;</span><br><span class="line">#include &lt;asm/io.h&gt;</span><br><span class="line"></span><br><span class="line">static int major;</span><br><span class="line">static struct class *led_class;</span><br><span class="line"></span><br><span class="line">static ssize_t led_write(struct file *filp, const char __user *buf,</span><br><span class="line"> size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">char val;</span><br><span class="line">/* copy_from_user : get data from app */</span><br><span class="line">copy_from_user(&amp;val, buf, 1);</span><br><span class="line"></span><br><span class="line">/* to set gpio register: out 1/0 */</span><br><span class="line">if (val)</span><br><span class="line">&#123;</span><br><span class="line">/* set gpio to let led on */</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">/* set gpio to let led off */</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">/* enable gpio</span><br><span class="line"> * configure pin as gpio</span><br><span class="line"> * configure gpio as output </span><br><span class="line"> */</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct file_operations led_fops = &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.write= led_write,</span><br><span class="line">.open= led_open,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 入口函数 */</span><br><span class="line">static int __init led_init(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;%s %s %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">major = register_chrdev(0, &quot;100ask_led&quot;, &amp;led_fops);</span><br><span class="line"></span><br><span class="line">/* ioremap */</span><br><span class="line"></span><br><span class="line">led_class = class_create(THIS_MODULE, &quot;myled&quot;);</span><br><span class="line">device_create(led_class, NULL, MKDEV(major, 0), NULL, &quot;myled&quot;); /* /dev/myled */</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit led_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">device_destroy(led_class, MKDEV(major, 0));</span><br><span class="line">class_destroy(led_class);</span><br><span class="line"></span><br><span class="line">unregister_chrdev(major, &quot;100ask_led&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure><p>Makefile源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 1. 使用不同的开发板内核时, 一定要修改KERN_DIR</span><br><span class="line"># 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:</span><br><span class="line"># 2.1 ARCH,          比如: export ARCH=arm64</span><br><span class="line"># 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line"># 2.3 PATH,          比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin </span><br><span class="line"># 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,</span><br><span class="line">#请参考各开发板的高级用户使用手册</span><br><span class="line"></span><br><span class="line">KERN_DIR = </span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">make -C $(KERN_DIR) M=`pwd` modules       </span><br><span class="line">$(CROSS_COMPILE)gcc -o ledtest ledtest.c </span><br><span class="line"></span><br><span class="line"># -C 表示changedir，进入到$(KERN_DIR)目录，编译 M 路径中的模块</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">make -C $(KERN_DIR) M=`pwd` modules clean</span><br><span class="line">rm -rf modules.order</span><br><span class="line">rm -f ledtest</span><br><span class="line"></span><br><span class="line">obj-m+= led_drv.o</span><br><span class="line">#需要编译的模块</span><br></pre></td></tr></table></figure><p>imx6ull开发板环境变量如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm</span><br><span class="line">export CROSS_COMPILE=arm-linux-gnueabihf-</span><br><span class="line">export PATH=$PATH:/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin </span><br></pre></td></tr></table></figure><h3 id="2-在内核目录里面编译驱动"><a href="#2-在内核目录里面编译驱动" class="headerlink" title="2 在内核目录里面编译驱动"></a>2 在内核目录里面编译驱动</h3><ul><li><p>将需要编译进内核的驱动源码放入到内核目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp led_drv.c /home/lk/linux/imx6ull/3.linux_kernel/kernel/alpha_kernel/linux-imx-rel_imx_4.1.15_2.1.0_ga/drivers/char</span><br></pre></td></tr></table></figure></li><li><p>修改内核目录下&#x2F;drivers&#x2F;char&#x2F;Kconfig，添加相应的配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config ALPHA_LED</span><br><span class="line">bool &quot;led driver for alpha&quot;</span><br><span class="line">default y</span><br><span class="line">help</span><br><span class="line">  Just for test led.</span><br></pre></td></tr></table></figure><p>也可以打开menuconfig来配置</p><p>make menuconfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers</span><br><span class="line">Character devices</span><br><span class="line">led driver for alpha</span><br><span class="line">m 编译为模块</span><br><span class="line">y 编译进内核</span><br><span class="line">n 不参与编译</span><br></pre></td></tr></table></figure><p>在内核根目录下的.config文件中可以看到 CONFIG_ALPHA_LED &#x3D; y</p></li><li><p>修改内核目录下&#x2F;drivers&#x2F;char&#x2F;Makefile，添加相应的配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_ALPHA_LED)     += gpioled.o</span><br></pre></td></tr></table></figure></li><li><p>编译zImage，烧写到开发板，即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make zImage -j4</span><br><span class="line">cp /arch/arm/boot/zImage   /home/lk/linux/tftpboot -rf     //拷贝zImage</span><br><span class="line">cp /arch/arm/boot/dts/.dtb /home/lk/linux/tftpboot -rf    //拷贝dtb</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-分离的设计思想与总线设备驱动模型"><a href="#5-分离的设计思想与总线设备驱动模型" class="headerlink" title="5 分离的设计思想与总线设备驱动模型"></a>5 分离的设计思想与总线设备驱动模型</h1><h2 id="1-分离的设计思想"><a href="#1-分离的设计思想" class="headerlink" title="1 分离的设计思想"></a>1 分离的设计思想</h2><p>一个驱动可以适应很多个设备，就可以把驱动与设备分离开</p><p>驱动程序分成两部分：</p><ul><li>驱动：通用的驱动信息</li><li>设备：硬件信息</li></ul><h2 id="2-总线设备驱动模型"><a href="#2-总线设备驱动模型" class="headerlink" title="2 总线设备驱动模型"></a>2 总线设备驱动模型</h2><ul><li>platform_bus_type  总线platform下面有两个链表<ul><li>driver_list   驱动链表</li><li>device_list  设备链表</li></ul></li></ul><h2 id="3-编写驱动方法"><a href="#3-编写驱动方法" class="headerlink" title="3 编写驱动方法"></a>3 编写驱动方法</h2><p>①构造，注册</p><ul><li>构造platform_driver，注册进驱动链表</li><li>构造platform_device，注册进设备链表</li></ul><p>②匹配，跟对方链表的每个成员一一比较，调用platform总线里面的 .match 函数比较</p><p>③匹配成功，就会执行platform_driver里面的 .probe 函数</p><h1 id="6-总线设备驱动模型彻底分析"><a href="#6-总线设备驱动模型彻底分析" class="headerlink" title="6 总线设备驱动模型彻底分析"></a>6 总线设备驱动模型彻底分析</h1><h2 id="1-匹配方法"><a href="#1-匹配方法" class="headerlink" title="1 匹配方法"></a>1 匹配方法</h2><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20231121211955147.png" alt="image-20231121211955147"></p><h2 id="2-注册过程"><a href="#2-注册过程" class="headerlink" title="2 注册过程"></a>2 注册过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">platform_driver_register 注册设备</span><br><span class="line">platform_device_add</span><br><span class="line">pdev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line">ret = device_add(&amp;pdev-&gt;dev);</span><br><span class="line">error = bus_add_device(dev);</span><br><span class="line">klist_add_tail 将设备放入总线设备链表</span><br><span class="line">bus_probe_device 枚举设备</span><br><span class="line">device_initial_prove</span><br><span class="line">__device_attach</span><br><span class="line">bus_for_each_drv 对于总线下面的每一个驱动</span><br><span class="line">__device_attch_driver 调用该函数查看是否匹配驱动</span><br></pre></td></tr></table></figure><h2 id="3-私有数据"><a href="#3-私有数据" class="headerlink" title="3 私有数据"></a>3 私有数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">platform_set_drvdata()   //设置与驱动有关的私有数据</span><br></pre></td></tr></table></figure><h1 id="7-设备树入门"><a href="#7-设备树入门" class="headerlink" title="7 设备树入门"></a>7 设备树入门</h1><p>设备文件过多，而且也不是内核中的核心文件，会导致内核臃肿，而且修改麻烦</p><p>所以引入一个配置文件，内核可以读取这个配置文件，就相当于读取设备文件，也就设备树</p><h2 id="1-反汇编dtb文件"><a href="#1-反汇编dtb文件" class="headerlink" title="1 反汇编dtb文件"></a>1 反汇编dtb文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dtc -I dtb -O dts imx6ull-alpha.dtb &gt; 1.dts</span><br></pre></td></tr></table></figure><h2 id="2-设备树节点语法"><a href="#2-设备树节点语法" class="headerlink" title="2 设备树节点语法"></a>2 设备树节点语法</h2><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20231121220113106.png" alt="image-20231121220113106"></p><h2 id="3-创建设备树节点"><a href="#3-创建设备树节点" class="headerlink" title="3 创建设备树节点"></a>3 创建设备树节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myled: myled_test &#123;</span><br><span class="line">pin = &quot;gpio5_3&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myled_ok: myled_ok_test &#123;</span><br><span class="line">compatible = &quot;fsl,led&quot;//有compatible属性的节点才能转换成platform_device</span><br><span class="line">pin = &quot;gpio5_3&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/sys/firmware/devicetree/base //该目录下有设备树节点的信息myled_test、myled_ok_test</span><br><span class="line">/sys/bus/platform/devices//该目录下有平台设备的信息myled_ok_test</span><br></pre></td></tr></table></figure><h2 id="4-设备树匹配过程"><a href="#4-设备树匹配过程" class="headerlink" title="4 设备树匹配过程"></a>4 设备树匹配过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">of_driver_match_device(dev,drv)</span><br><span class="line">of_match_device(drv-&gt;of_match_table, dev)  //驱动里面的of_match_device放有compatible</span><br></pre></td></tr></table></figure><h1 id="8-设备树示例"><a href="#8-设备树示例" class="headerlink" title="8 设备树示例"></a>8 设备树示例</h1><h2 id="1-LED和按键的设备树示例"><a href="#1-LED和按键的设备树示例" class="headerlink" title="1 LED和按键的设备树示例"></a>1 LED和按键的设备树示例</h2><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-alpha.dts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dtsled &#123;</span><br><span class="line">compatible = &quot;gpio-leds&quot;;//根据该属性找对应的驱动程序</span><br><span class="line"></span><br><span class="line">led0 &#123;</span><br><span class="line">label= &quot;red&quot;;</span><br><span class="line">gpios = &lt;&amp;gpio1 3 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">linux,default-trigger = &quot;heartbeat&quot;;</span><br><span class="line">default-state = &quot;on&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gpio-keys &#123;</span><br><span class="line">compatible = &quot;gpio-keys&quot;;//根据该属性找对应的驱动程序</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;0&gt;;</span><br><span class="line">autorepeat;</span><br><span class="line"></span><br><span class="line">led0 &#123;</span><br><span class="line">label= &quot;GPIO Key Enter&quot;;</span><br><span class="line">linux,code = &lt;KEY_ENTER&gt;;</span><br><span class="line">gpios = &lt;&amp;gpio1 18 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-I2C设备树示例"><a href="#2-I2C设备树示例" class="headerlink" title="2 I2C设备树示例"></a>2 I2C设备树示例</h2><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i2c1: i2c@021a0000 &#123;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;0&gt;;</span><br><span class="line">compatible = &quot;fsl,imx6ul-i2c&quot;, &quot;fsl,imx21-i2c&quot;;//I2C相关驱动</span><br><span class="line">reg = &lt;0x021a0000 0x4000&gt;;//寄存器基地址+长度</span><br><span class="line">interrupts = &lt;GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH&gt;;//中断</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;//时钟</span><br><span class="line">status = &quot;disabled&quot;;//状态</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-alpha.dts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">clock-frequency = &lt;100000&gt;;//频率</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_i2c1&gt;;//引脚信息</span><br><span class="line">status = &quot;okay&quot;;//状态</span><br><span class="line"></span><br><span class="line">ap3216c@1e &#123; //在I2C1下面的具体设备，I2C1的子节点</span><br><span class="line">compatible = &quot;alpha,ap3216c&quot;; //具体设备的驱动</span><br><span class="line">reg = &lt;0x1e&gt;; //设备地址</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">oled@3c &#123; </span><br><span class="line">compatible = &quot;alpha,oled&quot;; </span><br><span class="line">reg = &lt;0x3c&gt;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">codec: wm8960@1a &#123; </span><br><span class="line">compatible = &quot;wlf,wm8960&quot;; </span><br><span class="line">reg = &lt;0x1a&gt;; </span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_SAI2&gt;; </span><br><span class="line">clock-names = &quot;mclk&quot;; </span><br><span class="line">wlf,shared-lrclk; </span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-SPI设备树示例"><a href="#3-SPI设备树示例" class="headerlink" title="3 SPI设备树示例"></a>3 SPI设备树示例</h2><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ecspi3: ecspi@02010000 &#123;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;0&gt;;</span><br><span class="line">compatible = &quot;fsl,imx6ul-ecspi&quot;, &quot;fsl,imx51-ecspi&quot;;</span><br><span class="line">reg = &lt;0x02010000 0x4000&gt;;</span><br><span class="line">interrupts = &lt;GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_ECSPI3&gt;,</span><br><span class="line"> &lt;&amp;clks IMX6UL_CLK_ECSPI3&gt;;</span><br><span class="line">clock-names = &quot;ipg&quot;, &quot;per&quot;;</span><br><span class="line">dmas = &lt;&amp;sdma 7 7 1&gt;, &lt;&amp;sdma 8 7 2&gt;;</span><br><span class="line">dma-names = &quot;rx&quot;, &quot;tx&quot;;</span><br><span class="line">status = &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-alpha.dts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&amp;ecspi3 &#123;</span><br><span class="line">fsl,spi-num-chipselects = &lt;1&gt;;           //设置当前片选数量为 1</span><br><span class="line">cs-gpios = &lt;&amp;gpio1 20 GPIO_ACTIVE_LOW&gt;;  //描述片选引脚</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_ecspi3&gt;;           //设置 IO 要使用的 pinctrl 子节点</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line"></span><br><span class="line">spidev: icm20608@0 &#123; </span><br><span class="line">compatible = &quot;alientek,icm20608&quot;; </span><br><span class="line">spi-max-frequency = &lt;8000000&gt;;      //设置 SPI 最大时钟频率为 8MHz</span><br><span class="line">reg = &lt;0&gt;;                          //icm20608 连接在 ECSPI3 的第 0 个通道上</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-LCD设备树示例"><a href="#4-LCD设备树示例" class="headerlink" title="4 LCD设备树示例"></a>4 LCD设备树示例</h2><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lcdif: lcdif@021c8000 &#123;</span><br><span class="line">compatible = &quot;fsl,imx6ul-lcdif&quot;, &quot;fsl,imx28-lcdif&quot;;</span><br><span class="line">reg = &lt;0x021c8000 0x4000&gt;;</span><br><span class="line">interrupts = &lt;GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_LCDIF_PIX&gt;,</span><br><span class="line"> &lt;&amp;clks IMX6UL_CLK_LCDIF_APB&gt;,</span><br><span class="line"> &lt;&amp;clks IMX6UL_CLK_DUMMY&gt;;</span><br><span class="line">clock-names = &quot;pix&quot;, &quot;axi&quot;, &quot;disp_axi&quot;;</span><br><span class="line">status = &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-alpha.dts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;lcdif &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_lcdif_dat</span><br><span class="line">     &amp;pinctrl_lcdif_ctrl&gt;;</span><br><span class="line">display = &lt;&amp;display0&gt;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line"></span><br><span class="line">display0: display &#123;</span><br><span class="line">bits-per-pixel = &lt;24&gt;;</span><br><span class="line">bus-width = &lt;24&gt;;</span><br><span class="line"></span><br><span class="line">display-timings &#123;</span><br><span class="line">native-mode = &lt;&amp;timing0&gt;;</span><br><span class="line">timing0: timing0 &#123;</span><br><span class="line">clock-frequency = &lt;34200000&gt;;   /* LCD 像素时钟，单位 Hz */ </span><br><span class="line">hactive = &lt;800&gt;;                /* LCD X 轴像素个数 */</span><br><span class="line">vactive = &lt;480&gt;;                /* LCD Y 轴像素个数 */</span><br><span class="line">hfront-porch = &lt;210&gt;; /* LCD hfp 参数 */</span><br><span class="line">hback-porch = &lt;46&gt;;/* LCD hbp 参数 */</span><br><span class="line">hsync-len = &lt;1&gt;;/* LCD hspw 参数 */ </span><br><span class="line">vback-porch = &lt;23&gt;;/* LCD vbp 参数 */</span><br><span class="line">vfront-porch = &lt;22&gt;;/* LCD vfp 参数 */</span><br><span class="line">vsync-len = &lt;1&gt;;/* LCD vspw 参数 */</span><br><span class="line"></span><br><span class="line">hsync-active = &lt;0&gt;;</span><br><span class="line">vsync-active = &lt;0&gt;;</span><br><span class="line">de-active = &lt;1&gt;;</span><br><span class="line">pixelclk-active = &lt;0&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-设备树编写方法"><a href="#5-设备树编写方法" class="headerlink" title="5 设备树编写方法"></a>5 设备树编写方法</h2><ul><li>使用芯片厂家提供的工具 </li><li>看绑定文档</li><li>参考同类型单板的设备树文件 </li><li>网上搜索</li><li>实在没办法时, 只能去研究驱动源码</li></ul><h1 id="9-Pinctrl和GPIO"><a href="#9-Pinctrl和GPIO" class="headerlink" title="9 Pinctrl和GPIO"></a>9 Pinctrl和GPIO</h1><h2 id="1-Pinctrl"><a href="#1-Pinctrl" class="headerlink" title="1 Pinctrl"></a>1 Pinctrl</h2><ul><li><p>imx6ull为例</p><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-alpha.dts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gpioled &#123;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;;</span><br><span class="line">compatible = &quot;alpha-gpioled&quot;;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line"></span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_led&gt;;//Pinctrl</span><br><span class="line"></span><br><span class="line">led-gpio = &lt;&amp;gpio1 3 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_led: ledgrp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_GPIO1_IO03__GPIO1_IO03  0x10B0          /*config 是具体设置值*/</span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&quot;imx6ull-pinfunc.h&quot;</span><br><span class="line">#define MX6UL_PAD_GPIO1_IO03__GPIO1_IO03                          0x0068 0x02F4 0x0000 0x5 0x0</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-GPIO"><a href="#2-GPIO" class="headerlink" title="2 GPIO"></a>2 GPIO</h2><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-alpha.dts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gpioled &#123;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;;</span><br><span class="line">compatible = &quot;alpha-gpioled&quot;;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_led&gt;;</span><br><span class="line"></span><br><span class="line">led-gpio = &lt;&amp;gpio1 3 GPIO_ACTIVE_LOW&gt;;//GPIO</span><br><span class="line"></span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gpio1: gpio@0209c000 &#123;</span><br><span class="line">compatible = &quot;fsl,imx6ul-gpio&quot;, &quot;fsl,imx35-gpio&quot;;</span><br><span class="line">reg = &lt;0x0209c000 0x4000&gt;;</span><br><span class="line">interrupts = &lt;GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">     &lt;GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">gpio-controller;</span><br><span class="line">#gpio-cells = &lt;2&gt;;     //用2个cell描述gpio引脚</span><br><span class="line">interrupt-controller;</span><br><span class="line">#interrupt-cells = &lt;2&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="10-应用程序和驱动程序的更多交互方式"><a href="#10-应用程序和驱动程序的更多交互方式" class="headerlink" title="10 应用程序和驱动程序的更多交互方式"></a>10 应用程序和驱动程序的更多交互方式</h1><h2 id="1-APP读取按键值的四种方式"><a href="#1-APP读取按键值的四种方式" class="headerlink" title="1 APP读取按键值的四种方式"></a>1 APP读取按键值的四种方式</h2><ul><li><strong>查询方式</strong></li><li><strong>休眠-唤醒方式</strong></li><li>poll <strong>方式</strong> </li><li><strong>异步通知方式</strong></li></ul><h2 id="2-中断系统的设备树分析"><a href="#2-中断系统的设备树分析" class="headerlink" title="2 中断系统的设备树分析"></a>2 中断系统的设备树分析</h2><blockquote><p>中断流程：在ARM架构里面详细分析过中断的流程</p></blockquote><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intc: interrupt-controller@00a01000 &#123;</span><br><span class="line">compatible = &quot;arm,cortex-a7-gic&quot;;</span><br><span class="line">#interrupt-cells = &lt;3&gt;;          /* &lt;类别 中断号 触发方式&gt; */</span><br><span class="line">interrupt-controller;</span><br><span class="line">reg = &lt;0x00a01000 0x1000&gt;,</span><br><span class="line">      &lt;0x00a02000 0x100&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gpc: gpc@020dc000 &#123;</span><br><span class="line">compatible = &quot;fsl,imx6ul-gpc&quot;, &quot;fsl,imx6q-gpc&quot;;</span><br><span class="line">reg = &lt;0x020dc000 0x4000&gt;;</span><br><span class="line">interrupt-controller;</span><br><span class="line">#interrupt-cells = &lt;3&gt;;</span><br><span class="line">interrupts = &lt;GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">interrupt-parent = &lt;&amp;intc&gt;;/* 继承intc */</span><br><span class="line">fsl,mf-mix-wakeup-irq = &lt;0xfc00000 0x7d00 0x0 0x1400640&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;;</span><br><span class="line">compatible = &quot;simple-bus&quot;;</span><br><span class="line">interrupt-parent = &lt;&amp;gpc&gt;;/* 继承gpc */</span><br><span class="line">ranges;</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">gpio1: gpio@0209c000 &#123;</span><br><span class="line">compatible = &quot;fsl,imx6ul-gpio&quot;, &quot;fsl,imx35-gpio&quot;;</span><br><span class="line">reg = &lt;0x0209c000 0x4000&gt;;</span><br><span class="line">interrupts = &lt;GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">     &lt;GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">gpio-controller;</span><br><span class="line">#gpio-cells = &lt;2&gt;;</span><br><span class="line">interrupt-controller;</span><br><span class="line">#interrupt-cells = &lt;2&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">.............</span><br><span class="line">gpio5:.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-用一个程序总结驱动机制"><a href="#11-用一个程序总结驱动机制" class="headerlink" title="11 用一个程序总结驱动机制"></a>11 用一个程序总结驱动机制</h1><h1 id="12-驱动开发基础"><a href="#12-驱动开发基础" class="headerlink" title="12 驱动开发基础"></a>12 驱动开发基础</h1><ul><li>非阻塞方式：NOBLOCK，不等待，直接返回</li><li>休眠唤醒：中断</li><li>poll机制：有一个timeout，在指定的时间内检测有没有数据</li><li>异步通知机制：信号<ul><li>信号处理内部机制：实际上就是修改栈中LR的值，从而跳去执行信号处理函数，执行完后，触发异常，异常处理，恢复之前的LR</li></ul></li></ul><blockquote><p>推荐书：《linux源代码情景分析》，毛德操</p></blockquote><h1 id="13-实战-SR501人体红外模块驱动开发"><a href="#13-实战-SR501人体红外模块驱动开发" class="headerlink" title="13 实战_SR501人体红外模块驱动开发"></a>13 实战_SR501人体红外模块驱动开发</h1><h2 id="驱动编写方法"><a href="#驱动编写方法" class="headerlink" title="驱动编写方法"></a>驱动编写方法</h2><ul><li>中断</li><li>内核线程</li></ul><h2 id="1原理图"><a href="#1原理图" class="headerlink" title="1原理图"></a>1原理图</h2><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20231124155738845.png" alt="image-20231124155738845"></p><p>人体都有恒定的体温，一般在37度，所以会发出特定波长10uM左右的红外线，被动式红外探头就是靠探测人体发射的10uM左右的红外线而进行工作的。人体发射的10uM左右的红外线通过菲泥尔滤光片增强后聚集到红外感应源上。红外感应源通常采用热释电元件，这种元件在接收到人体红外辐射温度发生变化时就会失去电荷平衡，向外释放电荷，后续电路经检测处理后就能产生报警信号。</p><p>人体红外模块是一种能够检测人或动物发射的红外线而输出电信号的传感器。广泛应用于各种自动化控制装置中。比如常见的楼道自动开关、防盗报警等。如果有人在量程内运动，DO引脚将会输出有效信号。</p><p>实物和使用方法如下图所示，可以设置探测距离、延迟控制等：</p><p>通过跳线来设置是否可以重复触发，默认为L。其中L表示不可重复，H表示可重复。含义如下：</p><p>① 不可重复触发方式：</p><p>感应到人体并输出高电平后，延时时间一结束，输出将自动从高电平变为低电平。</p><p>② 重复触发方式： </p><p>感应到人体后输出高电平后，在延时时间段内，如果有人体在其感应范围内活动，其输出将一直保持高电平，直到人离开后才延时将高电平变为低电平(感应模块检测到人体的每一次活动后会自动顺延一个延时时间段，并且以最后一次活动的时间为延时时间的起始点)。</p><p>可以通过电位器实现封锁时间和检测距离的调节：</p><p>① 调节检测距离：</p><p>即有效距离的远近。调节距离电位器顺时针旋转，感应距离增大（约 7 米）；反之，感应距离减小（约 3 米）。</p><p>② 封锁时间：</p><p>感应模块在每一次感应输出后(高电平变为低电平)，可以紧跟着设置一个封锁时间，在此时间段内感应器不接收任何感应信号。</p><p>此功能可以实现(感应输出时间和封锁时间)两者的间隔工作，可应用于间隔探测产品；同时此功能可有效抑制负载切换过程中产生的各种干扰。</p><p>调节延时电位器顺时针旋转，感应延时加长（约300S），反之，感应延时减短（约0.5S）。</p><h2 id="2-实现设备树节点"><a href="#2-实现设备树节点" class="headerlink" title="2 实现设备树节点"></a>2 实现设备树节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sr501 &#123;</span><br><span class="line">compatible = &quot;alpha-sr501&quot;;</span><br><span class="line">gpios = &lt;&amp;gpio4 19 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-驱动框架"><a href="#3-驱动框架" class="headerlink" title="3 驱动框架"></a>3 驱动框架</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">#include &lt;linux/interrupt.h&gt;</span><br><span class="line">#include &lt;linux/irq.h&gt;</span><br><span class="line">#include &lt;linux/sched.h&gt;</span><br><span class="line">#include &lt;linux/pm.h&gt;</span><br><span class="line">#include &lt;linux/slab.h&gt;</span><br><span class="line">#include &lt;linux/sysctl.h&gt;</span><br><span class="line">#include &lt;linux/proc_fs.h&gt;</span><br><span class="line">#include &lt;linux/delay.h&gt;</span><br><span class="line">#include &lt;linux/platform_device.h&gt;</span><br><span class="line">#include &lt;linux/input.h&gt;</span><br><span class="line">#include &lt;linux/gpio_keys.h&gt;</span><br><span class="line">#include &lt;linux/workqueue.h&gt;</span><br><span class="line">#include &lt;linux/gpio.h&gt;</span><br><span class="line">#include &lt;linux/of.h&gt;</span><br><span class="line">#include &lt;linux/of_platform.h&gt;</span><br><span class="line">#include &lt;linux/of_gpio.h&gt;</span><br><span class="line">#include &lt;linux/of_irq.h&gt;</span><br><span class="line">#include &lt;linux/spinlock.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int sr501_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从设备读数据 */</span><br><span class="line">/* 设备文件 返回给用户空间的数据缓冲区 读取长度 相对于文件首地址的偏移 */</span><br><span class="line">static ssize_t sr501_read(struct file *filp, char __user *buf, </span><br><span class="line">                           size_t cnt,        loff_t *offt)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 向设备写数据 */</span><br><span class="line">/* 设备文件 要写给设备写入的数据 写入长度 相对于文件首地址的偏移 */</span><br><span class="line">static ssize_t sr501_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)</span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static unsigned int sr501_poll(struct file *filp, struct poll_table_struct *wait)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 关闭设备 */</span><br><span class="line">static int sr501_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static const struct file_operations sr501_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = sr501_open,</span><br><span class="line">.read = sr501_read,</span><br><span class="line">.write = sr501_write,</span><br><span class="line">.poll = sr501_poll,</span><br><span class="line">.release = sr501_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int sr501_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;sr501 match sucess!\r\n&quot;);</span><br><span class="line">    register_chrdev(0, &quot;sr501&quot;, &amp;sr501_fops);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int sr501_remove(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev(0, &quot;sr501&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct of_device_id sr501_of_match[] = &#123;</span><br><span class="line">&#123; .compatible = &quot;alpha-sr501&quot;, &#125;,</span><br><span class="line">&#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct platform_driver sr501_device_driver = &#123;</span><br><span class="line">.probe= sr501_probe,</span><br><span class="line">.remove= sr501_remove,</span><br><span class="line">.driver= &#123;</span><br><span class="line">.name= &quot;sr501&quot;,</span><br><span class="line">.of_match_table = of_match_ptr(sr501_of_match),</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init sr501_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;%s %s line %d\r\n&quot;,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">return platform_driver_register(&amp;sr501_device_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit sr501_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;sr501_device_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(sr501_init);</span><br><span class="line">module_exit(sr501_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make dtbs</span><br><span class="line">sudo cp arch/arm/boot/dts/imx6ull-alpha.dtb /home/lk/linux/tftpboot/ -rf</span><br><span class="line">sudo cp sr501.ko  /home/lk/linux/nfs/rootfs/lib/modules/4.1.15/ -rf</span><br></pre></td></tr></table></figure><h2 id="5-查看中断"><a href="#5-查看中断" class="headerlink" title="5 查看中断"></a>5 查看中断</h2><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20231124214601939.png" alt="image-20231124214601939"></p><h1 id="17-实战-SR04超声波测距模块驱动开发"><a href="#17-实战-SR04超声波测距模块驱动开发" class="headerlink" title="17 实战_SR04超声波测距模块驱动开发"></a>17 实战_SR04超声波测距模块驱动开发</h1><h2 id="驱动编写方法-1"><a href="#驱动编写方法-1" class="headerlink" title="驱动编写方法"></a>驱动编写方法</h2><ul><li>查询方式</li><li>中断</li></ul><h2 id="1-SR04工作原理"><a href="#1-SR04工作原理" class="headerlink" title="1 SR04工作原理"></a>1 SR04工作原理</h2><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/01_sr04_sch.png" alt="image-20211223183302503"></p><p>要测距，需如下操作：</p><ul><li><p>触发：向Trig（脉冲触发引脚）发出一个大约10us的高电平。</p><ul><li>模块就自动发出8个40Khz的超声波，超声波遇到障碍物后反射回来，模块收到返回来的超声波。</li></ul></li><li><p>回响：模块接收到反射回来的超声波后，Echo引脚输出一个与检测距离成比例的高电平。</p></li><li><p>我们只要计算Echo引脚维持高电平的时间T即刻计算举例：D &#x3D; 340*T&#x2F;2。</p></li></ul><h2 id="2-原理图"><a href="#2-原理图" class="headerlink" title="2 原理图"></a>2 原理图</h2><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20231125155404835.png" alt="image-20231125155404835"></p><h2 id="3-方法1-轮询方式"><a href="#3-方法1-轮询方式" class="headerlink" title="3 方法1   轮询方式"></a>3 方法1   轮询方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int us = 0;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);    // 关中断</span><br><span class="line"></span><br><span class="line">//使用udelay来延时判断引脚电平</span><br><span class="line">while (低电平); // 等待高电平</span><br><span class="line">while (高电平)&#123; udelay(1); us++; &#125;  // 累加时间</span><br><span class="line"></span><br><span class="line">local_irq_restore(flags); // 恢复中断</span><br></pre></td></tr></table></figure><h2 id="4-方法2中断"><a href="#4-方法2中断" class="headerlink" title="4 方法2中断"></a>4 方法2中断</h2><p>设置Echo中断为双边沿触发，在上升沿读取时间T1，在下降沿读取时间T2：T2-T1就是高电平的时间。</p><p>关键在于：使用什么函数读取时间？</p><p>内核在启动时，定时器便开始计数，通过获取计数，可计算得出运行时间。</p><p>获取时间函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ktime_get_ns();          // 获取内核启动到现在的时间，在挂起时会暂停</span><br><span class="line">ktime_get_boottime_ns(); // 获取内核启动到现在的时间，不受挂起影响，是绝对时间</span><br><span class="line">ktime_get_real_ns();     // 获取Unix时间(1970年)到现在的时间，可能涉及闰秒更新，用得比较少</span><br><span class="line">ktime_get_raw_ns();      // 类似ktime_get_ns(),不涉及闰秒更新，用得比较少</span><br></pre></td></tr></table></figure><h2 id="5-实现设备树节点"><a href="#5-实现设备树节点" class="headerlink" title="5 实现设备树节点"></a>5 实现设备树节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sr04 &#123;</span><br><span class="line">compatible = &quot;alpha-sr04&quot;;</span><br><span class="line">trig-gpios = &lt;&amp;gpio1 1 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">echo-gpios = &lt;&amp;gpio1 2 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-源码"><a href="#6-源码" class="headerlink" title="6 源码"></a>6 源码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/poll.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">#include &lt;linux/errno.h&gt;</span><br><span class="line">#include &lt;linux/miscdevice.h&gt;</span><br><span class="line">#include &lt;linux/kernel.h&gt;</span><br><span class="line">#include &lt;linux/major.h&gt;</span><br><span class="line">#include &lt;linux/mutex.h&gt;</span><br><span class="line">#include &lt;linux/proc_fs.h&gt;</span><br><span class="line">#include &lt;linux/seq_file.h&gt;</span><br><span class="line">#include &lt;linux/stat.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/device.h&gt;</span><br><span class="line">#include &lt;linux/tty.h&gt;</span><br><span class="line">#include &lt;linux/kmod.h&gt;</span><br><span class="line">#include &lt;linux/gfp.h&gt;</span><br><span class="line">#include &lt;linux/gpio/consumer.h&gt;</span><br><span class="line">#include &lt;linux/platform_device.h&gt;</span><br><span class="line">#include &lt;linux/of_gpio.h&gt;</span><br><span class="line">#include &lt;linux/of_irq.h&gt;</span><br><span class="line">#include &lt;linux/interrupt.h&gt;</span><br><span class="line">#include &lt;linux/irq.h&gt;</span><br><span class="line">#include &lt;linux/slab.h&gt;</span><br><span class="line">#include &lt;linux/fcntl.h&gt;</span><br><span class="line">#include &lt;linux/timer.h&gt;</span><br><span class="line">#include &lt;linux/workqueue.h&gt;</span><br><span class="line">#include &lt;asm/current.h&gt;</span><br><span class="line">#include &lt;linux/delay.h&gt;</span><br><span class="line">#include &lt;linux/drbd.h&gt;</span><br><span class="line"></span><br><span class="line">static int major;</span><br><span class="line">static struct class *sr04_class;</span><br><span class="line">static struct gpio_desc *sr04_trig;</span><br><span class="line">static struct gpio_desc *sr04_echo;</span><br><span class="line">static int irq;</span><br><span class="line">static wait_queue_head_t sr04_wq;</span><br><span class="line">static u64 sr04_data_ns = 0;  </span><br><span class="line"></span><br><span class="line">/* 实现对应的open/read/write等函数，填入file_operations结构体                   */</span><br><span class="line">static ssize_t sr04_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">#if 0</span><br><span class="line">int us = 0;</span><br><span class="line">unsigned long flags;</span><br><span class="line">int timeout_us = 1000000;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);  // 关中断</span><br><span class="line"></span><br><span class="line">/* 发送10us高电平    , 测量距离 2cm-450cm */</span><br><span class="line">gpiod_set_value(sr04_trig, 1);</span><br><span class="line">udelay(15);</span><br><span class="line">gpiod_set_value(sr04_trig, 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用udelay来延时判断引脚电平</span><br><span class="line">while (!gpiod_get_value(sr04_echo) &amp;&amp; timeout_us)</span><br><span class="line">&#123;</span><br><span class="line">udelay(1); // 等待高电平</span><br><span class="line">timeout_us--;</span><br><span class="line">&#125;</span><br><span class="line">if (!timeout_us)</span><br><span class="line">&#123;</span><br><span class="line">local_irq_restore(flags); // 恢复中断</span><br><span class="line">return -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout_us = 1000000;</span><br><span class="line">while (gpiod_get_value(sr04_echo) &amp;&amp; timeout_us)</span><br><span class="line">&#123; </span><br><span class="line">udelay(1); </span><br><span class="line">us++; // 累加时间</span><br><span class="line">timeout_us--;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">if (!timeout_us)</span><br><span class="line">&#123;</span><br><span class="line">local_irq_restore(flags); // 恢复中断</span><br><span class="line">return -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local_irq_restore(flags); // 恢复中断</span><br><span class="line">copy_to_user(buf, &amp;us, 4);</span><br><span class="line">return 4;</span><br><span class="line">#else</span><br><span class="line">   int timeout;</span><br><span class="line"></span><br><span class="line">/* 发送10us高电平    , 测量距离 2cm-450cm */</span><br><span class="line">gpiod_set_value(sr04_trig, 1);</span><br><span class="line">udelay(15);</span><br><span class="line">gpiod_set_value(sr04_trig, 0);</span><br><span class="line"></span><br><span class="line">/* 等待数据 */</span><br><span class="line">timeout = wait_event_interruptible_timeout(sr04_wq, sr04_data_ns, HZ);</span><br><span class="line">if (timeout)</span><br><span class="line">&#123;</span><br><span class="line">copy_to_user(buf, &amp;sr04_data_ns, 4);</span><br><span class="line">sr04_data_ns = 0;</span><br><span class="line">return 4;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return -EAGAIN;</span><br><span class="line">&#125; </span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static unsigned int sr04_drv_poll(struct file *fp, poll_table * wait)</span><br><span class="line">&#123;</span><br><span class="line">//printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">//poll_wait(fp, &amp;sr04_wait, wait);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 定义自己的file_operations结构体                                              */</span><br><span class="line">static struct file_operations sr04_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.read    = sr04_drv_read,</span><br><span class="line">.poll    = sr04_drv_poll,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static irqreturn_t sr04_isr(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">int val = gpiod_get_value(sr04_echo);</span><br><span class="line"></span><br><span class="line">if (val) /* 上升沿 */</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 记录数据 */</span><br><span class="line">sr04_data_ns = ktime_get_ns();</span><br><span class="line">//printk(&quot;%s %s %d, val = 0x%x\n&quot;, __FILE__, __FUNCTION__, __LINE__, sr04_data);</span><br><span class="line">&#125;</span><br><span class="line">else /* 下降沿 */</span><br><span class="line">&#123;</span><br><span class="line">sr04_data_ns = ktime_get_ns() - sr04_data_ns;</span><br><span class="line">/* 2. 唤醒APP:去同一个链表把APP唤醒 */</span><br><span class="line">wake_up(&amp;sr04_wq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return IRQ_HANDLED; // IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 1. 从platform_device获得GPIO</span><br><span class="line"> * 2. gpio=&gt;irq</span><br><span class="line"> * 3. request_irq</span><br><span class="line"> */</span><br><span class="line">static int sr04_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">/* 1. 获得硬件信息 */</span><br><span class="line">sr04_trig = gpiod_get(&amp;pdev-&gt;dev, &quot;trig&quot;, GPIOD_OUT_LOW);</span><br><span class="line">sr04_echo = gpiod_get(&amp;pdev-&gt;dev, &quot;echo&quot;, GPIOD_IN);</span><br><span class="line"></span><br><span class="line">irq = gpiod_to_irq(sr04_echo);</span><br><span class="line">    printk(&quot;irq: %d\r\n&quot;,irq);</span><br><span class="line">request_irq(irq, sr04_isr, IRQF_TRIGGER_RISING|IRQF_TRIGGER_FALLING, &quot;sr04&quot;, NULL);</span><br><span class="line"></span><br><span class="line">/* 2. device_create */</span><br><span class="line">device_create(sr04_class, NULL, MKDEV(major, 0), NULL, &quot;sr04&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int sr04_remove(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">device_destroy(sr04_class, MKDEV(major, 0));</span><br><span class="line">free_irq(irq, NULL);</span><br><span class="line">gpiod_put(sr04_trig);</span><br><span class="line">gpiod_put(sr04_echo);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static const struct of_device_id ask100_sr04[] = &#123;</span><br><span class="line">    &#123; .compatible = &quot;alpha-sr04&quot; &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 1. 定义platform_driver */</span><br><span class="line">static struct platform_driver sr04s_driver = &#123;</span><br><span class="line">    .probe      = sr04_probe,</span><br><span class="line">    .remove     = sr04_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = &quot;alpha-sr04&quot;,</span><br><span class="line">        .of_match_table = ask100_sr04,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 2. 在入口函数注册platform_driver */</span><br><span class="line">static int __init sr04_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int err;</span><br><span class="line">    </span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">/* 注册file_operations */</span><br><span class="line">major = register_chrdev(0, &quot;sr04&quot;, &amp;sr04_fops);  </span><br><span class="line"></span><br><span class="line">sr04_class = class_create(THIS_MODULE, &quot;sr04_class&quot;);</span><br><span class="line">if (IS_ERR(sr04_class)) &#123;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">unregister_chrdev(major, &quot;sr04&quot;);</span><br><span class="line">return PTR_ERR(sr04_class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_waitqueue_head(&amp;sr04_wq);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    err = platform_driver_register(&amp;sr04s_driver); </span><br><span class="line"></span><br><span class="line">return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 3. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数</span><br><span class="line"> *     卸载platform_driver</span><br><span class="line"> */</span><br><span class="line">static void __exit sr04_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">    platform_driver_unregister(&amp;sr04s_driver);</span><br><span class="line">class_destroy(sr04_class);</span><br><span class="line">unregister_chrdev(major, &quot;sr04&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */</span><br><span class="line"></span><br><span class="line">module_init(sr04_init);</span><br><span class="line">module_exit(sr04_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure><h1 id="18-实战-DHT11温湿度传感器驱动开发"><a href="#18-实战-DHT11温湿度传感器驱动开发" class="headerlink" title="18 实战_DHT11温湿度传感器驱动开发"></a>18 实战_DHT11温湿度传感器驱动开发</h1><h2 id="驱动编写方法-2"><a href="#驱动编写方法-2" class="headerlink" title="驱动编写方法"></a>驱动编写方法</h2><ul><li>查询方式</li><li>中断</li><li>IIO子系统</li></ul><h2 id="1-DHT11工作原理"><a href="#1-DHT11工作原理" class="headerlink" title="1. DHT11工作原理"></a>1. DHT11工作原理</h2><h3 id="1-1-硬件信号"><a href="#1-1-硬件信号" class="headerlink" title="1.1 硬件信号"></a>1.1 硬件信号</h3><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/01_sch.png" alt="image-20211225161948946"></p><p>需要先发一个开始信号给DHT11，才能接收数据。</p><p>下图为一次完整的传输示例，其中深黑色信号表示由主机驱动，即主机向DHT11发信号，浅灰色信号表示DHT11驱动，即DHT11发向主机发信号。</p><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/02_operaions.png"></p><p>当主机没有与DHT11通信时，总线处于空闲状态，此时总线电平由于上拉电阻的作用处于高电平。</p><p>当主机与DHT11正在通信时，总线处于通信状态，一次完整的通信过程如下：</p><ul><li><p>主机将对应的GPIO管脚配置为输出，准备向DHT11发送数据；</p></li><li><p>主机发送一个开始信号：</p><ul><li>开始信号 &#x3D; 一个低脉冲 + 一个高脉冲。低脉冲至少持续18ms，高脉冲持续20-40us。</li></ul></li><li><p>主机将对应的GPIO管脚配置为输入，准备接受DHT11传来的数据，这时信号由上拉电阻拉高；</p></li><li><p>DHT11发出响应信号：</p><ul><li>响应信号 &#x3D; 一个低脉冲 + 一个高脉冲。低脉冲持续80us，高脉冲持续80us。</li></ul></li><li><p>DHT11发出数据信号：</p><ul><li>数据为0的一位信号 &#x3D; 一个低脉冲 + 一个高脉冲。低脉冲持续50us，高脉冲持续26～28us。</li><li>数据为1的一位信号 &#x3D; 一个低脉冲 + 一个高脉冲。低脉冲持续50us，高脉冲持续70us。</li></ul></li><li><p>DHT11发出结束信号：</p><ul><li>最后1bit数据传送完毕后，DHT11拉低总线50us，然后释放总线，总线由上拉电阻拉高进入空闲状态。</li></ul></li></ul><p>​                               </p><h3 id="1-2-数据格式"><a href="#1-2-数据格式" class="headerlink" title="1.2 数据格式"></a>1.2 数据格式</h3><p>数据格式: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8bit湿度整数数据+8bit湿度小数数据</span><br><span class="line">+8bi温度整数数据+8bit温度小数数据</span><br><span class="line">+8bit校验和</span><br></pre></td></tr></table></figure><p>数据传送正确时,校验和等于“8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据”所得结果的末8位。</p><h2 id="2-编程思路"><a href="#2-编程思路" class="headerlink" title="2. 编程思路"></a>2. 编程思路</h2><p>有了上述基础知识后就可以开始编写程序了。</p><p>编程思路如下：</p><ul><li>设置好GPIO；</li><li>主机把GPIO设置为输出引脚，发送开始信号，然后把GPIO设置为输入引脚；</li><li>主机判断是否收到DHT11的回应信号；</li><li>接收到回应信号后，开始读取数据；</li><li>接收完数据后，校验、解析。</li></ul><p>关键在于如何得到一位数据，看看下图：</p><ul><li>先等待低电平结束，一直等到出现高电平；然后延时40us，读取GPIO值：这就是该位的数据值。</li></ul><p> <img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/03_dht11_time.png"></p><h2 id="3-编写驱动程序"><a href="#3-编写驱动程序" class="headerlink" title="3. 编写驱动程序"></a>3. 编写驱动程序</h2><h3 id="3-1-方法1-查询方式"><a href="#3-1-方法1-查询方式" class="headerlink" title="3.1 方法1: 查询方式"></a>3.1 方法1: 查询方式</h3><p>触发DHT11转换数据后，就把引脚配置为输入引脚，检测引脚的电平变化，并记录高低电平的时间，最后解析出温湿度。</p><p><strong>注意</strong>：要关闭中断。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dht11_read_byte</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用udelay来延时判断引脚电平</span></span><br><span class="line">    <span class="keyword">while</span> (低电平); <span class="comment">// 等待高电平</span></span><br><span class="line">    <span class="keyword">while</span> (高电平)&#123; udelay(<span class="number">1</span>); us++; &#125;  <span class="comment">// 累加时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> us = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);    <span class="comment">// 关中断</span></span><br><span class="line">val1 = dht11_read_byte();</span><br><span class="line">val2 = dht11_read_byte();</span><br><span class="line">tmp1 = dht11_read_byte();</span><br><span class="line">tmp2 = dht11_read_byte();</span><br><span class="line">crc  = dht11_read_byte();</span><br><span class="line">local_irq_restore(flags); <span class="comment">// 恢复中断</span></span><br></pre></td></tr></table></figure><h3 id="3-2-方法2-中断方式"><a href="#3-2-方法2-中断方式" class="headerlink" title="3.2 方法2: 中断方式"></a>3.2 方法2: 中断方式</h3><p>触发DHT11转换数据后，就把引脚配置为输入引脚，并注册中断：在中断函数中记录上升沿、下降沿的实际，解析出温湿度。</p><p>获取时间函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ktime_get_ns();          <span class="comment">// 获取内核启动到现在的时间，在挂起时会暂停</span></span><br><span class="line">ktime_get_boottime_ns(); <span class="comment">// 获取内核启动到现在的时间，不受挂起影响，是绝对时间</span></span><br><span class="line">ktime_get_real_ns();     <span class="comment">// 获取Unix时间(1970年)到现在的时间，可能涉及闰秒更新，用得比较少</span></span><br><span class="line">ktime_get_raw_ns();      <span class="comment">// 类似ktime_get_ns(),不涉及闰秒更新，用得比较少</span></span><br></pre></td></tr></table></figure><h3 id="3-3-方法3-使用IIO子系统"><a href="#3-3-方法3-使用IIO子系统" class="headerlink" title="3.3 方法3: 使用IIO子系统"></a>3.3 方法3: 使用IIO子系统</h3><p>内核已经自带DHT11的驱动程序：<code>drivers/iio/humidity/dht11.c</code>：</p><ul><li><p>配置内核<br><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/04_config_dht11_kernel.png" alt="image-20211225162846563"></p></li><li><p>编写设备树，参考<code>Documentation\devicetree\bindings\iio\humidity\dht11.txt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// imx6ull</span><br><span class="line">humidity_sensor &#123; compatible = &quot;dht11&quot;;</span><br><span class="line">gpios = &lt;&amp;gpio4 19 0&gt;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// stm32mp157</span><br><span class="line">humidity_sensor &#123; compatible = &quot;dht11&quot;;</span><br><span class="line">gpios = &lt;&amp;gpioa 50&gt;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>怎么使用？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/bus/iio/devices/iio:device1/in_temp_input</span><br><span class="line">cat /sys/bus/iio/devices/iio:device1/in_humidityrelative_input</span><br></pre></td></tr></table></figure><h1 id="21-实战-DS18B20驱动编程"><a href="#21-实战-DS18B20驱动编程" class="headerlink" title="21 实战_DS18B20驱动编程"></a>21 实战_DS18B20驱动编程</h1><h2 id="1-硬件连接"><a href="#1-硬件连接" class="headerlink" title="1.  硬件连接"></a>1.  硬件连接</h2><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/01_sch-1701156562752.png" alt="image-20220104184716599"></p><h2 id="2-访问流程"><a href="#2-访问流程" class="headerlink" title="2. 访问流程"></a>2. 访问流程</h2><p>在一条数据线上，可以连接多个DS18B20。每个DS18B20都内嵌不同的ID，所以需要先选择某个DS18B20。</p><p>如果只有一个DS18B20，就不需要选择。</p><p>访问DS18B20的流程为：启动温度转换、读取温度。</p><p>怎么启动温度转换？方法如下：</p><ul><li>发出Start信号</li><li>得到回应</li><li>发出8位的数据，用于选择某个DS18B20</li><li>发出温度转换命令</li><li>等待温度转换完毕</li></ul><p>温度转换完毕后，数据存在DS18B20内部的暂存器中。怎么读出数据？方法如下：</p><ul><li>发出Start信号</li><li>得到回应</li><li>发出8位的数据，用于选择某个DS18B20</li><li>发出读暂存器的命令</li><li>读温度低8位</li><li>读温度高8位</li></ul><h2 id="3-硬件信号"><a href="#3-硬件信号" class="headerlink" title="3. 硬件信号"></a>3. 硬件信号</h2><h3 id="3-1-Start和回应"><a href="#3-1-Start和回应" class="headerlink" title="3.1 Start和回应"></a>3.1 Start和回应</h3><p>深黑色线表示由主机驱动信号，浅灰色线表示由DS18B20驱动信号。</p><p>最开始时引脚是高电平，想要开始传输信号：</p><ul><li>必须要拉低至少480us，这是复位信号；</li><li>然后拉高释放总线，等待15~60us之后，</li><li>如果GPIO上连有DS18B20芯片，它会拉低60~240us：这就是回应</li></ul><p>如果主机在最后检查到60～240us的低脉冲回应信号，则表示DS18B20初始化成功。</p><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/02_start_and_ack.png" alt="image-20220104185739784"></p><h3 id="3-2-写一位数据"><a href="#3-2-写一位数据" class="headerlink" title="3.2 写一位数据"></a>3.2 写一位数据</h3><p>如果写0，拉低至少60us(写周期为60-120us)即可；</p><p>如果写1，先拉低至少1us，然后拉高，整个写周期至少为60us即可。</p><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/03_write_bit.png" alt="image-20220104185839041"></p><h3 id="3-3-读一位数据"><a href="#3-3-读一位数据" class="headerlink" title="3.3 读一位数据"></a>3.3 读一位数据</h3><p>主机先拉低至少1us，随后读取电平，如果为0，即读到的数据是0，如果为1，即可读到的数据是1。</p><p>整个过程必须在15us内完成，15us后引脚都会被拉高。</p><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/04_read_bit.png" alt="image-20220104190003488"></p><h2 id="4-DS18B20内部寄存器"><a href="#4-DS18B20内部寄存器" class="headerlink" title="4. DS18B20内部寄存器"></a>4. DS18B20内部寄存器</h2><p>参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">《嵌入式Linux应用开发完全手册V4.0_韦东山全系列视频文档-IMX6ULL开发板.docx》</span><br><span class="line">第13篇 IMX6ULL裸机开发</span><br><span class="line">第二十二章 DS18B20温度模块</span><br></pre></td></tr></table></figure><h2 id="5-编写驱动程序"><a href="#5-编写驱动程序" class="headerlink" title="5. 编写驱动程序"></a>5. 编写驱动程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/poll.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">#include &lt;linux/errno.h&gt;</span><br><span class="line">#include &lt;linux/miscdevice.h&gt;</span><br><span class="line">#include &lt;linux/kernel.h&gt;</span><br><span class="line">#include &lt;linux/major.h&gt;</span><br><span class="line">#include &lt;linux/mutex.h&gt;</span><br><span class="line">#include &lt;linux/proc_fs.h&gt;</span><br><span class="line">#include &lt;linux/seq_file.h&gt;</span><br><span class="line">#include &lt;linux/stat.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/device.h&gt;</span><br><span class="line">#include &lt;linux/tty.h&gt;</span><br><span class="line">#include &lt;linux/kmod.h&gt;</span><br><span class="line">#include &lt;linux/gfp.h&gt;</span><br><span class="line">#include &lt;linux/gpio/consumer.h&gt;</span><br><span class="line">#include &lt;linux/platform_device.h&gt;</span><br><span class="line">#include &lt;linux/of_gpio.h&gt;</span><br><span class="line">#include &lt;linux/of_irq.h&gt;</span><br><span class="line">#include &lt;linux/interrupt.h&gt;</span><br><span class="line">#include &lt;linux/irq.h&gt;</span><br><span class="line">#include &lt;linux/slab.h&gt;</span><br><span class="line">#include &lt;linux/fcntl.h&gt;</span><br><span class="line">#include &lt;linux/timer.h&gt;</span><br><span class="line">#include &lt;linux/workqueue.h&gt;</span><br><span class="line">#include &lt;asm/current.h&gt;</span><br><span class="line">#include &lt;linux/delay.h&gt;</span><br><span class="line">#include &lt;linux/drbd.h&gt;</span><br><span class="line">#include &lt;linux/ktime.h&gt;</span><br><span class="line">#include &lt;linux/version.h&gt;</span><br><span class="line"></span><br><span class="line">static int major;</span><br><span class="line">static struct class *ds18b20_class;</span><br><span class="line">static struct gpio_desc *ds18b20_data_pin;</span><br><span class="line"></span><br><span class="line">static void my_udelay(int us)</span><br><span class="line">&#123;</span><br><span class="line">u64 pre,last;</span><br><span class="line">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(5,0,0)</span><br><span class="line">pre = ktime_get_boot_ns();</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">last = ktime_get_boot_ns();</span><br><span class="line">if(last - pre &gt;= us*1000)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">pre = ktime_get_boottime_ns();</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">last = ktime_get_boottime_ns();</span><br><span class="line">if (last - pre &gt;= us * 1000)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ds18b20_wait_for_ack(void)</span><br><span class="line">&#123;</span><br><span class="line">int timeout_count = 500;</span><br><span class="line"></span><br><span class="line">/* 如果是高电平,等待 */</span><br><span class="line">while (gpiod_get_value(ds18b20_data_pin) &amp;&amp; --timeout_count)</span><br><span class="line">&#123;</span><br><span class="line">udelay(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!timeout_count)</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">/* 现在是低电平 */</span><br><span class="line">timeout_count = 500;</span><br><span class="line">while (!gpiod_get_value(ds18b20_data_pin) &amp;&amp; --timeout_count)</span><br><span class="line">&#123;</span><br><span class="line">udelay(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!timeout_count)</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int ds18b20_reset(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 开始信号：主机驱动信号，发送480us低脉冲 */</span><br><span class="line">gpiod_set_value(ds18b20_data_pin, 0);</span><br><span class="line">my_udelay(480);</span><br><span class="line"></span><br><span class="line">/* 等待应答 */</span><br><span class="line">gpiod_direction_input(ds18b20_data_pin);</span><br><span class="line">if (ds18b20_wait_for_ack())</span><br><span class="line">return -1;</span><br><span class="line">else</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void ds18b20_write_byte(unsigned char data)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for (i = 0; i &lt;8; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (data &amp; (1&lt;&lt;i))</span><br><span class="line">&#123;</span><br><span class="line">/* 输出1 */</span><br><span class="line">gpiod_direction_output(ds18b20_data_pin, 0);</span><br><span class="line">my_udelay(2);</span><br><span class="line"></span><br><span class="line">/* 设置为输入: 引脚默认为高 */</span><br><span class="line">gpiod_direction_input(ds18b20_data_pin);</span><br><span class="line">my_udelay(60);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">/* 输出0 */</span><br><span class="line">gpiod_direction_output(ds18b20_data_pin, 0);</span><br><span class="line">my_udelay(60);</span><br><span class="line"></span><br><span class="line">/* 设置为输入: 引脚默认为高 */</span><br><span class="line">gpiod_direction_input(ds18b20_data_pin);</span><br><span class="line">my_udelay(2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char ds18b20_read_byte(void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char data = 0;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; 8; i++)</span><br><span class="line">&#123;</span><br><span class="line">gpiod_direction_output(ds18b20_data_pin, 0);</span><br><span class="line">my_udelay(2);</span><br><span class="line"></span><br><span class="line">/* 设置为输入 */</span><br><span class="line">gpiod_direction_input(ds18b20_data_pin);</span><br><span class="line"></span><br><span class="line">/* 7us之后读引脚 */</span><br><span class="line">my_udelay(7);</span><br><span class="line">if (gpiod_get_value(ds18b20_data_pin))</span><br><span class="line">data |= (1&lt;&lt;i);</span><br><span class="line"></span><br><span class="line">/* 读到数据后, 等待足够60us */</span><br><span class="line">my_udelay(60);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 实现对应的open/read/write等函数，填入file_operations结构体                   */</span><br><span class="line">static ssize_t ds18b20_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long flags;</span><br><span class="line">unsigned char tempL=0,tempH=0;</span><br><span class="line">unsigned int integer;</span><br><span class="line">unsigned char decimal1,decimal2,decimal;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">if (size != 5)</span><br><span class="line">return -EINVAL;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);  // 关中断</span><br><span class="line"></span><br><span class="line">/* 访问DS18B20的流程为：启动温度转换、读取温度 */</span><br><span class="line"></span><br><span class="line">/* 启动温度转换 */</span><br><span class="line">/* 1.发送开始信号 */</span><br><span class="line">/* 2.等待回应信号 */</span><br><span class="line">if(ds18b20_reset())</span><br><span class="line">&#123;</span><br><span class="line">gpiod_direction_output(ds18b20_data_pin, 1);  /* 每次开始前都是高电平 */</span><br><span class="line">local_irq_restore(flags); // 恢复中断</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 3.发出8位的数据，用于选择某个DS18B20 */</span><br><span class="line">ds18b20_write_byte(0xcc); //忽略rom指令，直接使用功能指令</span><br><span class="line"></span><br><span class="line">/* 4.发出温度转换命令 */</span><br><span class="line">ds18b20_write_byte(0x44); //温度转换指令</span><br><span class="line"></span><br><span class="line">/* 5.等待温度转换完毕 */</span><br><span class="line">local_irq_restore(flags); // 恢复中断</span><br><span class="line">//转换需要时间，延时1s</span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">schedule_timeout(HZ); </span><br><span class="line">local_irq_save(flags);  // 关中断</span><br><span class="line"></span><br><span class="line">/* 不能省略！ */</span><br><span class="line">gpiod_direction_output(ds18b20_data_pin, 1);/* 每次开始前都是高电平 */</span><br><span class="line">/* 读取温度 */</span><br><span class="line">/* 1.发送开始信号 */</span><br><span class="line">/* 2.等待回应信号 */</span><br><span class="line">if(ds18b20_reset())</span><br><span class="line">&#123;</span><br><span class="line">gpiod_direction_output(ds18b20_data_pin, 1);/* 每次开始前都是高电平 */</span><br><span class="line">local_irq_restore(flags); // 恢复中断</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 3.发出8位的数据，用于选择某个DS18B20 */</span><br><span class="line">ds18b20_write_byte(0xcc); //忽略rom指令，直接使用功能指令</span><br><span class="line"></span><br><span class="line">/* 4.发出读暂存器的命令 */</span><br><span class="line">ds18b20_write_byte(0xbe); //忽读暂存器指令</span><br><span class="line"></span><br><span class="line">/* 5.读温度低8位，读温度高8位 */</span><br><span class="line">tempL = ds18b20_read_byte(); //读温度低8位</span><br><span class="line">tempH = ds18b20_read_byte(); //读温度高8位</span><br><span class="line"></span><br><span class="line">/* 数据处理 */</span><br><span class="line">if (tempH &gt; 0x7f)      //最高位为1时温度是负</span><br><span class="line">&#123;</span><br><span class="line">tempL    = ~tempL;             //补码转换，取反加一</span><br><span class="line">tempH    = ~tempH+1;      </span><br><span class="line">integer  = tempL/16+tempH*16;      //整数部分</span><br><span class="line">decimal1 = (tempL&amp;0x0f)*10/16; //小数第一位</span><br><span class="line">decimal2 = (tempL&amp;0x0f)*100/16%10;//小数第二位</span><br><span class="line">decimal  = decimal1*10+decimal2; //小数两位</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">integer  = tempL/16+tempH*16;      //整数部分</span><br><span class="line">decimal1 = (tempL&amp;0x0f)*10/16; //小数第一位</span><br><span class="line">decimal2 = (tempL&amp;0x0f)*100/16%10;//小数第二位</span><br><span class="line">decimal  = decimal1*10+decimal2; //小数两位</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local_irq_restore(flags); // 恢复中断</span><br><span class="line"></span><br><span class="line">gpiod_direction_output(ds18b20_data_pin, 1);/* 每次开始前都是高电平 */</span><br><span class="line"></span><br><span class="line">ret = copy_to_user(buf, &amp;integer, 4);</span><br><span class="line">ret = copy_to_user(buf+4, &amp;decimal, 1);</span><br><span class="line"></span><br><span class="line">return 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 定义自己的file_operations结构体                                              */</span><br><span class="line">static struct file_operations ds18b20_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.read    = ds18b20_drv_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 1. 从platform_device获得GPIO</span><br><span class="line"> * 2. gpio=&gt;irq</span><br><span class="line"> * 3. request_irq</span><br><span class="line"> */</span><br><span class="line">static int ds18b20_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">/* 1. 获得硬件信息 */</span><br><span class="line">ds18b20_data_pin = gpiod_get(&amp;pdev-&gt;dev, NULL, GPIOD_OUT_LOW);</span><br><span class="line">if (IS_ERR(ds18b20_data_pin))</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">return PTR_ERR(ds18b20_data_pin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 2. 创建设备 */</span><br><span class="line">device_create(ds18b20_class, NULL, MKDEV(major, 0), NULL, &quot;ds18b20&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int ds18b20_remove(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">device_destroy(ds18b20_class, MKDEV(major, 0));</span><br><span class="line">gpiod_put(ds18b20_data_pin);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static const struct of_device_id ask100_ds18b20[] = &#123;</span><br><span class="line">    &#123; .compatible = &quot;alpha-ds18b20&quot; &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 1. 定义platform_driver */</span><br><span class="line">static struct platform_driver ds18b20s_driver = &#123;</span><br><span class="line">    .probe      = ds18b20_probe,</span><br><span class="line">    .remove     = ds18b20_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = &quot;alpha-ds18b20&quot;,</span><br><span class="line">        .of_match_table = ask100_ds18b20,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 2. 在入口函数注册platform_driver */</span><br><span class="line">static int __init ds18b20_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int err;</span><br><span class="line">    </span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">/* 注册file_operations */</span><br><span class="line">major = register_chrdev(0, &quot;ds18b20&quot;, &amp;ds18b20_fops);  </span><br><span class="line"></span><br><span class="line">ds18b20_class = class_create(THIS_MODULE, &quot;ds18b20_class&quot;);</span><br><span class="line">if (IS_ERR(ds18b20_class)) &#123;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">unregister_chrdev(major, &quot;ds18b20&quot;);</span><br><span class="line">return PTR_ERR(ds18b20_class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    err = platform_driver_register(&amp;ds18b20s_driver); </span><br><span class="line"></span><br><span class="line">return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 3. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数</span><br><span class="line"> *     卸载platform_driver</span><br><span class="line"> */</span><br><span class="line">static void __exit ds18b20_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    platform_driver_unregister(&amp;ds18b20s_driver);</span><br><span class="line">class_destroy(ds18b20_class);</span><br><span class="line">unregister_chrdev(major, &quot;ds18b20&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */</span><br><span class="line"></span><br><span class="line">module_init(ds18b20_init);</span><br><span class="line">module_exit(ds18b20_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="22-实战-红外遥控器HS0038的两种驱动程序"><a href="#22-实战-红外遥控器HS0038的两种驱动程序" class="headerlink" title="22 实战_红外遥控器HS0038的两种驱动程序"></a>22 实战_红外遥控器HS0038的两种驱动程序</h1><h2 id="1-硬件连接-1"><a href="#1-硬件连接-1" class="headerlink" title="1.  硬件连接"></a>1.  硬件连接</h2><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/01_sch-1701229404264.png" alt="image-20220106190332522"></p><h2 id="2-通信协议"><a href="#2-通信协议" class="headerlink" title="2. 通信协议"></a>2. 通信协议</h2><p>我们按下遥控器按键的时候，遥控器自动发送某个红外信号，接收头接收到红外信号，然后把红外信号转换成电平信号，通过IRD这根线，传给SOC。整个传输，只涉及单向传输，由HS0038向主芯片传送。</p><p>因此，我们只需要编写程序，从IRD上获取数据即可，在这之前，我们需要先了解下数据是怎么表示的，也就是传输的红外数据的格式。</p><p>红外协议有：NEC、SONY、RC5、RC6等，常用的就是NEC格式，因此我们主要对NEC进行讲解。</p><p>在分析文章中的波形之前，我们先想象一下怎么在一条数据线上传输信号。</p><p>开始传输数据之前，一般都会发出一个start起始信号，通知对方我开始传输数据了，后面就是每一位每一位的数据。</p><p>NEC协议的开始是一段引导码：</p><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/02_data_seq.png"></p><p>这个引导码由一个9ms的低脉冲加上一个4.5ms的高脉冲组成，它用来通知接收方我要开始传输数据了。</p><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/03_pre_wave.png"></p><p>然后接着的是数据，数据由4字节组成：地址、地址(取反)、数据、数据(取反)，取反是用来校验用的。</p><p>地址是指遥控器的ID，每一类遥控器的ID都不一样，这样就可以防止操控电视的遥控器影响空调。数据就是遥控器上的不同按键值。</p><p>从前面的图可以知道，NEC每次要发32位（地址、地址取反、数据、数据取反，每个8位）的数据。数据的1和0，开始都是0.56ms的低脉冲，对于数据1，后面的高脉冲比较长，对于数据0，后面的高脉冲比较短。</p><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/04_data_wave.png"></p><p>第一次按下按键时，它会发出引导码，地址，地址取反，数据，数据取反。</p><p>如果这时还没松开按键，这就是“长按”，怎么表示“长按”？遥控器会发送一个不一样的引导码，这个引导码由9ms的低脉冲，2.25ms的高脉冲组成，表示现在按的还是上次一样的按键，也叫连发码，它会一直发送，直到松开。</p><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/05_repeat_wave.png"></p><h2 id="3-编程思路"><a href="#3-编程思路" class="headerlink" title="3. 编程思路"></a>3. 编程思路</h2><p>使用中断来实现：</p><ul><li>GPIO引脚配置为双边沿触发中断</li><li>记录中断发生时的时间</li><li>等接到完整的中断后，解析数据</li></ul><p><img src="/2023/12/11/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/06_use_irq.png" alt="image-20220106191056211"></p><h2 id="4-编程"><a href="#4-编程" class="headerlink" title="4. 编程"></a>4. 编程</h2><h3 id="4-1-中断方式"><a href="#4-1-中断方式" class="headerlink" title="4.1 中断方式"></a>4.1 中断方式</h3><h3 id="4-2-输入子系统"><a href="#4-2-输入子系统" class="headerlink" title="4.2 输入子系统"></a>4.2 输入子系统</h3><h1 id="24-实战-I2C设备驱动程序开发1-AT24C02程序框架"><a href="#24-实战-I2C设备驱动程序开发1-AT24C02程序框架" class="headerlink" title="24 实战_I2C设备驱动程序开发1_AT24C02程序框架"></a>24 实战_I2C设备驱动程序开发1_AT24C02程序框架</h1><h2 id="1-检查i2c1总线下的设备是否存在"><a href="#1-检查i2c1总线下的设备是否存在" class="headerlink" title="1 检查i2c1总线下的设备是否存在"></a>1 检查i2c1总线下的设备是否存在</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cdetect -y 0</span><br></pre></td></tr></table></figure><h2 id="2-i2c和输入系统的结合"><a href="#2-i2c和输入系统的结合" class="headerlink" title="2 i2c和输入系统的结合"></a>2 i2c和输入系统的结合</h2><ul><li>GT9xx</li><li>FT5x06</li></ul><h1 id="27-实战-SPI设备驱动开发1-OLED屏幕"><a href="#27-实战-SPI设备驱动开发1-OLED屏幕" class="headerlink" title="27 实战_SPI设备驱动开发1_OLED屏幕"></a>27 实战_SPI设备驱动开发1_OLED屏幕</h1>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC编译器详解</title>
      <link href="/2023/12/11/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/12/11/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-GCC编译器的介绍"><a href="#1-GCC编译器的介绍" class="headerlink" title="1 GCC编译器的介绍"></a>1 GCC编译器的介绍</h1><p>源文件需要经过编译才能生成可执行文件。在 Windows 下进行开发时，只需要点几个按钮即可编译，集成开发环境(比如 Visual studio)已经将各种编译工具的使用封装好了。Linux 下也有很优秀的集成开发工具，但是更多的时候是 直接使用编译工具；即使使用集成开发工具，也需要掌握一些编译选项。  PC 机上的编译工具链为 gcc、ld、objcopy、objdump 等，它们编译出来的程序在 x86 平台上运行。要编译出能在 ARM 平台上运行的程序，必须使用交叉编 译工具 xxx-gcc、xxx-ld 等(不同版本的编译器的前缀不一样，比如 arm-linuxgcc)，下面分别介绍。</p><h1 id="2-GCC编译过程"><a href="#2-GCC编译过程" class="headerlink" title="2 GCC编译过程"></a>2 GCC编译过程</h1><p>一个 C&#x2F;C++文件要经过预处理(preprocessing)、编译(compilation)、汇 编(assembly)和链接(linking)等 4 步才能变成可执行文件。</p><p><img src="/2023/12/11/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106151713868.png" alt="image-20231106151713868"></p><p>通过不同的 gcc 选项可以控制这些过程： </p><p><img src="/2023/12/11/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106151728007.png" alt="image-20231106151728007"></p><h2 id="2-1-预处理"><a href="#2-1-预处理" class="headerlink" title="2.1 预处理"></a>2.1 预处理</h2><p>C&#x2F;C++源文件中，以“#”开头的命令被称为预处理命令，如包含命令 “#include”、宏定义命令“#define”、条件编译命令“#if”、“#ifdef”等。 预处理就是将要包含(include)的文件插入原文件中、将宏定义展开、根据条件 编译命令选择要使用的代码，最后将这些东西输出到一个“.i”文件中等待进一 步处理。 </p><h2 id="2-2-编译"><a href="#2-2-编译" class="headerlink" title="2.2 编译"></a>2.2 编译</h2><p>编译就是把 C&#x2F;C++代码(比如上述的“.i”文件)“翻译”成汇编代码，所用 到的工具为 cc1(它的名字就是 cc1，x86 有自己的 cc1 命令，ARM 板也有自己的cc1 命令)。 </p><h2 id="2-3-汇编"><a href="#2-3-汇编" class="headerlink" title="2.3 汇编"></a>2.3 汇编</h2><p>汇编就是将第二步输出的汇编代码翻译成符合一定格式的机器代码，在Linux 系统上一般表现为 ELF 目标文件(OBJ 文件)，用到的工具为 as。x86 有 自己的 as 命令，ARM 版也有自己的 as 命令，也可能是 xxxx-as（比如 armlinux-as）。</p><p><strong>“反汇编”</strong>是指将机器代码转换为汇编代码，这在调试程序时常常用到。</p><h2 id="2-4-链接"><a href="#2-4-链接" class="headerlink" title="2.4 链接"></a>2.4 链接</h2><p>链接就是将上步生成的 OBJ 文件和系统库的 OBJ 文件、库文件链接起来，最 终生成了可以在特定平台运行的可执行文件，用到的工具为 ld 或 collect2。 </p><h2 id="2-5-gcc使用示例："><a href="#2-5-gcc使用示例：" class="headerlink" title="2.5 gcc使用示例："></a>2.5 gcc使用示例：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c<span class="comment">//输出一个名为 a.out 的可执行程序，然后可以执行./a.out </span></span><br></pre></td></tr></table></figure><p><img src="/2023/12/11/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106152210408.png" alt="image-20231106152210408"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c<span class="comment">// 输出名为 hello 的可执行程序，然后可以执行./hello </span></span><br></pre></td></tr></table></figure><p><img src="/2023/12/11/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106152418847.png" alt="image-20231106152418847"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c -<span class="type">static</span> <span class="comment">// 静态链接 </span></span><br><span class="line">gcc -c -o hello.o hello.c <span class="comment">// 先编译(不链接) </span></span><br><span class="line">gcc -o hello hello.o <span class="comment">// 再链接</span></span><br></pre></td></tr></table></figure><p><img src="/2023/12/11/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106152738286.png" alt="image-20231106152738286"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c -v<span class="comment">//可以查看编译信息</span></span><br></pre></td></tr></table></figure><p><img src="/2023/12/11/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106152934785.png" alt="image-20231106152934785"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E -o hello.i hello.c   <span class="comment">//预处理</span></span><br><span class="line">gcc -S -o hello.s hello.i<span class="comment">//编译</span></span><br><span class="line">gcc -c -o hello.o hello.s<span class="comment">//汇编</span></span><br><span class="line">gcc -o hello hello.o<span class="comment">//链接</span></span><br></pre></td></tr></table></figure><h1 id="3-常用编译选项"><a href="#3-常用编译选项" class="headerlink" title="3 常用编译选项"></a>3 常用编译选项</h1><table><thead><tr><th><strong>常用选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-E</td><td>预处理，开发过程中想快速确定某个宏可以使用“-E -dM”</td></tr><tr><td>-c</td><td>把预处理、编译、汇编都做了，但是不链接</td></tr><tr><td>-o</td><td>指定输出文件</td></tr><tr><td>-I（i）</td><td>指定头文件目录</td></tr><tr><td>-L</td><td>指定链接时库文件目录</td></tr><tr><td>-v</td><td>显示制作 GCC 工具自身时的配置命令；同时显示编译器驱动程序、预处理器、 编译器的版本号</td></tr><tr><td>-l</td><td>指定链接哪一个库文件</td></tr><tr><td>-S</td><td>编译后即停止，不进行汇编</td></tr></tbody></table><h1 id="4-头文件-与“-”区别"><a href="#4-头文件-与“-”区别" class="headerlink" title="4 头文件&lt; &gt;与“ ”区别"></a>4 头文件&lt; &gt;与“ ”区别</h1><ul><li>&lt;&gt;:在库文件目录下查找头文件</li><li>“ ”:     在当前目录下查找头文件</li></ul><p>举个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"> <span class="number">3</span></span><br><span class="line"> <span class="number">4</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line"> 5 &#123;</span><br><span class="line"> <span class="number">6</span>        <span class="type">int</span> i;</span><br><span class="line"> <span class="number">7</span>        <span class="built_in">printf</span>(<span class="string">&quot;Main fun!\n&quot;</span>);</span><br><span class="line"> <span class="number">8</span>        sub_fun();</span><br><span class="line"> <span class="number">9</span>        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test main.c sub.c<span class="comment">//编译成功，不会出现任何错误</span></span><br></pre></td></tr></table></figure><p>将上述代码中的第2行改成：#include “sub.h”，再次编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test main.c sub.c//报错,因为在库文件目录中没有sub.h</span><br></pre></td></tr></table></figure><p><img src="/2023/12/11/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106161746679.png" alt="image-20231106161746679"></p><ul><li><p>解决方法：</p><ul><li><p>在库文件目录中添加sub.h</p></li><li><p>在编译时指定头文件目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test main.c sub.c  -I .///指定在当前目录下查找头文件</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="5-编译多个文件"><a href="#5-编译多个文件" class="headerlink" title="5 编译多个文件"></a>5 编译多个文件</h1><ul><li><p>一起编译、链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test main.c sub.c</span><br></pre></td></tr></table></figure></li><li><p>分开编译，统一链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o main.o main.c</span><br><span class="line">gcc -c -o sub.o sub.c</span><br><span class="line">gcc -o test main.o sub.o</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-制作、使用动态库"><a href="#5-制作、使用动态库" class="headerlink" title="5 制作、使用动态库"></a>5 制作、使用动态库</h1><ul><li><p>第一步 制作、编译:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o main.o main.c</span><br><span class="line">gcc -c -o sub.o sub.c</span><br><span class="line">gcc -shared -o libsub.so sub.o sub2.o sub3.o//可以使用多个.o生成动态库</span><br><span class="line">gcc -o test main.o -lsub  -L .///指定动态库所在目录</span><br></pre></td></tr></table></figure></li><li><p>第2步 运行： </p><ul><li><p>先把 libsub.so 放到 Ubuntu 的&#x2F;lib 目录，然后就可以运行 test 程序。 </p></li><li><p>如果不想把 libsub.so 放到&#x2F;lib，也可以放在某个目录比如&#x2F;a，然后如下执</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/a </span><br><span class="line">./test</span><br></pre></td></tr></table></figure></li></ul><h1 id="6-制作、使用静态库"><a href="#6-制作、使用静态库" class="headerlink" title="6 制作、使用静态库"></a>6 <strong>制作、使用静态库</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o main.o main.c </span><br><span class="line">gcc -c -o sub.o sub.c </span><br><span class="line">ar crs libsub.a sub.o sub2.o sub3.o(可以使用多个.o 生成静态库) </span><br><span class="line">gcc -o test main.o libsub.a (如果.a 不在当前目录下，需要指定它的绝对或相对路径) </span><br></pre></td></tr></table></figure><p>运行：不需要把静态库 libsub.a 放到板子上。 </p><p><strong>注意：</strong>执行 arm-buildroot-linux-gnueabihf-gcc -c -o sub.o sub.c 交叉编译需要在最后面加上-fPIC 参数。 </p><h1 id="7-很有用的选项"><a href="#7-很有用的选项" class="headerlink" title="7 很有用的选项"></a>7 很有用的选项</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c // 查看预处理结果，比如头文件是哪个 </span><br><span class="line">gcc -E -dM main.c &gt; 1.txt // 把所有的宏展开，存在 1.txt 里 </span><br><span class="line">gcc -Wp,-MD,abc.dep -c -o main.o main.c // 生成依赖文件 abc.dep，后面 Makefile 会用 </span><br><span class="line">echo &#x27;main()&#123;&#125;&#x27;| gcc -E -v - // 它会列出头文件目录、库目录(LIBRARY_PATH) </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux知识点总结</title>
      <link href="/2023/12/11/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
      <url>/2023/12/11/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="常用的-Linux-指令"><a href="#常用的-Linux-指令" class="headerlink" title="常用的 Linux 指令"></a>常用的 Linux 指令</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看当前进程</p><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>执行退出</p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>查看当前路径</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>列出指定目录中的目录，以及文件</p><p>参数：</p><ul><li>-a显示所有文件及目录 (. 开头的隐藏文件也会列出)</li><li>-l     除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li><li>-R    若目录下有文件，则以下之文件亦皆依序列出</li></ul><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir test1#在当前目录下，建立一个名为 test1 的子目录</span><br><span class="line">mkdir -p test/test2#在当前目录下的 test 目录中，建立一个名为 test2 的子目录。若 test 目录原本不存在，则建立一个。</span><br></pre></td></tr></table></figure><h3 id="vi-vim"><a href="#vi-vim" class="headerlink" title="vi&#x2F;vim"></a>vi&#x2F;vim</h3><p>打开&#x2F;创建文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi file1.txt  #直接创建并打开一个文件file1.txt</span><br></pre></td></tr></table></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>创建文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file2.txt  #创建新的空文件file2.txt</span><br></pre></td></tr></table></figure><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>创建&#x2F;写入文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;this is a new file&quot; &gt; file3.txt</span><br><span class="line">#创建文件file3.txt并将this is a new file写入（说明：使用&gt;指令覆盖文件原内容并重新输入内容，若文件不存在则创建文件。）</span><br><span class="line"></span><br><span class="line">echo &quot;add contents&quot; &gt;&gt;file3.txt    </span><br><span class="line">#在已存在的文件补充写入新内容add contents（说明：使用&gt;&gt;指令向文件追加内容，原内容将保存。）</span><br><span class="line"></span><br><span class="line">echo hello world#向屏幕输出带空格的字符串，比如”hello world”</span><br></pre></td></tr></table></figure><h3 id="cat、less、more"><a href="#cat、less、more" class="headerlink" title="cat、less、more"></a>cat、less、more</h3><p>三者都是将文件内容输出到标准输出，其中less和more可以分页显示，cat是显示全部。</p><p>三者可以根据已经存在的文件创建新的文件。假设已经存在文件1.txt。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat  1.txt &gt; 2.txt</span><br><span class="line">less 1.txt &gt; 3.txt</span><br><span class="line">more 1.txt &gt; 4.txt</span><br></pre></td></tr></table></figure><p>此时创建的文件内容都和1.txt中文件内容相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1    #把 textfile1 的文档内容加上行号后输入到屏幕</span><br><span class="line">cat -n textfile1 &gt; textfile2  #把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里</span><br><span class="line"></span><br><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3  </span><br><span class="line">#把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里</span><br><span class="line">cat /dev/null &gt; /etc/test.txt #清空 /etc/test.txt 文档内容</span><br></pre></td></tr></table></figure><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>cd最主要的作用是切换目录，在cd后面跟&gt;或&gt;&gt;再加上文件名就可以创建一个内容为空的文件。</p><p>它和 echo的区别之处在于echo可写文件内容，而cd并不能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &gt; file3.txt   #创建新的空文件file3.txt</span><br><span class="line">cd &gt;&gt; file4.txt  #创建新的空文件file4.txt</span><br></pre></td></tr></table></figure><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>复制文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp  –r  test/  newtest      #将当前目录 test/ 下的所有文件复制到新目录 newtest下</span><br></pre></td></tr></table></figure><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>移动文件&#x2F;改文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv source_file(文件) dest_file(文件) #将源文件名 source_file 改为目标文件名 dest_file</span><br><span class="line">mv source_file(文件) dest_directory(目录)   #将文件 source_file 移动到目标目录 dest_directory 中</span><br></pre></td></tr></table></figure><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm  file   #删除当前目录下file文件</span><br><span class="line">rm  -rf   directory/       #删除目录 directory，不管该目录下是否有子目录或文件</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>查找文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grep hello file.txt#在文件 file.txt 中查找字符串 &quot;hello&quot;，并打印匹配的行</span><br><span class="line">grep test *file     #在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印匹配的行</span><br><span class="line">grep -r update /etc/acpi #查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串&quot;update&quot;的文件</span><br><span class="line">grep -v test *test*      #查找文件名中包含 test 的文件中不包含test 的行</span><br><span class="line"></span><br><span class="line">grep &quot;gpio-key&quot; * -nr | grep &quot;\.c&quot;//递归查找，在上一次搜索的结果中再次查找其中后缀是“.c”的文件</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>-i</code>：忽略大小写进行匹配</li><li><code>-v</code>：反向查找，只打印不匹配的行</li><li><code>-n</code>：显示匹配行的行号</li><li><code>-r</code>：递归查找子目录中的文件</li><li>**-**w 或 –word-regexp : 只显示全字符合的列</li></ul><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.c&quot;  #将当前目录及其子目录下所有文件后缀为 .c 的文件列出来</span><br><span class="line">find . -ctime -20   #将当前目录及其子目录下所有最近 20 天内更新过的文件列出</span><br><span class="line"></span><br><span class="line">find -name &quot;*gpio-key*&quot;//查找文件名中带有&quot;*gpio-key*&quot;的文件</span><br><span class="line">find -name &quot;*gpio-key*&quot; | grep &quot;imx&quot;//递归查找</span><br></pre></td></tr></table></figure><h3 id="tar、zip"><a href="#tar、zip" class="headerlink" title="tar、zip"></a>tar、zip</h3><p>压缩文件夹</p><ul><li>bz2格式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -vcjf  test1.tar.bz2  test1 //压缩 test1 文件夹为bz2格式</span><br><span class="line">tar -vxjf test1.tar.bz2 //解压</span><br></pre></td></tr></table></figure><ul><li>gz格式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -vczf test1.tar.gz test1 //压缩 test1 文件夹为gz格式</span><br><span class="line">tar -vxzf test2.tar.gz//解压</span><br></pre></td></tr></table></figure><ul><li>zip</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -rv test2.zip test2 // 压缩 test2 文件夹</span><br><span class="line">unzip test2.zip // 解压 test2.zip</span><br></pre></td></tr></table></figure><h2 id="常用的-GCC-指令"><a href="#常用的-GCC-指令" class="headerlink" title="常用的 GCC 指令"></a>常用的 GCC 指令</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i  #把预处理的结果导出到test.i文件</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s #编译器将test.i翻译成汇编语言，并将结果存储在test.s文件中。</span><br></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o #将汇编代码编译为目标文件（.o）但不链接</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o -o test #将生成的目标文件test.o生成最终的可执行文件test</span><br></pre></td></tr></table></figure><h3 id="一步到位编译"><a href="#一步到位编译" class="headerlink" title="一步到位编译"></a>一步到位编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test #将源文件test.c编译链接为可执行文件test</span><br></pre></td></tr></table></figure><h3 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test1.c test2.c -o test</span><br></pre></td></tr></table></figure><h3 id="警告处理"><a href="#警告处理" class="headerlink" title="警告处理"></a>警告处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -w test.c -o test     # 忽略编译时的警告</span><br><span class="line">gcc -Wall test.c -o test #编译后显示所有警告</span><br><span class="line">gcc -Werror test.c -o test  #在产生警告的地方停止编译</span><br></pre></td></tr></table></figure><h2 id="常用的-GDB-指令"><a href="#常用的-GDB-指令" class="headerlink" title="常用的 GDB 指令"></a>常用的 GDB 指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">gcc -g test.c -o test  #编译时生成debug有关的程序信</span><br><span class="line">gdb test        #启动调试</span><br><span class="line">help #查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h</span><br><span class="line">run #重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r</span><br><span class="line">start #单步执行，运行程序，停在第一执行语句</span><br><span class="line">list #查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l</span><br><span class="line">set #设置变量的值</span><br><span class="line">next #单步调试（逐过程，函数直接执行）,简写n</span><br><span class="line">step #单步调试（逐语句：跳入自定义函数内部执行）,简写s</span><br><span class="line">backtrace #查看函数的调用的栈帧和层级关系,简写bt</span><br><span class="line">frame #切换函数的栈帧,简写f</span><br><span class="line">info #查看函数内部局部变量的数值,简写i</span><br><span class="line">finish #结束当前函数，返回到函数调用点</span><br><span class="line">continue #继续运行,简写c</span><br><span class="line">print #打印值及地址,简写p</span><br><span class="line">quit #退出gdb,简写q</span><br><span class="line">break+num #在第num行设置断点,简写b</span><br><span class="line">info breakpoints #查看当前设置的所有断点</span><br><span class="line">delete breakpoints num #删除第num个断点,简写d</span><br><span class="line">display #追踪查看具体变量值</span><br><span class="line">undisplay #取消追踪观察变量</span><br><span class="line">watch #被设置观察点的变量发生修改时，打印显示</span><br><span class="line">i watch #显示观察点</span><br><span class="line">enable breakpoints #启用断点</span><br><span class="line">disable breakpoints #禁用断点</span><br><span class="line">x #查看内存x/20xw 显示20个单元，16进制，4字节每单元</span><br><span class="line">run argv[1] argv[2] #调试时命令行传参</span><br><span class="line">set follow-fork-mode child #Makefile项目管理：选择跟踪父子进程(fork())</span><br></pre></td></tr></table></figure><h2 id="常用的驱动开发指令"><a href="#常用的驱动开发指令" class="headerlink" title="常用的驱动开发指令"></a>常用的驱动开发指令</h2><h3 id="查看内核中已有的字符设备的信息"><a href="#查看内核中已有的字符设备的信息" class="headerlink" title="查看内核中已有的字符设备的信息"></a>查看内核中已有的字符设备的信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod</span><br></pre></td></tr></table></figure><h3 id="加载-卸载驱动"><a href="#加载-卸载驱动" class="headerlink" title="加载&#x2F;卸载驱动"></a>加载&#x2F;卸载驱动</h3><ul><li>insmod</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insmod led.ko</span><br><span class="line">rmmod  led.ko</span><br></pre></td></tr></table></figure><ul><li>modprobe</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">depmod</span><br><span class="line">modprobe led.ko</span><br><span class="line">rmmod led.ko</span><br></pre></td></tr></table></figure><h3 id="查看驱动中的打印信息"><a href="#查看驱动中的打印信息" class="headerlink" title="查看驱动中的打印信息"></a>查看驱动中的打印信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg</span><br></pre></td></tr></table></figure><h3 id="查看中断号"><a href="#查看中断号" class="headerlink" title="查看中断号"></a>查看中断号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupt</span><br></pre></td></tr></table></figure><h1 id="u-boot"><a href="#u-boot" class="headerlink" title="u-boot"></a>u-boot</h1><p>详细版参考  <code>uboot完全分析与移植</code></p><h2 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h2><p>Linux系统要启动就必须需要一个 bootloader程序，也就说芯片上电以后先运行一段bootloader程序。 这段 bootloader程序会先初始化时钟，看门狗，中断，SDRAM，等外设，然后将 Linux内核从  flash（NAND, NOR FLASH,SD,MMC等）拷贝到SDRAM中，最后启动Linux内核。当然了，  bootloader的实际工作要复杂的多，但是它<strong>最主要的工作就是启动 Linux内核</strong>。</p><p>bootloader和 Linux内核的关系就跟PC上的BIOS和 Windows的关系一样， bootloader就相当于 BIOS。总得来说，Bootloader就是一小段程序，它在系统上电时开始执行，初始化硬件设各、准备好 软件环境，最后调用操作系统内核。</p><h2 id="u-boot启动过程"><a href="#u-boot启动过程" class="headerlink" title="u-boot启动过程"></a>u-boot启动过程</h2><ul><li><p>第一阶段</p><p>初始化时钟，关闭看门狗，关中断，启动ICACHE，关闭DCACHE和TLB，关闭MMU，初始化SDRAM， 初始化NAND FLASH，重定位。</p></li><li><p>第二阶段</p><p>初始化一个串口，检测系统内存映射，将内核映象和根文件系统映象从 Flash上读到SDRAM空间中，为 内核设置启动参数，调用内核</p></li></ul><h2 id="u-boot和内核完成参数传递"><a href="#u-boot和内核完成参数传递" class="headerlink" title="u-boot和内核完成参数传递"></a>u-boot和内核完成参数传递</h2><p>uboot启动后已经完成了基本的硬件初始化（如：内存、串口等），接下来，它的主要任务就是加载 Linux内核到开发板的内存，然后跳转到Linux内核所在的地址运行。</p><p>具体是如何跳转呢？做法很简单，<strong>直接修改PC寄存器的值为Linux内核所在的地址</strong>，这样CPU就会从 Linux内核所在的地址去取指令，从而执行内核代码。</p><p>在前面我们已经知道，在跳转到内核以前，uboot需要做好以下三件事情：</p><ul><li><p><strong>CPU寄存器的设置</strong></p><p>R0&#x3D;0 </p><p>R1&#x3D;机器类型ID；对于ARM结构的CPU，其机器类型ID可以参见 linux&#x2F;arch&#x2F;arm tools&#x2F; mach-types </p><p>R2&#x3D;启动参数标记列表在RAM中起始基地址</p></li><li><p><strong>CPU工作模式</strong> </p><p>必须禁止中断（IRQs和FIQs） </p><p>CPU必须为SVC模式</p></li><li><p><strong>Cache和MMU的设置</strong> </p><p>MMU必须关闭 指令 </p><p>Cache可以打开也可以关闭 数据 </p><p>Cache必须关闭 </p><p>其中上面第一步CPU寄存器的设置中，就是通过R0,R1,R2三个参数给内核传递参数的</p></li></ul><h2 id="为何需要传递参数给内核？"><a href="#为何需要传递参数给内核？" class="headerlink" title="为何需要传递参数给内核？"></a>为何需要传递参数给内核？</h2><p>在此之前，uboot已经完成了硬件的初始化，可以说已经”适应了“这块开发板。然而，内核并不是对于所 有的开发板都能完美适配的（如果适配了，可想而知这个内核有多庞大，又或者有新技术发明了，可以 完美的适配各种开发板），此时，对于开发板的环境一无所知。所以，要想启动Linux内核，uboot必须 要给内核传递一些必要的信息来告诉内核<strong>当前所处的环境</strong>。</p><h2 id="如何给内核传递参数"><a href="#如何给内核传递参数" class="headerlink" title="如何给内核传递参数"></a>如何给内核传递参数</h2><p>uboot把<strong>机器ID通过R1传递给内核</strong>，Linux内核运行的时候，首先就从R1中读取机器ID来判断是否支持 当前机器。这个机器ID实际上就是开发板CPU的ID，每个厂家生产出一款CPU的时候都会给它指定一个 唯一的ID，大家可以到uboot源码的arch\arm\include\asm\mach-type.h文件中去查看。</p><p><img src="/2023/12/11/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20231211123657070.png" alt="image-20231211123657070"></p><p><strong>R2存放的是块内存的基地址</strong>，这块内存中存放的是uboot给Linux内核的其他参数。这些参数有<strong>内存的起 始地址、内存大小、Linux内核启动后挂载文件系统的方式等信息</strong>。很明显，参数有多个，不同的参数 有不同的内容，为了让Linux内核能精确的解析出这些参数，双方在传递参数的时候要求参数在存放的时候需要按照双方规定的格式存放。</p><p><strong>除了约定好参数存放的地址外，还要规定参数的结构</strong>。Linux2.4.x以后的内核都期望以标记列表 （tagged_list）的形式来传递启动参数。标记，就是一种数据结构；标记列表，就是挨着存放的多个标 记。标记列表以标记 ATAG_CORE 开始，以标记 ATAG_NONE 结束。</p><p>标记的数据结构为tag，它由一个tag_header结构和一个联合（union）组成。tag_header结构表示标记 的类型及长度，比如是表示内存还是表示命令行参数等。对于不同类型的标记使用不同的联合 （union），比如表示内存时使用tag_ mem32，表示命令行时使用 tag_cmdline。具体代码见 arch\arm\include\asm\setup.h。</p><p><img src="/2023/12/11/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20231211123647175.png" alt="image-20231211123647175"></p><p>从上面可以看出，struct_tag结构体由structtag_header+联合体union构成，结构体struct tag_header 用来描述每个tag的头部信息，如tag的类型，tag大小。联合体union用来描述每个传递给Linux内核的参 数信息。</p><h2 id="为什么需要关闭caches？"><a href="#为什么需要关闭caches？" class="headerlink" title="为什么需要关闭caches？"></a>为什么需要关闭caches？</h2><p>caches是cpu内部的一个2级缓存，它的作用是将常用的数据和指令放在cpu内部。caches是通过CP15 管理的，刚上电的时候，cpu还不能管理caches。上电的时候指令cache可关闭，也可不关闭，但数据 cache一定要关闭，否则可能导致刚开始的代码里面，去取数据的时候，从cache里面取，而这时候RAM 中数据还没有caches过来，导致数据预取异常。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="根文件系统"><a href="#根文件系统" class="headerlink" title="根文件系统"></a>根文件系统</h2><p>根文件系统首先是一种文件系统，该文件系统不仅具有普通文件系统的存储数据文件的功能，但是相对于普通的文件系统，它的特殊之处在于，它是<strong>内核启动时所挂载（mount）的第一个文件系统</strong>，内核代码的映像文件保存在根文件系统中，系统引导启动程序会在根文件系统挂载之后从中把一些<strong>初始化脚本</strong> （如rcS,inittab）和<strong>服务</strong>加载到内存中去运行，里面包含了 Linux系统能够运行<strong>所必需的应用程序</strong>、<strong>库</strong> 等，比如可以给用户提供操作 Linux的控制界面的shell程序、动态连接的程序运行时需要的glibc库等。 我们要明白文件系统和内核是完全独立的两个部分。在嵌入式中移植的内核下载到开发板上，是没有办 法真正的启动Linux操作系统的，会出现无法加载文件系统的错误。</p><h2 id="跟文件系统的重要性"><a href="#跟文件系统的重要性" class="headerlink" title="跟文件系统的重要性"></a>跟文件系统的重要性</h2><p>根文件系统之所以在前面加一个”根“，说明它是加载其它文件系统的”根“，那么如果没有这个根，其它的 文件系统也就没有办法进行加载的。根文件系统包含系统启动时所必须的目录和关键性的文件，以及使 其他文件系统得以挂载（mount）所必要的文件。例如： </p><ul><li>init进程的应用程序必须运行在根文件系统上。 </li><li>根文件系统提供了根目录“&#x2F;”。 </li><li>linux挂载分区时所依赖的信息存放于根文件系统&#x2F;etc&#x2F;fstab这个文件中。 </li><li>shell命令程序必须运行在根文件系统上，譬如ls、cd等命令。</li></ul><p>总之：一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、&#x2F;bin  &#x2F;sbin等目录下的shell命令，还有&#x2F;lib目录下的库文件等）相配合才能工作</p><h2 id="可执行的映像文件"><a href="#可执行的映像文件" class="headerlink" title="可执行的映像文件"></a>可执行的映像文件</h2><p>可执行映像文件通常由以下几部分构成。 </p><ul><li>一个或多个代码段，代码段的属性为只读。 </li><li>零个或多个包含初始化数据的数据段，数据段的属性为可读写。</li><li>零个或多个不包含初始化数据的数据段，数据段的属性为可读写。</li></ul><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="硬中断和软中断"><a href="#硬中断和软中断" class="headerlink" title="硬中断和软中断"></a>硬中断和软中断</h2><ul><li><strong>硬中断</strong><ul><li>硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的 IRQ（中断请求）。基于IRQ，CPU可以将相应的请求分发到对应的硬件驱动上（注：硬件驱动通 常是内核中的一个子程序，而不是一个独立的进程）。</li><li>处理中断的驱动是需要运行在CPU上的，因此，当中断产生的时候，CPU会中断当前正在运行的任 务，来处理中断。在有多核心的系统上，一个中断通常只能中断一颗CPU（也有一种特殊的情况， 就是在大型主机上是有硬件通道的，它可以在没有主CPU的支持下，可以同时处理多个中断。）</li><li>硬中断可以直接中断CPU。它会引起内核中相关的代码被触发。对于那些需要花费一些时间去处理 的进程，中断代码本身也可以被其他的硬中断中断</li><li>对于时钟中断，内核调度代码会将当前正在运行的进程挂起，从而让其他的进程来运行。它的存在 是为了让调度代码（或称为调度器）可以调度多任务</li></ul></li><li><strong>软中断</strong><ul><li>软中断的处理非常像硬中断。然而，它们仅仅是由当前正在运行的进程所产生的</li><li>通常，软中断是一些对I&#x2F;O的请求。这些请求会调用内核中可以调度I&#x2F;O发生的程序。对于某些设 备，I&#x2F;O请求需要被立即处理，而磁盘I&#x2F;O请求通常可以排队并且可以稍后处理。根据I&#x2F;O模型的不 同，进程或许会被挂起直到I&#x2F;O完成，此时内核调度器就会选择另一个进程去运行。I&#x2F;O可以在进程 之间产生。并且调度过程通常和磁盘I&#x2F;O的方式是相同。</li><li>软中断仅与内核相联系。而内核主要负责对需要运行的任何其他的进程进行调度。一些内核允许设 备驱动的一些部分存在于用户空间，并且当需要的时候内核也会调度这个进程去运行</li><li>软中断并不会直接中断CPU。也只有当前正在运行的代码（或进程）才会产生软中断。这种中断是 一种需要内核为正在运行的进程去做一些事情（通常为I&#x2F;O）的请求。有一个特殊的软中断是Yield 调用，它的作用是请求内核调度器去查看是否有一些其他的进程可以运行</li></ul></li><li><strong>区别</strong><ul><li>1.软中断是执行中断指令产生的，而硬中断是由外设引发的。 </li><li>2.硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。 </li><li>3.硬中断是可屏蔽的，软中断不可屏蔽。 </li><li>4.硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。 </li><li>5.软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部</li></ul></li></ul><h2 id="中断为什么要区分上半部和下半部"><a href="#中断为什么要区分上半部和下半部" class="headerlink" title="中断为什么要区分上半部和下半部"></a>中断为什么要区分上半部和下半部</h2><p>Linux中断分为硬件中断和内部中断（异常），调用过程：外部中断产生-&gt;发送中断信号到中断控制器-&gt; 通知处理器产生中断的中断号，让其进一步处理。 </p><p>对于中断上半部和下半部的产生，为了中断处理过程中被新的中断打断，将中断处理一分为二，上半部 登记新的中断，快速处理简单的任务，剩余复杂耗时的处理留给下半部处理，下半部处理过程中可以被 中断，上半部处理时不可被中断。</p><h2 id="中断的下半部如何实现"><a href="#中断的下半部如何实现" class="headerlink" title="中断的下半部如何实现"></a>中断的下半部如何实现</h2><p>软中断、tasklet、工作队列</p><h2 id="linux中断的响应执行流程"><a href="#linux中断的响应执行流程" class="headerlink" title="linux中断的响应执行流程"></a>linux中断的响应执行流程</h2><p>中断的响应流程：cpu接受中断-&gt;保存中断上下文跳转到中断处理历程-&gt;执行中断上半部-&gt;执行中断下半 部-&gt;恢复中断上下文。 中断的申请request_irq的正确位置：应该是在第一次打开 、硬件被告知终端之前</p><h1 id="Linux驱动模型"><a href="#Linux驱动模型" class="headerlink" title="Linux驱动模型"></a>Linux驱动模型</h1><h2 id="字符设备驱动模型"><a href="#字符设备驱动模型" class="headerlink" title="字符设备驱动模型"></a>字符设备驱动模型</h2><h3 id="驱动初始化"><a href="#驱动初始化" class="headerlink" title="驱动初始化"></a>驱动初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct cdev </span><br><span class="line">&#123;</span><br><span class="line">    struct kobject kobj;</span><br><span class="line">    struct module *owner;</span><br><span class="line">    const struct file_operations *ops; //设备操作集</span><br><span class="line">    struct list_head list;</span><br><span class="line">    dev_t dev; //设备号</span><br><span class="line">    unsigned int count; //设备数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dev是设备号，包含有主设备号和次设备号的信息。主设备号用于区分设备的类型，次设备号用于标记 相同类型的设备的不同个体。</p><p>Linux内核中使用 dev_t 类型来定义设备号， dev_t 这种类型其实质为32位的 unsigned int ，其 中高12位为主设备号，低20位为次设备号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dev_t dev = MKDEV (主设备号，次设备号)    //设备号</span><br><span class="line">主设备号 = MAJOR(dev_t dev)</span><br><span class="line">次设备号=MINOR(dev_t dev)</span><br></pre></td></tr></table></figure><p>主设备号是一个重要的资源，可以通过静态申请和动态分配为设备分配一个主设备号：</p><ul><li>静态申请：自己选择一个未被使用的主设备号，然后通过函数register_chrdev_region向内核 申请使用。</li><li>动态分配：使用 alloc_chrdev_region 由内核分配一个可用的主设备号。</li></ul><p>既然设备号是一种资源，则设备驱动在退出后都应该释放该资源。使用unregister_chrdev_region函数释放设备号。</p><p>ops是操作函数集。 file_operations 是一个很重要的结构，该结构的成员基本都是函数指针，并且是 一些文件操作的函数的指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct file_operations &#123;</span><br><span class="line">  struct module *owner;</span><br><span class="line">  loff_t(*llseek) (struct file *, loff_t, int);</span><br><span class="line">  ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);</span><br><span class="line">  ssize_t(*aio_read) (struct kiocb *, char __user *, size_t, loff_t);</span><br><span class="line">  ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);</span><br><span class="line">  ssize_t(*aio_write) (struct kiocb *, const char __user *, size_t, loff_t);</span><br><span class="line">  int (*readdir) (struct file *, void *, filldir_t);</span><br><span class="line">  unsigned int (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line">  int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);</span><br><span class="line">  int (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">  int (*open) (struct inode *, struct file *);</span><br><span class="line">  int (*flush) (struct file *);</span><br><span class="line">  int (*release) (struct inode *, struct file *);</span><br><span class="line">  int (*fsync) (struct file *, struct dentry *, int datasync);</span><br><span class="line">  int (*aio_fsync) (struct kiocb *, int datasync);</span><br><span class="line">  int (*fasync) (int, struct file *, int);</span><br><span class="line">  int (*lock) (struct file *, int, struct file_lock *);</span><br><span class="line">  ssize_t(*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);</span><br><span class="line">  ssize_t(*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);</span><br><span class="line">  ssize_t(*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void __user *);</span><br><span class="line">  ssize_t(*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);</span><br><span class="line">  unsigned long (*get_unmapped_area) (struct file *, unsigned long,unsigned long, </span><br><span class="line">                  unsigned long,unsigned long);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>驱动初始化四大步骤：</p><ul><li><p>1.分配</p><p>cdev变量的定义可以采用静态和动态两种办法：  </p><p>静态分配： struct cdev mdev；  </p><p>动态分配： struct cdev *pdev &#x3D; cdev_alloc()；</p></li><li><p>2.初始化</p><p>struct cdev的初始化使用cdev_init函数来完成。  </p><p>原型： cdev_init(struct cdev *cdev, const struct file_operations *fops)  </p><p>参数：  </p><p>​cdev：待初始化的cdev结构 </p><p>​ fops：设备对应的操作函数集</p></li><li><p>3.注册</p><p>字符设备的注册使用cdev_add函数来完成。</p><p>原型： cdev_add(struct cdev *p, dev_t dev, unsigned count)</p><p>参数：  </p><p>​p：待添加到内核的字符设备结构  </p><p>​dev：设备号  count：该类设备的设备个数  </p></li><li><p>4.硬件初始化</p><p>根据相应硬件的数据手册完成初始化。</p></li></ul><h3 id="实现设备操作"><a href="#实现设备操作" class="headerlink" title="实现设备操作"></a>实现设备操作</h3><p>由 struct file_operations 可以看出，要实现的操作并不少，这里只介绍一些重要的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int (*open)(struct inode *, struct file *) //打开设备，响应open系统调用</span><br><span class="line">int (*release)(struct inode *, struct file *);//关闭设备，响应close系统调用</span><br><span class="line">loff_t (*llseek)(struct file *, loff_t, int) //重定位读写指针，响应lseek系统调用</span><br><span class="line">ssize_t (*read)(struct file *, char __user *, size_t, loff_t *) //从设备读取数据，响应read系统调用</span><br><span class="line">ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *) //向设备写入数据，响应write系统调用</span><br></pre></td></tr></table></figure><p>内核空间与用户空间传递数据的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int copy_to_user(void __user *to, const void *from, int n)</span><br><span class="line">int copy_from_user(void *to, const void __user *from, int n)</span><br></pre></td></tr></table></figure><h3 id="驱动注销"><a href="#驱动注销" class="headerlink" title="驱动注销"></a>驱动注销</h3><p>驱动注销：当我们从内核中卸载驱动程序的时候，需要使用 cdev_del 函数来完成字符设备的注销。</p><h3 id="驱动程序示例"><a href="#驱动程序示例" class="headerlink" title="驱动程序示例"></a>驱动程序示例</h3><ul><li><strong>老版驱动程序</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/types.h&gt;</span><br><span class="line">#include &lt;linux/kernel.h&gt;</span><br><span class="line">#include &lt;linux/delay.h&gt;</span><br><span class="line">#include &lt;linux/ide.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line"></span><br><span class="line">#define CHRDEVBASE_MAJOR200/* 主设备号 */</span><br><span class="line">#define CHRDEVBASE_NAME&quot;chrdevbase&quot; /* 设备名   */</span><br><span class="line"></span><br><span class="line">static char readbuf[100];/* 读缓冲区 */</span><br><span class="line">static char writebuf[100];/* 写缓冲区 */</span><br><span class="line">static char kerneldata[] = &#123;&quot;kernel data!&quot;&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * @description: 打开设备</span><br><span class="line"> * @param - inode : 传递给驱动的inode</span><br><span class="line"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span><br><span class="line"> *   一般在open的时候将private_data指向设备结构体。</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> */</span><br><span class="line">static int chrdevbase_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">//printk(&quot;chrdevbase open!\r\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * @description: 从设备读取数据 </span><br><span class="line"> * @param - filp : 要打开的设备文件(文件描述符)</span><br><span class="line"> * @param - buf : 返回给用户空间的数据缓冲区</span><br><span class="line"> * @param - cnt : 要读取的数据长度</span><br><span class="line"> * @param - offt : 相对于文件首地址的偏移</span><br><span class="line"> * @return : 读取的字节数，如果为负值，表示读取失败</span><br><span class="line"> */</span><br><span class="line">static ssize_t chrdevbase_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)</span><br><span class="line">&#123;</span><br><span class="line">int retvalue = 0;</span><br><span class="line"></span><br><span class="line">/* 向用户空间发送数据 */</span><br><span class="line">memcpy(readbuf, kerneldata, sizeof(kerneldata));</span><br><span class="line">retvalue = copy_to_user(buf, readbuf, cnt);</span><br><span class="line">if(retvalue == 0)&#123;</span><br><span class="line">printk(&quot;kernel senddata ok!\r\n&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printk(&quot;kernel senddata failed!\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//printk(&quot;chrdevbase read!\r\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * @description: 向设备写数据 </span><br><span class="line"> * @param - filp : 设备文件，表示打开的文件描述符</span><br><span class="line"> * @param - buf : 要写给设备写入的数据</span><br><span class="line"> * @param - cnt : 要写入的数据长度</span><br><span class="line"> * @param - offt : 相对于文件首地址的偏移</span><br><span class="line"> * @return : 写入的字节数，如果为负值，表示写入失败</span><br><span class="line"> */</span><br><span class="line">static ssize_t chrdevbase_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)</span><br><span class="line">&#123;</span><br><span class="line">int retvalue = 0;</span><br><span class="line">/* 接收用户空间传递给内核的数据并且打印出来 */</span><br><span class="line">retvalue = copy_from_user(writebuf, buf, cnt);</span><br><span class="line">if(retvalue == 0)&#123;</span><br><span class="line">printk(&quot;kernel recevdata:%s\r\n&quot;, writebuf);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printk(&quot;kernel recevdata failed!\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//printk(&quot;chrdevbase write!\r\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * @description: 关闭/释放设备</span><br><span class="line"> * @param - filp : 要关闭的设备文件(文件描述符)</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> */</span><br><span class="line">static int chrdevbase_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">//printk(&quot;chrdevbase release！\r\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 设备操作函数结构体</span><br><span class="line"> */</span><br><span class="line">static struct file_operations chrdevbase_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = chrdevbase_open,</span><br><span class="line">.read = chrdevbase_read,</span><br><span class="line">.write = chrdevbase_write,</span><br><span class="line">.release = chrdevbase_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * @description: 驱动入口函数 </span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> */</span><br><span class="line">static int __init chrdevbase_init(void)</span><br><span class="line">&#123;</span><br><span class="line">int retvalue = 0;</span><br><span class="line"></span><br><span class="line">/* 注册字符设备驱动 */</span><br><span class="line">retvalue = register_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME, &amp;chrdevbase_fops);</span><br><span class="line">if(retvalue &lt; 0)&#123;</span><br><span class="line">printk(&quot;chrdevbase driver register failed\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">printk(&quot;chrdevbase init!\r\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * @description: 驱动出口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> */</span><br><span class="line">static void __exit chrdevbase_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 注销字符设备驱动 */</span><br><span class="line">unregister_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME);</span><br><span class="line">printk(&quot;chrdevbase exit!\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * 将上面两个函数指定为驱动的入口和出口函数 </span><br><span class="line"> */</span><br><span class="line">module_init(chrdevbase_init);</span><br><span class="line">module_exit(chrdevbase_exit);</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * LICENSE和作者信息</span><br><span class="line"> */</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;lk&quot;);</span><br></pre></td></tr></table></figure><ul><li><strong>新版驱动程序</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/types.h&gt;</span><br><span class="line">#include &lt;linux/kernel.h&gt;</span><br><span class="line">#include &lt;linux/delay.h&gt;</span><br><span class="line">#include &lt;linux/ide.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/errno.h&gt;</span><br><span class="line">#include &lt;linux/gpio.h&gt;</span><br><span class="line">#include &lt;linux/cdev.h&gt;</span><br><span class="line">#include &lt;linux/device.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;asm/mach/map.h&gt;</span><br><span class="line">#include &lt;asm/uaccess.h&gt;</span><br><span class="line">#include &lt;asm/io.h&gt;</span><br><span class="line"></span><br><span class="line">#define NEWCHRLED_CNT1  /* 设备号个数 */</span><br><span class="line">#define NEWCHRLED_NAME&quot;newchrled&quot;/* 名字 */</span><br><span class="line"></span><br><span class="line">/* newchrled设备结构体 */</span><br><span class="line">struct newchrled_dev&#123;</span><br><span class="line">dev_t devid;/* 设备号  */</span><br><span class="line">struct cdev cdev;/* cdev */</span><br><span class="line">struct class *class;/* 类 */</span><br><span class="line">struct device *device;/* 设备  */</span><br><span class="line">int major;/* 主设备号  */</span><br><span class="line">int minor;/* 次设备号   */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct newchrled_dev newchrled;/* led设备 */</span><br><span class="line"></span><br><span class="line">/* 打开设备 */</span><br><span class="line">static int led_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;newchrled; /* 设置私有数据 */</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从设备读取数据  */</span><br><span class="line">static ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 向设备写数据  */</span><br><span class="line">static ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 关闭/释放设备  */</span><br><span class="line">static int led_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 设备操作函数 */</span><br><span class="line">static struct file_operations newchrled_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_open,</span><br><span class="line">.read = led_read,</span><br><span class="line">.write = led_write,</span><br><span class="line">.release = led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 驱动入口函数 */</span><br><span class="line">static int __init led_init(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 注册字符设备驱动 */</span><br><span class="line">/* 1、创建设备号 */</span><br><span class="line">if (newchrled.major) &#123;/*  定义了设备号 */</span><br><span class="line">newchrled.devid = MKDEV(newchrled.major, 0);</span><br><span class="line">register_chrdev_region(newchrled.devid, NEWCHRLED_CNT, NEWCHRLED_NAME);</span><br><span class="line">&#125; else &#123;/* 没有定义设备号 */</span><br><span class="line">alloc_chrdev_region(&amp;newchrled.devid, 0, NEWCHRLED_CNT, NEWCHRLED_NAME);/* 申请设备号 */</span><br><span class="line">newchrled.major = MAJOR(newchrled.devid);/* 获取分配号的主设备号 */</span><br><span class="line">newchrled.minor = MINOR(newchrled.devid);/* 获取分配号的次设备号 */</span><br><span class="line">&#125;</span><br><span class="line">printk(&quot;newcheled major=%d,minor=%d\r\n&quot;,newchrled.major, newchrled.minor);</span><br><span class="line"></span><br><span class="line">/* 2、初始化cdev */</span><br><span class="line">newchrled.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;newchrled.cdev, &amp;newchrled_fops);</span><br><span class="line"></span><br><span class="line">/* 3、添加一个cdev */</span><br><span class="line">cdev_add(&amp;newchrled.cdev, newchrled.devid, NEWCHRLED_CNT);</span><br><span class="line"></span><br><span class="line">/* 4、创建类 */</span><br><span class="line">newchrled.class = class_create(THIS_MODULE, NEWCHRLED_NAME);</span><br><span class="line">if (IS_ERR(newchrled.class)) &#123;</span><br><span class="line">return PTR_ERR(newchrled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 5、创建设备 */</span><br><span class="line">newchrled.device = device_create(newchrled.class, NULL, newchrled.devid, NULL, NEWCHRLED_NAME);</span><br><span class="line">if (IS_ERR(newchrled.device)) &#123;</span><br><span class="line">return PTR_ERR(newchrled.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 驱动出口函数 */</span><br><span class="line">static void __exit led_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 注销字符设备驱动 */</span><br><span class="line">cdev_del(&amp;newchrled.cdev);  /* 删除cdev */</span><br><span class="line">unregister_chrdev_region(newchrled.devid, NEWCHRLED_CNT); /* 注销设备号 */</span><br><span class="line"></span><br><span class="line">device_destroy(newchrled.class, newchrled.devid);</span><br><span class="line">class_destroy(newchrled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;lk&quot;);</span><br></pre></td></tr></table></figure><h2 id="LCD驱动模型"><a href="#LCD驱动模型" class="headerlink" title="LCD驱动模型"></a>LCD驱动模型</h2><h2 id="总线设备驱动模型"><a href="#总线设备驱动模型" class="headerlink" title="总线设备驱动模型"></a>总线设备驱动模型</h2><p>自内核2.6版本开始，需要关注的是总线、设备和驱动这3个实体，总线将设备和驱动绑定。在Linux内核 系统中注册一个设备的时候，会寻找与之对应驱动进行匹配；相反地，系统中注册一个驱动的时候，会 去寻找一个对应的设备进行匹配。匹配的的工作由总线来完成。</p><p><strong>在Linux设备中有的是没有对应的物理总线的，但为了适配Linux的总线模型，内核针对这种没有物理总 线的设备开发了一种虚拟总线——platform总线。</strong></p><p>将设备和驱动独立开，驱动尽可能写的通用，当来了一个类似的设备1后也可以使用这个驱动，让驱动程 序可以重用。这体现了Linux驱动的软件架构设计的思想。 </p><p>按照这个思路，Linux中的设备和驱动都需要挂接在一种总线上，比如i2c总线上的eeprom，eeprom作 为设备，eeprom的驱动都挂接在i2c驱动上。但是在嵌入式系统中，<strong>soc系统一般都会集成独立的i2c控制器，控制器也是需要驱动的，但是再按照设备-总线-驱动模型进行设计，就会发现无法找到一个合适 总线去挂接控制器设备和控制器驱动了（i2c控制器是挂接在CPU内部的总线上，而不是i2c总线）</strong>，所 以Linux发明了一种<strong>虚拟总线，称为platform总线，相应的设备称为platform_device（控制器设 备），对应的驱动platform_driver（控制器驱动）</strong>，用platform总线来承载这些相对特殊的系统。 </p><p>注意：所谓的platform_device并不是与字符设备、块设备和网络设备并列的概念，而是Linux系统提 供的一种附加手段，例如，在 S3C6410处理器中，把内部集成的I2C、RTC、SPI、LCD、看门狗等控制器都归纳为platform_device，而它们本身就是字符设备。我们要记住，platform 驱动只是在字符设备 驱动外套一层platform_driver 的外壳。引入platform模型符合Linux 设备模型 —— 总线、设备、驱动，设备模型中配套的sysfs节点都可以用，方便我们的开发；当然你也可以选择不用，不过就失去了一 些platform带来的便利。</p><p>设备驱动中引入platform 概念，隔离BSP和驱动。在BSP中定义platform设备和设备使用的资源、设备 的具体匹配信息，而在驱动中，只需要通过API去获取资源和数据，做到了板相关代码和驱动代码的分 离，使得驱动具有更好的可扩展性和跨平台性。</p><p><img src="/2023/12/11/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20231211160624274.png" alt="image-20231211160624274"></p><p>下面分析下总线设备驱动模型的匹配过程</p><p>一边的“device”结构体和另一边的“较稳定的 drivice 代码”的联系：“device_add()”除了将“devcie”结构放 到 bus 的“dev 链表”之外，还会从另一边的“drv”链表中取表元即某个“driver”结构，<strong>用总线里的一个 （.match）函数来作比较</strong>，看另一边的“driver”是否支持一边的“device”。若是能够支持，则接着<strong>调用软件驱动部分的“.probe”函数</strong>。</p><p>“driver_register()”会将“bus_drv_dev”模型中的较稳定代码“driver”结构体放到虚拟总线的某个链表 （drv 链表）中。从另一边的“dev”链表中<strong>取出每一个“device”结构用 bus 中的“.match”函数来作比较， 若支持则调用“.probe”函数</strong>。左右两个注册就建立起来的一种机制。在“.probe”函数中做的事件由自已决 定，打印一句话，或注册一个字符设备，再或注册一个“input_dev”结构体等等都是由自已决定。强制的 把一个驱动程序分为左右两边这种机制而已，可以把这套东西放在任何地方，这里的“driver”只是个结构 体不要被这个名字迷惑，“device”也只是个结构体，里面放什么内容都是由自已决定的。</p><h2 id="输入子系统模型"><a href="#输入子系统模型" class="headerlink" title="输入子系统模型"></a>输入子系统模型</h2><p>每个硬件都有一个input_dev结构体，每个软件都有一个input_handler结构体。input_dev和 input_handler分别通过input_register_device(),input_register_handler()向核心层注册硬件和软件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int input_register_device(struct input_dev *dev)   //*dev:要注册的驱动设备</span><br><span class="line">&#123;</span><br><span class="line"> ... ...</span><br><span class="line">       list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);   //(1)放入链表中</span><br><span class="line"> ... ...</span><br><span class="line">       list_for_each_entry(handler, &amp;input_handler_list, node)  //(2)</span><br><span class="line">       input_attach_handler(dev, handler);</span><br><span class="line"> ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/12/11/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20231211160843845.png" alt="image-20231211160843845"></p><p><strong>从input_dev方向分析：</strong> input设备在增加到input_dev_list链表上之后，会查找 input_handler_list事件 处理链表上的handler进行匹配，这里的匹配 方式与总线设备驱动模型的device和driver匹配过程很相 似，<strong>所有的input_device都挂在input_dev_list上，所有类型的事件都挂在input_handler_list 上，进行 “匹配相亲”</strong>。如果匹配上了，就<strong>调用input_handler的connect函数进行连接</strong>。设备就是在此时注册的</p><p><strong>从input_handler方向分析：</strong>将handler挂到链表input_handler_list下，然后遍历input_dev_list链表,查 找并匹配输入设备对应的事件处理层，如果匹配上了，就调用connect函数进行连接，并创建 input_handle结构。</p><p>所以，不管新添加input_dev还是input_handler,都会进入input_attach_handler()判断两者id是否有支 持, 若两者支持便进行连接。</p><h2 id="platform平台匹配规则"><a href="#platform平台匹配规则" class="headerlink" title="platform平台匹配规则"></a>platform平台匹配规则</h2><p>总线，设备，驱动。匹配规则就是当有一个新的设备挂起时，总线被唤醒，match函数被调用，用 device名字去跟本总线下的所有驱动名字去比较。相反就是用驱动的名字去device链表中和所有device 的名字比较。如果匹配上，才会调用驱动中的probe函数，否则不调用。至于先后顺序，鉴于个人理 解，不会有影响，不管谁先谁后，bus都会完成匹配工作。谈谈对Linux设备驱动模型的认识：设备驱动 模型的出现主要有三个好处，设备与驱动分离，驱动可移植性增强；设备驱动抽象结构以总线结构表示 看起来更加清晰明了，谁是属于哪一条bus的；最后，就是大家最熟悉的热插拔了，设备与驱动分离， 很好的奠定了热插拔机制</p><h1 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h1><h2 id="镜像格式"><a href="#镜像格式" class="headerlink" title="镜像格式"></a>镜像格式</h2><ol><li><strong>uboo</strong>t经过编译直接生成的<strong>elf格式的可执行程序是u-boot</strong>，这个程序类似于windows下的exe格式，在操作系统下是<strong>可以直接执行</strong>的。但是这种格式不能用来烧录下载。我们用来烧录下载的是uboot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用 的）得到的。这个<strong>u-boot.bin就叫镜像（image）</strong>，镜像就是用来烧录到iNand中执行的。 </li><li><strong>linux内核</strong>经过编译后也会生成一个<strong>elf格式的可执行程序，叫vmlinux或vmlinuz</strong>，这个就是原始的未经任何处理加工的原版内核elf文件；嵌入式系统部署时烧录的一般不是这个 vmlinuz&#x2F;vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），<strong>经过制作加工成烧录镜像的文件就叫Image</strong>（制作把78M大的精简成了7.5M，因 此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。 </li><li>原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是 这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且<strong>在image压缩后的文件的前端附加了一部分解压缩代码。构成了一个压缩格式的镜像就叫zImage</strong>。（因为当 年Image大小刚好比一张软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）。 </li><li>uboot为了启动linux内核，还发明了一种内核格式叫uImage。<strong>uImage是由zImage加工得到的， uboot中有一个工具，可以将zImage加工生成uImage</strong>。注意：<strong>uImage不关linux内核的事</strong>，linux 内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给 uboot启动。这个加工过程其实就是在zImage前面加上64字节的uImage的头信息即可。 </li><li>原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage， 是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：<strong>有些 uboot是支持zImage启动的，有些则不支持。但是所有的uboot肯定都支持uImage启动</strong>。 </li><li>如果直接在kernel底下去make uImage会提供mkimage command not found。解决方案是去 uboot&#x2F;tools下cp mkimage &#x2F;usr&#x2F;local&#x2F;bin&#x2F;，复制mkimage工具到系统目录下。再去make  uImage即可</li></ol><p>通过上面的介绍我们了解了内核镜像的各种格式，<strong>如果通过uboot启动内核，Linux必须为uImage 格式</strong>。</p><h2 id="内核中申请内存函数"><a href="#内核中申请内存函数" class="headerlink" title="内核中申请内存函数"></a>内核中申请内存函数</h2><h3 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a>kmalloc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *kmalloc(size_t size, gfp_t flags)</span><br></pre></td></tr></table></figure><p>kmalloc是内核中最常用的一种内存分配方式，它通过调用kmem_cache_alloc函数来实现。kmalloc一 次最多能申请的内存大小由include&#x2F;linux&#x2F;Kmalloc_size.h的内容来决定，在默认的2.6.18内核版本中， kmalloc一次<strong>最多能申请大小为131702B也就是128KB字节</strong>的<strong>连续物理内存</strong>。测试结果表明，如果试图 用kmalloc函数分配大于128KB的内存，编译不能通过</p><h3 id="vmalloc"><a href="#vmalloc" class="headerlink" title="vmalloc"></a>vmalloc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *vmalloc(unsigned long size)</span><br></pre></td></tr></table></figure><p>前面内存分配方式是<strong>物理连续的</strong>，<strong>能保证较低的平均访问时间</strong>。但是在某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也可以接受，这是<strong>就可以分配一段线性连续，物理不连续的地 址，带来的好处是一次可以分配较大块的内存</strong>。vmallocvmalloc对一次能分配的内存大小没有明确限制。出于性能考虑，应谨慎使用vmalloc函数。在测试过程中，<strong>最大能一次分配1GB的空间</strong>。</p><h3 id="dma-alloc-coherent"><a href="#dma-alloc-coherent" class="headerlink" title="dma_alloc_coherent"></a>dma_alloc_coherent</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *dma_alloc_coherent(struct device *dev, size_t size,ma_addr_t *dma_handle, gfp_t gfp)</span><br></pre></td></tr></table></figure><p><strong>DMA是一种硬件机制，允许外围设备和主存之间直接传输IO数据，而不需要CPU的参与</strong>，<strong>使用DMA机制 能大幅提高与设备通信的吞吐量</strong>。DMA操作中，涉及到CPU高速缓存和对应的内存数据一致性的问题， 必须保证两者的数据一致，在x86_64体系结构中，硬件已经很好的解决了这个问题，  dma_alloc_coherent和get_free_pages函数实现差别不大，前者实际是调用alloc_pages函数来分配内存，因此一次分配内存的大小限制和后者一样。__get_free_pages分配的内存同样可以用于DMA操作。 测试结果证明，<strong>dma_alloc_coherent函数一次能分配的最大内存也为4M</strong></p><h3 id="oiremap"><a href="#oiremap" class="headerlink" title="oiremap"></a>oiremap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void * ioremap (unsigned long offset, unsigned long size)</span><br></pre></td></tr></table></figure><p>ioremap是一种更直接的内存“分配”方式，使用时直接指定物理起始地址和需要分配内存的大小，然后将该段物理地址映射到内核地址空间。<strong>ioremap用到的物理地址空间都是事先确定的****，和上面的几种内存分配方式并不太一样，并不是分配一段新的物理内存。</strong>ioremap多用于设备驱动**，可以让CPU直接访问外部设备的IO空间。ioremap能映射的内存由原有的物理内存空间决定，所以没有进行测试</p><h2 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h2><p>对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。也就是说一个进程的最大地址空间为 4G。 </p><p>操作系统的核心是内核(kernel)，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层 硬件设备的所有权限。为了保证内核的安全，<strong>现在的操作系统一般都强制用户进程不能直接操作内核。 具体的实现方式基本都是由操作系统将虚拟地址空间划分为两部分，一部分为内核空间，另一部分为用 户空间。</strong>针对 Linux 操作系统而言，<strong>最高的 1G 字节</strong>(从虚拟地址 0xC0000000 到 0xFFFFFFFF)由内核使 用，称为内核空间。而<strong>较低的 3G 字节</strong>(从虚拟地址 0x00000000 到 0xBFFFFFFF)由各个进程使用，称为用户空间。 </p><p>对上面这段内容我们也可以这样理解： 每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使 用。换句话说就是， <strong>最高 1G 的内核空间是被所有进程共享的</strong>！ 下图描述了每个进程 4G 地址空间的分配情况。</p><p><img src="/2023/12/11/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20231211165915274.png" alt="image-20231211165915274"></p><h2 id="为什么需要区分内核空间与用户空间？"><a href="#为什么需要区分内核空间与用户空间？" class="headerlink" title="为什么需要区分内核空间与用户空间？"></a>为什么需要区分内核空间与用户空间？</h2><p>在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如<strong>清内存、设置时钟</strong> 等。如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。 </p><p>所以，CPU 将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使 用，普通应用程序只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别： Ring0~Ring3。 </p><p>其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在  Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态</p><h2 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h2><p>当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。 </p><p>在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限 制，可以自由地访问任何有效地址，也可以直接进行端口的访问。 </p><p>在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其 地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I&#x2F;O 许可位 图(I&#x2F;O Permission Bitmap)中规定的可访问端口进行直接访问。 </p><p>对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为 所有的代码都是运行在内核态的，因而，用户编写的应用程序代码可以很容易的让操作系统崩溃掉。 </p><p>对于 Linux 来说，通过区分内核空间和用户空间的设计，<strong>隔离了操作系统代码(操作系统的代码要比应用 程序的代码健壮很多)与应用程序代码</strong>。即便是单个应用程序出现错误，也不会影响到操作系统的稳定 性，这样其它的程序还可以正常的运行(Linux 可是个多任务系统啊！)。所以，<strong>区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性</strong>。</p><h2 id="内核空间与用户空间的通信方式"><a href="#内核空间与用户空间的通信方式" class="headerlink" title="内核空间与用户空间的通信方式"></a>内核空间与用户空间的通信方式</h2><h3 id="使用API"><a href="#使用API" class="headerlink" title="使用API"></a>使用API</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_user(x，ptr) //在内核中被调用，获取用户空间指定地址的数值并保存到内核变量x中。</span><br><span class="line">put_user(x，ptr) //在内核中被调用，将内核空间的变量x的数值保存到到用户空间指定地址处。</span><br><span class="line">Copy_from_user()/copy_to_user() //主要应用于设备驱动读写函数中，通过系统调用触发。</span><br></pre></td></tr></table></figure><h3 id="使用proc文件系统"><a href="#使用proc文件系统" class="headerlink" title="使用proc文件系统"></a>使用proc文件系统</h3><p>和sysfs文件系统类似，也可以作为内核空间和用户空间交互的手段。&#x2F;proc 文件系统是一种虚拟文 件系统，通过他可以作为一种linux内核空间和用户空间的。与普通文件不同，这里的虚拟文件的内 容都是动态创建的。使用&#x2F;proc文件系统的方式很简单。调用create_proc_entry，返回一个 proc_dir_entry指针，然后去填充这个指针指向的结构就好了</p><h3 id="使用sysfs文件系统-kobject"><a href="#使用sysfs文件系统-kobject" class="headerlink" title="使用sysfs文件系统+kobject"></a>使用sysfs文件系统+kobject</h3><p>每个在内核中注册的kobject都对应着sysfs系统中的一个目录。可以通过读取根目录下的sys目录中 的文件来获得相应的信息。除了sysfs文件系统和proc文件系统之外，一些其他的虚拟文件系统也 能同样达到这个效果。</p><h3 id="netlink"><a href="#netlink" class="headerlink" title="netlink"></a>netlink</h3><p>netlink socket提供了一组类似于BSD风格的API，用于用户态和内核态的IPC。相比于其他的用户 态和内核态IPC机制，netlink有几个好处：1.使用自定义一种协议完成数据交换，不需要添加一个 文件等。2.可以支持多点传送。3.支持内核先发起会话。4.异步通信，支持缓存机制。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>应该说这是一种比较笨拙的做法，不过确实可以这样用。当处于内核空间的时候，直接操作文件， 将想要传递的信息写入文件，然后用户空间可以读取这个文件便可以得到想要的数据了。下面是一 个简单的测试程序，在内核态中，程序会向“&#x2F;home&#x2F;melody&#x2F;str_from_kernel”文件中写入一条字 符串，然后我们在用户态读取这个文件，就可以得到内核态传输过来的数据了</p><h3 id="使用mmap"><a href="#使用mmap" class="headerlink" title="使用mmap"></a>使用mmap</h3><p>以将内核空间的地址映射到用户空间。在以前做嵌入式的时候用到几次。一方面可以在driver中 修改Struct file_operations结构中的mmap函数指针来重新实现一个文件对应的映射操作。另一方 面，也可以直接打开&#x2F;dev&#x2F;mem文件，把物理内存中的某一页映射到进程空间中的地址上。 其实，除了重写Struct file_operations中mmap函数，我们还可以重写其他的方法如ioctl等，来达 到驱动内核空间和用户空间通信的方式。</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>从内核空间向进程发送信号。这个倒是经常遇到，用户程序出现重大错误，内核发送信号杀死相应 进程。</p><h2 id="内核链表的通用性"><a href="#内核链表的通用性" class="headerlink" title="内核链表的通用性"></a>内核链表的通用性</h2><p>内核中由于要管理大量的设备，但是各种设备各不相同，必须将他们统一起来管理，于是内核设计者就 想到了使用通用链表来处理，通用链表看似神秘，实际上就是<strong>双向循环链表</strong>，<strong>这个链表的每个节点都是 只有指针域，没有任何数据域</strong></p><p><img src="/2023/12/11/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/image-20231211170829736.png" alt="image-20231211170829736"></p><p>使用通用链表的好处是：</p><ol><li>通用链表中每个节点中没有数据域，也就是说无论数据结构有多复杂在链表中只有前后级指针。 </li><li>如果一个数据结构（即是描述设备的设备结构体）想要用通用链表管理，只需要在结构体中包含节 点的字段即可</li><li>双向链表可以从任意一个节点的前后遍历整个链表，遍历非常方便。 </li><li>使用循环链表使得可以不断地循环遍历管理节点，像进程的调度：操作系统会把就绪的进程放在一 个管理进程的就绪队列的通用链表中管理起来，循环不断地，为他们分配时间片，获得cpu进行周 而复始的进程调度</li></ol><h2 id="用户空间到内核空间的执行过程"><a href="#用户空间到内核空间的执行过程" class="headerlink" title="用户空间到内核空间的执行过程"></a>用户空间到内核空间的执行过程</h2><p>1.应用层调用open函数，在VFS层中找到struct inode结构体，判断是字符设备还是块设备，根据设 备号，可以找到对应的驱动程序。</p><p>2.在驱动层中，每个字符设备都有一个struct cdev结构体，这个结构体通过struct inode结构体中的 i_cdev把连接起VFS层和驱动层，struct cdev结构体描述了字符设备所有信息，其中最重要的一项 就是字符设备的操作函数接口 </p><p>3.struct cdev结构体中的struct file结构体记录了操作字符设备的一些函数，比如open read write 函数等。 struct file结构体其实是在VFS层的，通过struct file结构体指针指向驱动层的struct file结构体将驱 动层函数和VFS层链接起来 </p><p>4.任务完成，VFS层会给应用返回一个文件描述符（fd）。这个fd是和struct file结构体对应的</p><h1 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h1><h2 id="主设备号和次设备号的用途"><a href="#主设备号和次设备号的用途" class="headerlink" title="主设备号和次设备号的用途"></a>主设备号和次设备号的用途</h2><p><strong>主设备号：</strong></p><p><strong>主设备号标识设备对应的特定的驱动程序。</strong>虽然现代的linux内核允许多个驱动程序共享主设 备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织。 </p><p><strong>次设备号：</strong></p><p><strong>次设备号由内核使用，用于确定由主设备号对应驱动程序中的各个设备</strong>。依赖于驱动程序的 编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数 组的索引。</p><h2 id="字符设备驱动如何创建设备文件？"><a href="#字符设备驱动如何创建设备文件？" class="headerlink" title="字符设备驱动如何创建设备文件？"></a>字符设备驱动如何创建设备文件？</h2><ol><li><p>手动创建 </p><p>mknod &#x2F;dev&#x2F;led c 250 0 ，其中dev&#x2F;led 为设备节点 ,c 代表字符设备, 250代表主设备号, 0代表 次设备号。</p></li><li><p>自动创建  </p><p>UDEV&#x2F;MDEV是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在 用户态意味着系统要运行之后，在 &#x2F;etc&#x2F;init.d&#x2F;rcS 脚本文件中会执行 mdev -s 自动创建设备节点</p></li></ol><h2 id="如何注册一个字符设备？"><a href="#如何注册一个字符设备？" class="headerlink" title="如何注册一个字符设备？"></a>如何注册一个字符设备？</h2><ol><li><p>void cdev_init(struct cdev *cdev, struct file_operations *fops) </p><p>该注册函数可以将cdev结构嵌入到自己的设备特定的结构中。cdev是一个指向结构体cdev的指 针，而fops是指向一个类似于f file_operations结构（可以是file_operations结构，但不限于该结 构）的指针。 </p></li><li><p>int register_chrdev(unsigned int major, const char *namem , struct file  operations *fopen); </p><p>该注册函数是早期的注册函数，major是设备的主设备号，name是驱动程序的名称，而fops是默 认的file_operations结构（这是只限于file_operations结构）。对于register_chrdev的调用将为给 定的主设备号注册0－255作为次设备号，并为每个 设备建 立一个对应的默认cdev结构</p></li></ol><h2 id="dev目录下的文件如何产生？"><a href="#dev目录下的文件如何产生？" class="headerlink" title="&#x2F;dev目录下的文件如何产生？"></a>&#x2F;dev目录下的文件如何产生？</h2><p>普遍说法有三种方式，devfs机制，udev机制，再有一个就是手动创建设备节点。谈谈个人见解： </p><ol><li>devfs机制从来没用过，应该是2.6以前的内核使用的； </li><li>udev，其实就是现在<strong>常用的device_create()、class_create()这一套接口</strong>，所谓udev是上层用户空 间程序，是基于驱动中创建使用了这两个接口而起作用的，但是udev在日常开发中几乎接触不到， 我们只需在驱动中调用创建节点的这两个API就ok了，剩下的工作就交给udev去做了，有想深究它 具体实现原理的那就自己去研究吧，我觉得会用就行了；</li><li><strong>mknod</strong> ，新手最常用的一种创建设备节点方法，但并非入门后就再没有用途，在某些情境下，或 许有人不想使用udev机制，于是把节点创建工作写在脚本里，这样也是无可厚非的</li></ol><h2 id="字符设备和块设备的区别？"><a href="#字符设备和块设备的区别？" class="headerlink" title="字符设备和块设备的区别？"></a>字符设备和块设备的区别？</h2><p>Linux中I&#x2F;O设备分为两类：块设备和字符设备。两种设备本身没有严格限制，但是，基于不同的功能进 行了分类。 </p><p><strong>字符设备：</strong>提供连续的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持按 字节&#x2F;字符来读写数据。字符终端、串口、鼠标、键盘、摄像头、声卡和显卡等就是典型的字符设备。 </p><p><strong>块设备：</strong>应用程序可以随机访问设备数据，程序可自行确定读取数据的位置。硬盘是典型的块设备，应 用程序可以寻址磁盘上的任何位置，并由此读取数据。此外，数据的读写只能以块(通常是512B)的倍数 进行。与字符设备不同，块设备并不支持基于字符的寻址。如：u盘，SD卡，磁盘等</p><h2 id="为什么需要ioremap？"><a href="#为什么需要ioremap？" class="headerlink" title="为什么需要ioremap？"></a>为什么需要ioremap？</h2><p>ioremp是内核中用来将外设寄存器物理地址映射到主存上去的接口，即将io地址空间映射到虚拟地址空 间上去，便于操作。为什么非要映射呢，因为保护模式下的cpu只认虚拟地址，不认物理地址，给它物 理地址它并不帮你做事，所以你要操作外设上的寄存器必须先映射到虚拟内存空间，拿着虚拟地址去跟 cpu对接，从而操作寄存器。</p><h2 id="insmod-rmmod对应驱动中的函数？"><a href="#insmod-rmmod对应驱动中的函数？" class="headerlink" title="insmod&#x2F;rmmod对应驱动中的函数？"></a>insmod&#x2F;rmmod对应驱动中的函数？</h2><p>分别会执行 module_init() 和 module_exit() 指定的init函数和exit函数。要注意的就是，尽量使在 init函数中出现的资源申请及使用，都要有对应的释放操作在exit中，即init申请，eixt释放。 </p><h2 id="nand驱动的-probe流程"><a href="#nand驱动的-probe流程" class="headerlink" title="nand驱动的 probe流程"></a>nand驱动的 probe流程</h2><p>probe 函数就会与NAND 芯片进行，主要做的事情主要包括这几个方面：读取NAND 芯片的ID ，然后查 表得到这片NAND 芯片的如厂商，page size ，erase size 以及chip size 等信息，接着，根据struct  nand_chip 中options 的值的不同，或者在NAND 芯片中的特定位置查找bad block table ，或者scan  整个NAND 芯片，并在内存中建立bad block table 。说起来复杂，但其实所有的这些动作，都可以在 MTD 提供的一个叫做nand_scan 的函数中完成。</p><h2 id="常用的调式技巧"><a href="#常用的调式技巧" class="headerlink" title="常用的调式技巧"></a>常用的调式技巧</h2><p>利用printk，查看OOP消息，利用strace，利用内核内置的hacking选项，利用ioctl方法，利用&#x2F;proc 文 件系统，使用kgdb。</p><h1 id="驱动中常用的操作函数"><a href="#驱动中常用的操作函数" class="headerlink" title="驱动中常用的操作函数"></a>驱动中常用的操作函数</h1><h2 id="ioremap"><a href="#ioremap" class="headerlink" title="ioremap"></a>ioremap</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void * __ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags)</span><br><span class="line">void *ioremap(unsigned long phys_addr, unsigned long size)</span><br></pre></td></tr></table></figure><p>将一个IO地址空间映射到内核的虚拟地址空间上去，便于访问。</p><p>ioremap是内核提供的用来映射外设寄存器到主存的函数，我们要映射的地址已经从pci_dev中读了出来 （上一步），这样就水到渠成的成功映射了而不会和其他地址有冲突。映射完了有什么效果呢？我举个 例子，比如某个网卡有100 个寄存器，他们都是连在一块的，位置是固定的，假如每个寄存器占4个字节 那么一共400个字节的空间被映射到内存成功后，ioaddr就是这段地址的开头（注意ioaddr是虚拟地 址，而mmio_start是物理地址，它是BIOS得到的，肯定是物理地址，而保护模式下CPU不认物理地址，只认虚拟地址），ioaddr+0就是第一个寄存器的地址，ioaddr+4就是第二个寄存器地址（每个寄存器占 4个字节），以此类推，我们就能够在内存中访问到所有的寄存器进而操控他们了。</p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int open( const char * pathname, int flags);</span><br><span class="line">int open( const char * pathname,int flags, mode_t mode);</span><br></pre></td></tr></table></figure><p>pathname ：文件的名称，可以包含（绝对和相对）路径 </p><p>flags：文件打开模式 </p><p>mode: 用来规定对该文件的所有者，文件的用户组及系统中其他用户的访问权限，则文件权限为： mode&amp;(~umask)</p><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read(int fd, void * buf, size_t count);</span><br></pre></td></tr></table></figure><p>read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中</p><p><strong>返回值</strong>为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据。若参数count 为0, 则 read()不会有作用并返回0。</p><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write (int fd, const void * buf, size_t count);</span><br></pre></td></tr></table></figure><p>write()会把参数buf所指的内存写入count个字节到参数放到所指的文件内</p><p><strong>返回值</strong>，如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中</p><h2 id="copy-to-user"><a href="#copy-to-user" class="headerlink" title="copy_to_user"></a>copy_to_user</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned long copy_to_user(void *to, const void *from, unsigned long n)</span><br></pre></td></tr></table></figure><p>从内核空间中读取数据到用户空间</p><h2 id="copy-from-user"><a href="#copy-from-user" class="headerlink" title="copy_from_user"></a>copy_from_user</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned long copy_from_user(void *to, const void *from, unsigned long n);</span><br></pre></td></tr></table></figure><p>从用户空间中读取数据到内核空间</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于NFS挂载失败问题</title>
      <link href="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装NFS服务"><a href="#1-安装NFS服务" class="headerlink" title="1 安装NFS服务"></a>1 安装NFS服务</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server rpcbind </span><br></pre></td></tr></table></figure><h1 id="2-配置置-nfs"><a href="#2-配置置-nfs" class="headerlink" title="2 配置置 nfs"></a>2 配置置 nfs</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/exports</span><br></pre></td></tr></table></figure><p>打开后在最后一行添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/lk/linux/nfs *(rw,sync,no_root_squash) </span><br></pre></td></tr></table></figure><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20231110185954503.png" alt="image-20231110185954503"></p><h1 id="3-重启NFS"><a href="#3-重启NFS" class="headerlink" title="3 重启NFS"></a>3 重启NFS</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nfs-kernel-server restart </span><br></pre></td></tr></table></figure><h1 id="4-查看NFS版本"><a href="#4-查看NFS版本" class="headerlink" title="4 查看NFS版本"></a>4 查看NFS版本</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /proc/fs/nfsd/versions</span><br></pre></td></tr></table></figure><p>有两种情况：</p><h2 id="4-1-第一种：无法支持-NFS-V2"><a href="#4-1-第一种：无法支持-NFS-V2" class="headerlink" title="4.1 第一种：无法支持 NFS V2"></a>4.1 第一种：无法支持 NFS V2</h2><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20231110191748974.png" alt="image-20231110191748974"></p><p>没有 -2 也没有 +2 ，说明无法支持 NFS V2，目前可以确定 linux kernel 6.2 以上版本会有这个问题，可以通过降低内核版本解决。</p><p>所以需要降低内核版本</p><ul><li><p>查看Ubuntu当前版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p>Ubuntu22.04默认应该是6.2版本：linux-image-6.2.0-36-generic</p></li><li><p>查看已安装的内核版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --get-selections | grep linux-image</span><br></pre></td></tr></table></figure><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20231110190809915.png" alt="image-20231110190809915"></p></li></ul><p>其中linux-image-5.19.0-41-generic是我后面自行安装的，需要切换到这个较低的版本</p><ul><li><p>下载新的内核镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-image-5.19.0-41-generic</span><br></pre></td></tr></table></figure></li><li><p>打开打开 GRUB 配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br></pre></td></tr></table></figure></li><li><p>更改启动内核，将GRUB_DEFAULT&#x3D;0改为如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_DEFAULT=&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 5.19.0-41-generic&quot;</span><br></pre></td></tr></table></figure></li><li><p>更新GRUB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure></li><li><p>重启Ubuntu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li><li><p>再次查看当前内核版本，看是否切换内核成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20231110191508823.png" alt="image-20231110191508823"></p></li><li><p>再次查看NFS版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /proc/fs/nfsd/versions</span><br></pre></td></tr></table></figure><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20231110191610106.png" alt="image-20231110191610106"></p><p>发现已经可以支持V2版本，可以正常使用，如果这里是“ -2 ”，参考下面4.2章节</p></li></ul><h2 id="4-2-第二种：没有开启NFS-V2"><a href="#4-2-第二种：没有开启NFS-V2" class="headerlink" title="4.2 第二种：没有开启NFS V2"></a>4.2 第二种：没有开启NFS V2</h2><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/00a664e4c3ff47de810f22f1d90caeb7.png" alt="img"></p><ul><li><p>修改 &#x2F;etc&#x2F;default&#x2F;nfs-kernel-server配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/nfs-kernel-server</span><br></pre></td></tr></table></figure><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/cb121088d7fd42ec89c50e86548ba7f0.png" alt="img"></p></li><li><p>重启nfs服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nfs-kernel-server restart</span><br></pre></td></tr></table></figure><p>重启之后看是否可以正常使用，如果还是不行，往下看</p></li><li><p>查看一下&#x2F;etc&#x2F;hosts,修改以下地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/a2d6444b2b5942daa14cd166b99d68ba.png" alt="img"></p></li><li><p>再次重启nfs服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nfs-kernel-server restart</span><br></pre></td></tr></table></figure><p>重启之后看是否可以正常使用，如果还是不行，往下看</p></li><li><p>再次查看NFS版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /proc/fs/nfsd/versions</span><br></pre></td></tr></table></figure><p>设置完上述内容后打印nfs的version还是出现-2，接着往下看</p></li><li><p>用netstat看一下nfs对应端口,发现没有udp只有tcp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a | grep &quot;nfs&quot;</span><br></pre></td></tr></table></figure><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/dc84d3471a6940dc998f5023eb9a38af.png" alt="img"></p></li><li><p>设置一下这个文件&#x2F;etc&#x2F;nfs.conf</p><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/d12fb26c2b4b4dd9b1d7d52584d2b486.png" alt="img"></p></li><li><p>再次重启nfs服务，看一下nfs对应端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service nfs-kernel-server restart</span><br><span class="line">netstat -a | grep &quot;nfs&quot;</span><br></pre></td></tr></table></figure><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/9f6b7fef6eab47f993e9d18eff8ff98d.png" alt="img"></p></li><li><p>再次查看NFS版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /proc/fs/nfsd/versions</span><br></pre></td></tr></table></figure><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8ENFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20231110191610106.png" alt="image-20231110191610106"></p></li></ul><p>成功！！！！！！</p><blockquote><p>查看很多篇帖子，以及参考Ubuntu官网：Ubuntu不同版本修改nfs配置的方法，才总结出比较全面的解决办法</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大端与小端</title>
      <link href="/2023/11/03/%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/"/>
      <url>/2023/11/03/%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="1-嵌入式编程中，什么是大端？什么是小端？"><a href="#1-嵌入式编程中，什么是大端？什么是小端？" class="headerlink" title="1.嵌入式编程中，什么是大端？什么是小端？"></a>1.嵌入式编程中，什么是大端？什么是小端？</h1><ul><li>大端模式：低位字节存在高地址上，高位字节存在低地址上</li><li>小端模式：低位字节存在低地址上，高位字节存在高地址上</li></ul><p><img src="/2023/11/03/%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/image-20231103144235652.png" alt="image-20231103144235652"></p><p>​釆用小端模式的CPU对操作数的存放方式是从低字节到高字节，而大端模式对操作数的存放方式是从高 字节到低字节。例如，16位宽的数0x1234在小端模式CPU内存中的存放方式（假设从地址0x4000开始 存放）见表1，而在大端模式CPU内存中的存放方式见表2。</p><p>​表1 0x1234在小端CPU内存中的存放方式</p><p><img src="/2023/11/03/%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/image-20231103144428620.png" alt="image-20231103144428620"></p><p>​表2 0x1234在大端CPU内存中的存放方式</p><p><img src="/2023/11/03/%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/image-20231103144514639.png" alt="image-20231103144514639"></p><p>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybitfields</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> a:<span class="number">4</span>;  <span class="comment">/* 取低4位 */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> b:<span class="number">5</span>;  <span class="comment">/* 取低5位 */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> c:<span class="number">7</span>;  <span class="comment">/* 取低7位 */</span></span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> test.a = <span class="number">2</span>;<span class="comment">/* 取其低四位是0010 */</span></span><br><span class="line"> test.b = <span class="number">3</span>;<span class="comment">/* 取其低五位是00011 */</span></span><br><span class="line"> test.c = <span class="number">0</span>;<span class="comment">/* 取其低七位是0000000 */</span></span><br><span class="line"> i =*((<span class="type">short</span>*)&amp;test);  <span class="comment">/* 上面的16位内存转换成 short类型进行解释 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果为 50。</p><p>如果为小端模式，低位字节在低地址，则 i &#x3D;  0000000  00011   0010，也就是十进制50</p><p>如果为大端模式，低位字节在高地址，则 i &#x3D; 0010  00011   0000000，也就是十进制8576</p><h1 id="2-如何判断处理器是大端模式还是小端模式？"><a href="#2-如何判断处理器是大端模式还是小端模式？" class="headerlink" title="2.如何判断处理器是大端模式还是小端模式？"></a>2.如何判断处理器是大端模式还是小端模式？</h1><h2 id="2-1-使用联合体"><a href="#2-1-使用联合体" class="headerlink" title="2.1 使用联合体"></a>2.1 使用联合体</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int checkCPU(void)</span><br><span class="line">&#123;</span><br><span class="line">union w &#123;</span><br><span class="line">int a;  /* 占4个字节 */</span><br><span class="line">char b;/* 占1个字节 */</span><br><span class="line">&#125;c;</span><br><span class="line">c.a = 1;</span><br><span class="line">return(c.b == 1); /* 判断低字节1存放在高地址还是低地址 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">if (checkCPU())</span><br><span class="line">printf(&quot;小端\r\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;大端\r\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：联合体变量中的成员是<strong>共用一个首地址，共占同一段内存空间</strong>，所以在任意时刻只能存放其中一个成员的值</p><h2 id="2-1-使用指针"><a href="#2-1-使用指针" class="headerlink" title="2.1 使用指针"></a>2.1 使用指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">checkCPU</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> usData = <span class="number">0x1122</span>;                  <span class="comment">/* 占两个字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>*pucData = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;usData;<span class="comment">/* 占一个字节 */</span></span><br><span class="line">    <span class="keyword">return</span> (*pucData == <span class="number">0x22</span>);  <span class="comment">/* 判断低位字节0x22是否存放在低地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(checkCPU())</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;小端\n&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;大端\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-如何进行大小端的转换？"><a href="#3-如何进行大小端的转换？" class="headerlink" title="3.如何进行大小端的转换？"></a>3.如何进行大小端的转换？</h1><h2 id="3-1-int型位变量"><a href="#3-1-int型位变量" class="headerlink" title="3.1 int型位变量"></a>3.1 int型位变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">swapInt32</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp = ((data &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) | ((data &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) | </span><br><span class="line">           ((data &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) |  ((data &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0x11223344</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">b = swapInt32(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,b); <span class="comment">/* 44332211 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-short型位变量"><a href="#3-1-short型位变量" class="headerlink" title="3.1 short型位变量"></a>3.1 short型位变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="title function_">swapShort16</span><span class="params">(<span class="type">short</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp = ((data &amp; <span class="number">0x00FF</span>) &lt;&lt; <span class="number">8</span>) | ((data &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">short</span> a = <span class="number">0x1122</span>;</span><br><span class="line"><span class="type">short</span> b;</span><br><span class="line"></span><br><span class="line">b = swapShort16(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,b); <span class="comment">/* 2211 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-对常量的处理"><a href="#4-对常量的处理" class="headerlink" title="4.对常量的处理"></a>4.对常量的处理</h1><h2 id="4-1-对0x100000赋值"><a href="#4-1-对0x100000赋值" class="headerlink" title="4.1 对0x100000赋值"></a>4.1 对0x100000赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>*)<span class="number">0x100000</span> = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可以看成3步 */</span></span><br><span class="line"><span class="type">int</span> *pAddr;               <span class="comment">/* 定义一个指针变量 */</span></span><br><span class="line">pAddr = (<span class="type">int</span> *)<span class="number">0x100000</span>;  <span class="comment">/* 指向0x100000这个地址 */</span></span><br><span class="line">*pAddr = <span class="number">1234</span>;  <span class="comment">/* 往这个地址里面赋值 */</span></span><br></pre></td></tr></table></figure><h2 id="4-2-让程序跳转到绝对地址是0x100000去执行"><a href="#4-2-让程序跳转到绝对地址是0x100000去执行" class="headerlink" title="4.2 让程序跳转到绝对地址是0x100000去执行"></a>4.2 让程序跳转到绝对地址是0x100000去执行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*((<span class="type">void</span> (*)( ))<span class="number">0x100000</span> ) ( );</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*Func)</span><span class="params">()</span>;         <span class="comment">/* 定义函数类型 Func == void (*)() */</span></span><br><span class="line">Func f;<span class="comment">/* 定义一个函数指针f */</span></span><br><span class="line">f = (Func)<span class="number">0x100000</span><span class="comment">/* 将0x100000强制转换成函数指针,f指向他 */</span></span><br><span class="line">*(f)();                         <span class="comment">/* 调用函数f,这里加不加*都可以 */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信协议</title>
      <link href="/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、通信基础知识"><a href="#一、通信基础知识" class="headerlink" title="一、通信基础知识"></a>一、通信基础知识</h1><h2 id="1-异步通信和同步通信："><a href="#1-异步通信和同步通信：" class="headerlink" title="1.异步通信和同步通信："></a>1.异步通信和同步通信：</h2><ul><li><strong>异步通信：</strong>在发送字符时，所发送的字符之间的时间间隔可以是任意的。当然，接收端必须时刻做好接收的准备。发送端可以在任意时刻开始发送字符，因此必须在每一个字符的开始和结束的地方加上标志，即加上开始位和停止位，以便使接收端能够正确地将每一个字符接收下来。<strong>接收方并不知道数据什么时候会到达，收发双方可以有各自自己的时钟</strong></li><li><strong>同步通信：</strong>发送端在发送串行数据的同时，提供一个时钟信号，并按照一定的约定（例如：在时钟信号的上升沿的时候，将数据发送出去）发送数据，接收端根据发送端提供的时钟信号，以及大家的约定，接收数据。<strong>同步通信中双方使用频率一致的时钟</strong></li></ul><h2 id="2-串行通信与并行通信"><a href="#2-串行通信与并行通信" class="headerlink" title="2.串行通信与并行通信"></a>2.串行通信与并行通信</h2><ul><li><strong>并行通信：</strong>指数据的各位 同时进⾏传送，其特点是传输速度快，但当传输距离较远、位数⼜多时，导致了通信线路复杂且成本提⾼。</li><li><strong>串行通信：</strong>指数据⼀位位地顺序传送，其特点是通信线路简单，只要⼀对传输线就可以实现双向通信，并可以利⽤电话线， 从⽽⼤⼤降低了成本，特别适⽤于远距离通信，但传送速度较慢</li></ul><h2 id="3-全双工、半双工、单工"><a href="#3-全双工、半双工、单工" class="headerlink" title="3.全双工、半双工、单工"></a>3.全双工、半双工、单工</h2><ul><li><strong>全双工：</strong>允许二台设备间<strong>同时</strong>进行双向数据传输</li><li><strong>半双工：</strong>允许二台设备之间的双向数据传输，但<strong>不能同时</strong>进行</li><li><strong>单工：</strong>指数据传输只支持数据在一个方向上传输</li></ul><h1 id="二、串口"><a href="#二、串口" class="headerlink" title="二、串口"></a>二、串口</h1><h2 id="1-串口简介与应用"><a href="#1-串口简介与应用" class="headerlink" title="1.串口简介与应用"></a>1.串口简介与应用</h2><h3 id="1-1简介"><a href="#1-1简介" class="headerlink" title="1.1简介"></a>1.1简介</h3><p>​通用异步收发器 UART（Universal Asynchronous Receiver&#x2F;Transmitter)，是一种<strong>串行、异步、全双工</strong>的通信协议，将所需传输的数据一位接一位地传输，在UART通讯协议中信号线上的状态位高电平代表’1’，低电平代表’0’。其特点是通信线路简单，只要一对传输线就可以实现双向通信，大大降低了成本，但传送速度较慢。</p><h3 id="1-2应用"><a href="#1-2应用" class="headerlink" title="1.2应用"></a>1.2应用</h3><ul><li>打印调试信息</li><li>外接各种模块：GPS、蓝牙、、、、</li></ul><h2 id="2-使用UART设置项"><a href="#2-使用UART设置项" class="headerlink" title="2.使用UART设置项"></a>2.使用UART设置项</h2><ul><li>波特率：传输每一位需要的时间：t &#x3D; 1&#x2F;115200</li><li>格式：数据位、停止位、校验位、流量控制</li><li><img src="/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/image-20231015160815240.png" alt="image-20231015160815240"></li></ul><h2 id="3-电平形式"><a href="#3-电平形式" class="headerlink" title="3.电平形式"></a>3.电平形式</h2><ul><li><strong>TTL&#x2F;CMOS逻辑电平：</strong>0 ~ +5v,  逻辑“0”：&lt;0.8v, 逻辑“1”：&gt;2v。</li><li><strong>RS-232电平：</strong>-12v ~ +12v,逻辑“0”：&lt;-3v, 逻辑“1”：&gt;3v。采取不平衡传输方式，即所谓<strong>单端通讯</strong>，只允许<strong>一对一通信</strong></li><li><strong>RS-485电平：</strong>逻辑“0”：压差&lt;-2v, 逻辑“1”：压差&gt;2v。采用平衡传输，即<strong>差分传输</strong>，允许连接<strong>多达128个</strong>收发器</li></ul><h2 id="4-串口结构图"><a href="#4-串口结构图" class="headerlink" title="4.串口结构图"></a>4.串口结构图</h2><p><img src="/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/image-20231015161453003.png" alt="image-20231015161453003"></p><blockquote><p>串行发送：逐位发送</p><p>发送步骤：开发板中内存中的数据——FIFO—–移位寄存器——逐位发送出去</p><p>如何判断发送完没有？：中断  or  轮询</p></blockquote><h2 id="5-串口编程-STM32F103"><a href="#5-串口编程-STM32F103" class="headerlink" title="5.串口编程_STM32F103"></a>5.串口编程_STM32F103</h2><h3 id="5-1-看原理图确定引脚"><a href="#5-1-看原理图确定引脚" class="headerlink" title="5.1 看原理图确定引脚"></a>5.1 看原理图确定引脚</h3><h4 id="UART1"><a href="#UART1" class="headerlink" title="UART1:"></a>UART1:</h4><ul><li>TX——PA9</li><li>RX——PA10</li></ul><h3 id="5-2-使能GPIO-UART1时钟"><a href="#5-2-使能GPIO-UART1时钟" class="headerlink" title="5.2 使能GPIO&#x2F;UART1时钟"></a>5.2 使能GPIO&#x2F;UART1时钟</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 使能GPIOA/USART1时钟 */</span><br><span class="line">/* RCC_APB2ENR */</span><br><span class="line">pReg = (volatile unsigned int *)(0x40021000 + 0x18);</span><br><span class="line">*pReg |= (1&lt;&lt;2) | (1&lt;&lt;14);</span><br></pre></td></tr></table></figure><h3 id="5-3配置引脚为UART功能"><a href="#5-3配置引脚为UART功能" class="headerlink" title="5.3配置引脚为UART功能"></a>5.3配置引脚为UART功能</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 配置引脚功能: PA9(USART1_TX), PA10(USART1_RX) </span></span><br><span class="line"><span class="comment">* GPIOA_CRH = 0x40010800 + 0x04 */</span></span><br><span class="line">pReg = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40010800</span> + <span class="number">0x04</span>);</span><br><span class="line"><span class="comment">/* PA9(USART1_TX) */</span></span><br><span class="line">*pReg &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">*pReg |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">6</span>);  <span class="comment">/* Output mode, max speed 10 MHz; Alternate function output Push-pull */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PA10(USART1_RX) */</span></span><br><span class="line">*pReg &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">8</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">10</span>));</span><br><span class="line">*pReg |= (<span class="number">0</span>&lt;&lt;<span class="number">8</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">10</span>);  <span class="comment">/* Input mode (reset state); Floating input (reset state) */</span></span><br></pre></td></tr></table></figure><h3 id="5-4-设置串口参数"><a href="#5-4-设置串口参数" class="headerlink" title="5.4 设置串口参数"></a>5.4 设置串口参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint32_t</span> SR;    <span class="comment">/*!&lt; USART Status register, Address offset: 0x00 */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint32_t</span> DR;    <span class="comment">/*!&lt; USART Data register,   Address offset: 0x04 */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint32_t</span> BRR;   <span class="comment">/*!&lt; USART Baud rate register, Address offset: 0x08 */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint32_t</span> CR1;   <span class="comment">/*!&lt; USART Control register 1, Address offset: 0x0C */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint32_t</span> CR2;   <span class="comment">/*!&lt; USART Control register 2, Address offset: 0x10 */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint32_t</span> CR3;   <span class="comment">/*!&lt; USART Control register 3, Address offset: 0x14 */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint32_t</span> GTPR;  <span class="comment">/*!&lt; USART Guard time and prescaler register, Address offset: 0x18 */</span></span><br><span class="line">&#125; USART_TypeDef;</span><br><span class="line"></span><br><span class="line">USART_TypeDef *usart1 = (USART_TypeDef *)<span class="number">0x40013800</span>;</span><br><span class="line"><span class="comment">/* 设置波特率</span></span><br><span class="line"><span class="comment"> * 115200 = 8000000/16/USARTDIV</span></span><br><span class="line"><span class="comment"> * USARTDIV = 4.34</span></span><br><span class="line"><span class="comment"> * DIV_Mantissa = 4</span></span><br><span class="line"><span class="comment"> * DIV_Fraction / 16 = 0.34</span></span><br><span class="line"><span class="comment"> * DIV_Fraction = 16*0.34 = 5</span></span><br><span class="line"><span class="comment"> * 真实波特率:</span></span><br><span class="line"><span class="comment"> * DIV_Fraction / 16 = 5/16=0.3125</span></span><br><span class="line"><span class="comment"> * USARTDIV = DIV_Mantissa + DIV_Fraction / 16 = 4.3125</span></span><br><span class="line"><span class="comment"> * baudrate = 8000000/16/4.3125 = 115942</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIV_Mantissa 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIV_Fraction 5</span></span><br><span class="line">usart1-&gt;BRR = (DIV_Mantissa&lt;&lt;<span class="number">4</span>) | (DIV_Fraction);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置数据格式: 8n1 */</span>  <span class="comment">/* 使能USART1 */</span></span><br><span class="line">usart1-&gt;CR1 = (<span class="number">1</span>&lt;&lt;<span class="number">13</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">12</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">10</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">usart1-&gt;CR2 &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">12</span>);</span><br></pre></td></tr></table></figure><h3 id="5-4-根据状态寄存器读写数据"><a href="#5-4-根据状态寄存器读写数据" class="headerlink" title="5.4 根据状态寄存器读写数据"></a>5.4 根据状态寄存器读写数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 读数据 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">USART_TypeDef *usart1 = (USART_TypeDef *)<span class="number">0x40013800</span>;</span><br><span class="line"><span class="keyword">while</span> ((usart1-&gt;SR &amp; (<span class="number">1</span>&lt;&lt;<span class="number">5</span>)) == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> usart1-&gt;DR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写数据 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">USART_TypeDef *usart1 = (USART_TypeDef *)<span class="number">0x40013800</span>;</span><br><span class="line"><span class="keyword">while</span> ((usart1-&gt;SR &amp; (<span class="number">1</span>&lt;&lt;<span class="number">7</span>)) == <span class="number">0</span>);</span><br><span class="line">usart1-&gt;DR = c;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、SPI协议"><a href="#三、SPI协议" class="headerlink" title="三、SPI协议"></a>三、SPI协议</h1><h2 id="1-SPI应用"><a href="#1-SPI应用" class="headerlink" title="1.SPI应用"></a>1.SPI应用</h2><p>SPI是串行外设接口（Serial Peripheral Interface）的缩写，是美国摩托罗拉公司（Motorola）最先推出的一种同步串行传输规范，也是一种单片机外设芯片串行扩展接口，是一种<strong>串行、同步、全双工</strong>通信总线，所以可以在同一时间发送和接收数据，SPI没有定义速度限制，通常能达到甚至超过10M&#x2F;bps。</p><h2 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h2><ul><li><strong>MISO</strong>:主设备数据输入，从设备数据输出</li><li><strong>MOSI</strong>:主设备数据输入，从设备数据输出</li><li><strong>CS</strong>:从设备使能信号，由主设备控制，一主多从时，CS&#x2F;SS是从芯片是否被主芯片选中的控制信号，只有片选信号为预先规定的使能信号时（高电位或低电位），主芯片对此从芯片的操作才有效,<strong>使用 CS信号线来寻址</strong></li><li><strong>SCLK</strong>:时钟信号，由主设备产生</li></ul><h2 id="3-协议"><a href="#3-协议" class="headerlink" title="3.协议"></a>3.协议</h2><p>SPI通讯时序图：</p><p><img src="/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/image-20231102200224551.png" alt="image-20231102200224551"></p><ul><li><p><strong>起始和停止信号：</strong>在图中的标号1处，CS信号线由高变低，是 SPI 通讯的起始信号。在图中的标号6处，CS信号线由高变低，是 SPI 通讯的停止信号。</p></li><li><p><strong>数据有效性：</strong>SPI使用 MOSI及 MISO 信号线来传输数据，使用 SCK 信号线进行数据同步。 </p><p>MOSI及MISO 数据MSB 先行线在 SCK 的每个时钟周期传输一位数据，且数据输入输出是同时进行的。数据传输时(高位先行)或 LSB( 低位先行)先行并没有作硬性规定，但要保证两个 SP 通讯设备间使用同样协定，一般都会采用上图中的 MSB 先行(高位先行)模式。</p><p>观察图中的2345标号处，MOSI 及 MISO 的数据在 SCK 的上升沿期间变化输出，在SCLK 的下降沿被采样。即在 SCK 的下降沿时刻，MOSI 及 MISO 的数据有效，高电平时表示数据“1”，为低电6时表示数据“0”。在其它时刻，数据无效，MOSI及 MISO为下一次表示数据做准备，每次数据传输可以 8 位或 16 位为单位，每次传输的单位数不受限制。</p></li><li><p><strong>时钟极性（CPOL）和时钟相位（CPHA）</strong></p><p>上面讲的图中的时序只是 SPI 中的其中一种通讯模式，SPI共有四种通讯模式，它们的主要区别是:总线闲时 SCK 的时钟状态以及数据采样时刻。为方便说明，在此引入”时钟极性CPOL”和时钟相位 CPHA”<br><strong>时钟极性</strong>是指 SPI 通讯设备处于空闲状态时，SCK 信号线的电平信号(即 SPI 通讯开始CS 线为高电平时 SCK的状态)。 CPOL&#x3D;O 时，SCK 在空闲状态时为低电平，CPOL&#x3D;1前、时，则相反。<br><strong>时钟相</strong>位 CPHA 是指数据的采样的时刻，当 CPHA&#x3D; 0时，MOSI 或 MISO 数据线上的信号将会在 SCK 时钟线的“奇数边沿”被采样。当 CPHA&#x3D;1时，数据线在 SCK的“偶数边沿”采样</p></li></ul><h2 id="4-SPI编程-STM32F103"><a href="#4-SPI编程-STM32F103" class="headerlink" title="4.SPI编程_STM32F103"></a>4.SPI编程_STM32F103</h2><h3 id="4-1-看原理图确定引脚"><a href="#4-1-看原理图确定引脚" class="headerlink" title="4.1.看原理图确定引脚"></a>4.1.看原理图确定引脚</h3><p>SPI1_SCK:PB3</p><p>SPI1_MISO:PB4</p><p>SPI1_MOSI:PB5</p><h3 id="4-2-使能GPIO-SPI1时钟"><a href="#4-2-使能GPIO-SPI1时钟" class="headerlink" title="4.2.使能GPIO&#x2F;SPI1时钟"></a>4.2.使能GPIO&#x2F;SPI1时钟</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);<span class="comment">//使能GPIOB时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);<span class="comment">//使能SPI1时钟</span></span><br></pre></td></tr></table></figure><h3 id="4-3-配置引脚为UART功能"><a href="#4-3-配置引脚为UART功能" class="headerlink" title="4.3.配置引脚为UART功能"></a>4.3.配置引脚为UART功能</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GPIOFB3,4,5初始化设置</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;<span class="comment">//PB3~5复用功能输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;<span class="comment">//复用功能</span></span><br><span class="line">GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;<span class="comment">//100MHz</span></span><br><span class="line">GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;<span class="comment">//上拉</span></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">GPIO_PinAFConfig(GPIOB,GPIO_PinSource3,GPIO_AF_SPI1); <span class="comment">//PB3复用为 SPI1</span></span><br><span class="line">GPIO_PinAFConfig(GPIOB,GPIO_PinSource4,GPIO_AF_SPI1); <span class="comment">//PB4复用为 SPI1</span></span><br><span class="line">GPIO_PinAFConfig(GPIOB,GPIO_PinSource5,GPIO_AF_SPI1); <span class="comment">//PB5复用为 SPI1</span></span><br></pre></td></tr></table></figure><h3 id="4-4-设置SPI参数"><a href="#4-4-设置SPI参数" class="headerlink" title="4.4.设置SPI参数"></a>4.4.设置SPI参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  <span class="comment">//设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工</span></span><br><span class="line">SPI_InitStructure.SPI_Mode = SPI_Mode_Master;<span class="comment">//设置SPI工作模式:设置为主SPI</span></span><br><span class="line">SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;<span class="comment">//设置SPI的数据大小:SPI发送接收8位帧结构</span></span><br><span class="line">SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;<span class="comment">//串行同步时钟的空闲状态为高电平</span></span><br><span class="line">SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;<span class="comment">//串行同步时钟的第二个跳变沿（上升或下降）数据被采样</span></span><br><span class="line">SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;<span class="comment">//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制</span></span><br><span class="line">SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;<span class="comment">//定义波特率预分频的值:波特率预分频值为256</span></span><br><span class="line">SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;<span class="comment">//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始</span></span><br><span class="line">SPI_InitStructure.SPI_CRCPolynomial = <span class="number">7</span>;<span class="comment">//CRC值计算的多项式</span></span><br><span class="line">SPI_Init(SPI1, &amp;SPI_InitStructure);  <span class="comment">//根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器</span></span><br><span class="line">SPI_Cmd(SPI1, ENABLE); <span class="comment">//使能SPI外设</span></span><br></pre></td></tr></table></figure><h3 id="4-5-根据状态寄存器读写数据"><a href="#4-5-根据状态寄存器读写数据" class="headerlink" title="4.5.根据状态寄存器读写数据"></a>4.5.根据状态寄存器读写数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SPI1 读写一个字节</span></span><br><span class="line"><span class="comment">//TxData:要写入的字节</span></span><br><span class="line"><span class="comment">//返回值:读取到的字节</span></span><br><span class="line">u8 <span class="title function_">SPI1_ReadWriteByte</span><span class="params">(u8 TxData)</span></span><br><span class="line">&#123;  </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET)&#123;&#125;<span class="comment">//等待发送区空  </span></span><br><span class="line"></span><br><span class="line">SPI_I2S_SendData(SPI1, TxData); <span class="comment">//通过外设SPIx发送一个byte  数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET)&#123;&#125; <span class="comment">//等待接收完一个byte  </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1); <span class="comment">//返回通过SPIx最近接收的数据</span></span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、IIC协议"><a href="#四、IIC协议" class="headerlink" title="四、IIC协议"></a>四、IIC协议</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>IIC协议是由数据线SDA和时钟线SCL构成的串行总线，可发送和接收数据，是一个<strong>多主机的同步、串行、半双工通信方式</strong>每个挂接在总线上的器件都有下难一的地址立速在标准模式下可达 100kbit&#x2F;s,在快速模式下可达400kbit&#x2F;s，在高速模式下可待3.4Mbit&#x2F;s。</p><p>I2C总线系统结构,如下所示:</p><p><img src="/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/image-20231102202844411.png" alt="image-20231102202844411"></p><h2 id="2-协议"><a href="#2-协议" class="headerlink" title="2.协议"></a>2.协议</h2><h3 id="2-1-空闲状态"><a href="#2-1-空闲状态" class="headerlink" title="2.1.空闲状态"></a>2.1.空闲状态</h3><p>​当总线上的SDA和SCL两条信号线同时处于高电平,便是空闲状态,如上面的硬件图所示,当我们不传输数据 时, SDA和SCL被上拉电阻拉高,即进入空闲状态</p><h3 id="2-2-起始信号"><a href="#2-2-起始信号" class="headerlink" title="2.2.起始信号"></a>2.2.起始信号</h3><p>​当SCL为高期间，SDA由高到低的跳变；便是总线的启动信号,只能由主机发起,且在空闲状态下才能启动 该信号,如下图所示：</p><p><img src="/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/image-20231102203404673.png" alt="image-20231102203404673"></p><h3 id="2-3-停止信号"><a href="#2-3-停止信号" class="headerlink" title="2.3.停止信号"></a>2.3.停止信号</h3><p>​当SCL为高期间，SDA由低到高的跳变；便是总线的停止信号,表示数据已传输完成,如下图所示：</p><p><img src="/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/image-20231102203428037.png" alt="image-20231102203428037"></p><h3 id="2-4-传输数据格式"><a href="#2-4-传输数据格式" class="headerlink" title="2.4.传输数据格式"></a>2.4.传输数据格式</h3><p>​当发了起始信号后,就开始传输数据,传输的数据格式如下图所示：</p><p>当SCL为高电平时,便会获取SDA数据值,其中SDA数据必须是稳定的(若SDA不稳定就会变成起始&#x2F;停止信 号)。</p><p>当SCL为低电平时,便是SDA的电平变化状态</p><p>若主从机在传输数据期间,需要完成其它功能(例如中断),可以主动拉低SCL,使I2C进入等待状态,直到处理结束再释放SCL,数据传输会继续</p><p><img src="/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/image-20231102203617556.png" alt="image-20231102203617556"></p><h3 id="2-5-应答信号"><a href="#2-5-应答信号" class="headerlink" title="2.5.应答信号"></a>2.5.应答信号</h3><p>I2C总线上的数据都是以<strong>8位数据(字节)<strong>进行的，当发送了8个数据后，</strong>发送方</strong>会在第9个时钟脉冲期间<strong>释放SDA数据</strong>，当接收方接收该字节成功，便会输出一个ACK应答信号，当SDA为高电平,表示为非应答信号NACK，当SDA为低电平，表示为有效应答信号ACK PS:</p><p>当主<strong>机为接收方时,收到最后一个字节后,主机可以不发送ACK,直接发送停止信号来结束传输</strong>。 当从机为接收方时，没有发送ACK，则表示从机可能在忙其它事、或者不匹配地址信号和不支持多主机 发送，主机可以发送停止信号，再次发送起始信号启动新的传输。</p><p><img src="/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/image-20231102204513302.png" alt="image-20231102204513302"></p><h3 id="2-6-完整数据传输"><a href="#2-6-完整数据传输" class="headerlink" title="2.6.完整数据传输"></a>2.6.完整数据传输</h3><p>如下图所示, <strong>发送起始信号后</strong>,便发送一个<strong>8位的设备地址</strong>,其中<strong>第8位是对设备的读写标志</strong>,后面紧跟着的就是<strong>数据</strong>了,直到发送停止信号止。</p><p>PS:当我们第一次是读操作，然后想换成写操作时，可以再次发送一个起始信号，然后发送读的设备地 址，不需要停止信号便能实现不同的地址转换。</p><p><img src="/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/image-20231102204641094.png" alt="image-20231102204641094"></p><h2 id="3-数据格式"><a href="#3-数据格式" class="headerlink" title="3.数据格式"></a>3.数据格式</h2><h3 id="3-1-写操作"><a href="#3-1-写操作" class="headerlink" title="3.1.写操作"></a>3.1.写操作</h3><p>刚开始主芯片要发出一个<strong>start信号</strong>，然后发出一个<strong>设备地址</strong>(用来确定是往哪一个芯片写数据)，<strong>方向</strong>(读&#x2F;写，0表示写，1表示读)。<strong>回应</strong>(用来确定这个设备是否存在)，然后就可以<strong>传输数据</strong>，传输数据之后，要有一个<strong>回应信号</strong>（确定数据是否接受完成)，然后再传输下一个数据。每传输一个数据，接受方都会有一个回应信号，数据发送完之后，主芯片就会发送一个<strong>停止信号</strong>。</p><p>白色背景：主→从。灰色背景：从→主</p><p><img src="/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/image-20231102204958271.png" alt="image-20231102204958271"></p><h3 id="3-2-读操作"><a href="#3-2-读操作" class="headerlink" title="3.2.读操作"></a>3.2.读操作</h3><p>刚开始主芯片要发出一个<strong>start信号</strong>，然后发出一个<strong>设备地址</strong>(用来确定是从哪一个芯片读取数据)，<strong>方向</strong>(读&#x2F;写，0表示写，1表示读)。<strong>回应</strong>(用来确定这个设备是否存在)，然后就可以<strong>传输数据</strong>，传输数据之 后，要有一个回应信号（确定数据是否接受完成)，然后在传输下一个数据。每传输一个数据，接受方都 会有一个回应信号，数据发送完之后，主芯片就会发送一个停止信号。 </p><p>白色背景：主→从。灰色背景：从→主</p><p><img src="/2023/11/02/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/image-20231102205105562.png" alt="image-20231102205105562"></p><h2 id="4-IIC编程"><a href="#4-IIC编程" class="headerlink" title="4.IIC编程"></a>4.IIC编程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myiic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//本程序只供学习使用，未经作者许可，不得用于其它任何用途</span></span><br><span class="line"><span class="comment">//ALIENTEK STM32F407开发板</span></span><br><span class="line"><span class="comment">//IIC 驱动代码   </span></span><br><span class="line"><span class="comment">//正点原子@ALIENTEK</span></span><br><span class="line"><span class="comment">//技术论坛:www.openedv.com</span></span><br><span class="line"><span class="comment">//创建日期:2014/5/6</span></span><br><span class="line"><span class="comment">//版本：V1.0</span></span><br><span class="line"><span class="comment">//版权所有，盗版必究。</span></span><br><span class="line"><span class="comment">//Copyright(C) 广州市星翼电子科技有限公司 2014-2024</span></span><br><span class="line"><span class="comment">//All rights reserved  </span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////// </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化IIC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);<span class="comment">//使能GPIOB时钟</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//GPIOB8,B9初始化设置</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;<span class="comment">//普通输出模式</span></span><br><span class="line">  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;<span class="comment">//100MHz</span></span><br><span class="line">  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;<span class="comment">//上拉</span></span><br><span class="line">  GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<span class="comment">//初始化</span></span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">IIC_SDA=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产生IIC起始信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SDA_OUT();     <span class="comment">//sda线输出</span></span><br><span class="line">IIC_SDA=<span class="number">1</span>;    </span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line"> IIC_SDA=<span class="number">0</span>;<span class="comment">//START:when CLK is high,DATA change form high to low </span></span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;<span class="comment">//钳住I2C总线，准备发送或接收数据 </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//产生IIC停止信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SDA_OUT();<span class="comment">//sda线输出</span></span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">IIC_SDA=<span class="number">0</span>;<span class="comment">//STOP:when CLK is high DATA change form low to high</span></span><br><span class="line"> delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>; </span><br><span class="line">IIC_SDA=<span class="number">1</span>;<span class="comment">//发送I2C总线结束信号</span></span><br><span class="line">delay_us(<span class="number">4</span>);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等待应答信号到来</span></span><br><span class="line"><span class="comment">//返回值：1，接收应答失败</span></span><br><span class="line"><span class="comment">//        0，接收应答成功</span></span><br><span class="line">u8 <span class="title function_">IIC_Wait_Ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 ucErrTime=<span class="number">0</span>;</span><br><span class="line">SDA_IN();      <span class="comment">//SDA设置为输入  </span></span><br><span class="line">IIC_SDA=<span class="number">1</span>;delay_us(<span class="number">1</span>);   </span><br><span class="line">IIC_SCL=<span class="number">1</span>;delay_us(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">while</span>(READ_SDA)</span><br><span class="line">&#123;</span><br><span class="line">ucErrTime++;</span><br><span class="line"><span class="keyword">if</span>(ucErrTime&gt;<span class="number">250</span>)</span><br><span class="line">&#123;</span><br><span class="line">IIC_Stop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">IIC_SCL=<span class="number">0</span>;<span class="comment">//时钟输出0    </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//产生ACK应答</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">SDA_OUT();</span><br><span class="line">IIC_SDA=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不产生ACK应答    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_NAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">SDA_OUT();</span><br><span class="line">IIC_SDA=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;      </span><br><span class="line"><span class="comment">//IIC发送一个字节</span></span><br><span class="line"><span class="comment">//返回从机有无应答</span></span><br><span class="line"><span class="comment">//1，有应答</span></span><br><span class="line"><span class="comment">//0，无应答  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Send_Byte</span><span class="params">(u8 txd)</span></span><br><span class="line">&#123;                        </span><br><span class="line">    u8 t;   </span><br><span class="line">SDA_OUT();     </span><br><span class="line">    IIC_SCL=<span class="number">0</span>;<span class="comment">//拉低时钟开始数据传输</span></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">    &#123;              </span><br><span class="line">        IIC_SDA=(txd&amp;<span class="number">0x80</span>)&gt;&gt;<span class="number">7</span>;</span><br><span class="line">        txd&lt;&lt;=<span class="number">1</span>;   </span><br><span class="line">delay_us(<span class="number">2</span>);   <span class="comment">//对TEA5767这三个延时都是必须的</span></span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>); </span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">//读1个字节，ack=1时，发送ACK，ack=0，发送nACK   </span></span><br><span class="line">u8 <span class="title function_">IIC_Read_Byte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ack)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i,receive=<span class="number">0</span>;</span><br><span class="line">SDA_IN();<span class="comment">//SDA设置为输入</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++ )</span><br><span class="line">&#123;</span><br><span class="line">        IIC_SCL=<span class="number">0</span>; </span><br><span class="line">        delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">        receive&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(READ_SDA)receive++;   </span><br><span class="line">delay_us(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">        IIC_NAck();<span class="comment">//发送nACK</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        IIC_Ack(); <span class="comment">//发送ACK   </span></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2023/10/27/%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/10/27/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-链表的概念"><a href="#1-链表的概念" class="headerlink" title="1.链表的概念"></a>1.链表的概念</h2><p>链表是一种常见的基础数据结构，结构体指针在这里得到了充分的利用。链表可以动态的进行存储分配，也就是说，链表是一个功能极为强大的数组，它可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点。</p><p>链表都有一个头指针，一般以head来表示，存放的是一个地址。链表中的节点分为两类，头结点和一般节点，头结点是没有数据域的。链表中每个节点都分为两部分，一个数据域，一个是指针域。说到这里你应该就明白了，链表就如同车链子一样，head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放个“NULL”（表示“空地址”），链表到此结束</p><h2 id="1-链表操作的难点-指针"><a href="#1-链表操作的难点-指针" class="headerlink" title="1. 链表操作的难点:指针"></a>1. 链表操作的难点:指针</h2><p>理解了指针，对于链表就容易理解了。</p><p>2个口诀：</p><ul><li>变量变量，能变，就是能读能写，必定在内存里</li><li>指针指针，保存的是地址，32位处理器中地址都是32位的，无论是什么类型的指针变量，都是4字节</li></ul><h2 id="2-链表类型"><a href="#2-链表类型" class="headerlink" title="2. 链表类型"></a>2. 链表类型</h2><p><img src="/%E9%93%BE%E8%A1%A8/01_link_type.png" alt="image-20220313120114693"></p><h2 id="3-普通的链表插入删除排序操作"><a href="#3-普通的链表插入删除排序操作" class="headerlink" title="3. 普通的链表插入删除排序操作"></a>3. 普通的链表插入删除排序操作</h2><h3 id="3-1-创建链表"><a href="#3-1-创建链表" class="headerlink" title="3.1 创建链表"></a>3.1 创建链表</h3><ul><li>创建两个结构体，一个表示链表的头部，一个表示链表项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *name; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-初始化链表"><a href="#3-2-初始化链表" class="headerlink" title="3.2 初始化链表"></a>3.2 初始化链表</h3><ul><li>让链表的头部指向为NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *pList, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">pList-&gt;name = name;</span><br><span class="line">pList-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-插入链表"><a href="#3-3-插入链表" class="headerlink" title="3.3 插入链表"></a>3.3 插入链表</h3><ul><li><p>往链表的最后一项插入，最后一项指向为NULL</p><p><img src="/%E9%93%BE%E8%A1%A8/image-20231027182219023.png" alt="image-20231027182219023"></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AddItemToList</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *pList, <span class="keyword">struct</span> person *new_persion)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">last</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果是空链表 */</span></span><br><span class="line"><span class="keyword">if</span> (pList-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pList-&gt;next = new_persion;</span><br><span class="line">new_persion-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 找出链表的最后一项 */</span></span><br><span class="line">last = pList-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (last-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">last = last-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* last-&gt;next == NULL */</span></span><br><span class="line">last-&gt;next = new_persion;</span><br><span class="line">new_persion-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-链表中删除项"><a href="#3-4-链表中删除项" class="headerlink" title="3.4 链表中删除项"></a>3.4 链表中删除项</h3><p>分为两种情况：</p><ul><li><p>删除的是第一项</p><p><img src="/%E9%93%BE%E8%A1%A8/image-20231027181925007.png" alt="image-20231027181925007"></p></li><li><p>删除的是其他项</p><p><img src="/%E9%93%BE%E8%A1%A8/image-20231027182349405.png" alt="image-20231027182349405"></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelItemFromList</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *pList, <span class="keyword">struct</span> person *person)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">p</span> =</span> pList-&gt;next;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">pre</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 找到person */</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p != person)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 后面还有人, 移动到下一个 */</span></span><br><span class="line">pre = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 退出的条件: p==NULL, p == person */</span></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;can not find the person to del\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>) <span class="comment">/* 前面无人, 表示要删除的是第1项 */</span></span><br><span class="line">&#123;</span><br><span class="line">pList-&gt;next = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;next = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-链表排序"><a href="#3-5-链表排序" class="headerlink" title="3.5 链表排序"></a>3.5 链表排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SortList</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *pList)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">pre</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *tmp_name;</span><br><span class="line"><span class="type">int</span> tmp_age;</span><br><span class="line"></span><br><span class="line">pre = pList-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pre)</span><br><span class="line">&#123;</span><br><span class="line">next = pre-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pre-&gt;age &gt; next-&gt;age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 交换值 */</span></span><br><span class="line">tmp_name = pre-&gt;name;</span><br><span class="line">pre-&gt;name = next-&gt;name;</span><br><span class="line">next-&gt;name = tmp_name;</span><br><span class="line"></span><br><span class="line">tmp_age = pre-&gt;age;</span><br><span class="line">pre-&gt;age = next-&gt;age;</span><br><span class="line">next-&gt;age = tmp_age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next = next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-普通的链表改进"><a href="#3-普通的链表改进" class="headerlink" title="3. 普通的链表改进"></a>3. 普通的链表改进</h2><p>主要是因为刚才的链表头部与链表项的操作不同一</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pList-&gt;next</span><br><span class="line">person-&gt;next</span><br></pre></td></tr></table></figure><h3 id="3-1-创建链表-1"><a href="#3-1-创建链表-1" class="headerlink" title="3.1 创建链表"></a>3.1 创建链表</h3><ul><li>创建两个结构体，一个表示链表的头部，一个表示链表项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *name; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">head</span>;</span>  <span class="comment">/* 这里不再使用指针，而是使用结构体来表示头部 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-初始化链表-1"><a href="#3-2-初始化链表-1" class="headerlink" title="3.2 初始化链表"></a>3.2 初始化链表</h3><ul><li>让链表的头部指向为NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *pList, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">pList-&gt;name = name;</span><br><span class="line">pList-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-插入链表-1"><a href="#3-3-插入链表-1" class="headerlink" title="3.3 插入链表"></a>3.3 插入链表</h3><ul><li><p>往链表的最后一项插入，最后一项指向为NULL</p><p><img src="/%E9%93%BE%E8%A1%A8/image-20231027182219023.png" alt="image-20231027182219023"></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AddItemToList</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *pList, <span class="keyword">struct</span> person *new_persion)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">last</span> =</span> &amp;pList-&gt;head;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 找出链表的最后一项 */</span></span><br><span class="line"><span class="keyword">while</span> (last-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">last = last-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* last-&gt;next == NULL */</span></span><br><span class="line">last-&gt;next = new_persion;</span><br><span class="line">new_persion-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-链表中删除项-1"><a href="#3-4-链表中删除项-1" class="headerlink" title="3.4 链表中删除项"></a>3.4 链表中删除项</h3><p>分为两种情况：</p><ul><li><p>删除的是第一项</p><p><img src="/%E9%93%BE%E8%A1%A8/image-20231027181925007.png" alt="image-20231027181925007"></p></li><li><p>删除的是其他项</p><p><img src="/%E9%93%BE%E8%A1%A8/image-20231027182349405.png" alt="image-20231027182349405"></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelItemFromList</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *pList, <span class="keyword">struct</span> person *person)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">pre</span> =</span> &amp;pList-&gt;head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 找到person */</span></span><br><span class="line"><span class="keyword">while</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;next != person)</span><br><span class="line">&#123;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 没找到 */</span></span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pre-&gt;next = person-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-链表排序-1"><a href="#3-5-链表排序-1" class="headerlink" title="3.5 链表排序"></a>3.5 链表排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SortList</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *pList)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">pre</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *tmp_name;</span><br><span class="line"><span class="type">int</span> tmp_age;</span><br><span class="line"></span><br><span class="line">pre = pList-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pre)</span><br><span class="line">&#123;</span><br><span class="line">next = pre-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pre-&gt;age &gt; next-&gt;age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 交换值 */</span></span><br><span class="line">tmp_name = pre-&gt;name;</span><br><span class="line">pre-&gt;name = next-&gt;name;</span><br><span class="line">next-&gt;name = tmp_name;</span><br><span class="line"></span><br><span class="line">tmp_age = pre-&gt;age;</span><br><span class="line">pre-&gt;age = next-&gt;age;</span><br><span class="line">next-&gt;age = tmp_age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next = next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-通用链表"><a href="#4-通用链表" class="headerlink" title="4. 通用链表"></a>4. 通用链表</h2><h2 id="5-双向链表"><a href="#5-双向链表" class="headerlink" title="5. 双向链表"></a>5. 双向链表</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码重定位</title>
      <link href="/2023/10/23/%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
      <url>/2023/10/23/%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="一、段的概念"><a href="#一、段的概念" class="headerlink" title="一、段的概念"></a>一、段的概念</h1><p>代码段、只读数据段、可读可写的数据段、BSS段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> g_Char = <span class="string">&#x27;A&#x27;</span>;           <span class="comment">// 可读可写，不能放在ROM上，应该放在RAM里</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_Char2 = <span class="string">&#x27;B&#x27;</span>;    <span class="comment">// 只读变量，可以放在ROM上</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>;   <span class="comment">// 初始值为0，干嘛浪费空间保存在ROM上？没必要</span></span><br><span class="line"><span class="type">int</span> g_B;       <span class="comment">// 没有初始化，干嘛浪费空间保存在ROM上？没必要</span></span><br></pre></td></tr></table></figure><p>所以，程序分为这几个段：</p><ul><li>代码段(RO-CODE)：就是程序本身，不会被修改</li><li>可读可写的数据段(RW-DATA)：有初始值的全局变量、静态变量，<strong>需要从ROM上复制到内存</strong></li><li>只读的数据段(RO-DATA)：可以放在ROM上，不需要复制到内存</li><li>BSS段或ZI段：<ul><li>初始值为0的全局变量或静态变量，没必要放在ROM上，使用之前清零就可以</li><li>未初始化的全局变量或静态变量，没必要放在ROM上，使用之前清零就可以</li></ul></li><li>局部变量：保存在栈中，运行时生成</li><li>堆：一块空闲空间，使用malloc函数来管理它，malloc函数可以自己写</li></ul><h1 id="二、重定位要做的事"><a href="#二、重定位要做的事" class="headerlink" title="二、重定位要做的事"></a>二、重定位要做的事</h1><h2 id="1-程序中含有什么？"><a href="#1-程序中含有什么？" class="headerlink" title="1. 程序中含有什么？"></a>1. 程序中含有什么？</h2><ul><li>代码段：如果它不在链接地址上，就需要重定位</li><li>只读数据段：如果它不在链接地址上，就需要重定位</li><li>可读可写的数据段：如果它不在链接地址上，就需要重定位</li><li>BSS段：不需要重定位，因为程序里根本不保存BSS段，使用前把BSS段对应的空间清零即可</li></ul><h2 id="2-谁来做重定位？"><a href="#2-谁来做重定位？" class="headerlink" title="2. 谁来做重定位？"></a>2. 谁来做重定位？</h2><ul><li>程序本身：它把自己复制到链接地址去</li><li>一开始，程序可能并不位于它的链接地址上，为什么它可以执行重定位的操作？<ul><li>因为重定位的代码是使用<strong>“位置无关码”</strong>写的</li></ul></li><li>什么叫位置无关码：这段代码扔在任何位置都可以运行，跟它所在的位置无关</li><li>怎么写出<strong>位置无关码：</strong><ul><li>跳转：使用相对跳转指令，不能使用绝对跳转指令<ul><li>只能使用branch指令(比如<code>bl main</code>)，不能给PC直接复制，比如<code>ldr pc, =main</code></li></ul></li><li>不要访问全局变量、静态变量</li><li>不使用字符串</li></ul></li></ul><h2 id="3-怎么做重定位和清除BSS段？"><a href="#3-怎么做重定位和清除BSS段？" class="headerlink" title="3. 怎么做重定位和清除BSS段？"></a>3. 怎么做重定位和清除BSS段？</h2><ul><li>核心：复制</li><li>复制的三要素：源、目的、长度<ul><li>怎么知道代码段&#x2F;数据段保存在哪？(加载地址)</li><li>怎么知道代码段&#x2F;数据段要被复制到哪？(链接地址)</li><li>怎么知道代码段&#x2F;数据段的长度？</li></ul></li><li>怎么知道BSS段的地址范围：起始地址、长度？</li><li>这一切<ul><li>在keil中使用散列文件(Scatter File)来描述</li><li>在GCC中使用链接脚本(Link Script)来描述</li></ul></li></ul><h2 id="4-加载地址和链接地址的区别"><a href="#4-加载地址和链接地址的区别" class="headerlink" title="4. 加载地址和链接地址的区别"></a>4. 加载地址和链接地址的区别</h2><p>程序运行时，<strong>应该</strong>位于它的链接地址处，因为：</p><ul><li>使用函数地址时用的是”函数的链接地址”，所以代码段<strong>应该</strong>位于链接地址处</li><li>去访问全局变量、静态变量时，用的是”变量的链接地址”，所以数据段<strong>应该</strong>位于链接地址处</li></ul><p>但是： 程序一开始时可能并没有位于它的”链接地址”：</p><ul><li>比如对于STM32F103，程序被烧录器烧写在Flash上，这个地址称为”加载地址”</li><li>比如对于IMX6ULL&#x2F;STM32MP157，片内ROM根据头部信息把程序读入内存，这个地址称为“加载地址”</li></ul><p>当<strong>加载地址 ！&#x3D; 链接地址</strong>时，就需要重定位。</p><h1 id="四、散列文件使用与分析"><a href="#四、散列文件使用与分析" class="headerlink" title="四、散列文件使用与分析"></a>四、散列文件使用与分析</h1><h2 id="1-重定位的实质-移动数据"><a href="#1-重定位的实质-移动数据" class="headerlink" title="1. 重定位的实质: 移动数据"></a>1. 重定位的实质: 移动数据</h2><p>把代码段、只读数据段、数据段，移动到它的链接地址处。<br>也就是<strong>复制</strong>！<br>数据复制的三要素：源、目的、长度。</p><ul><li><p>数据保存在哪里？加载地址</p></li><li><p>数据要复制到哪里？链接地址</p></li><li><p>长度</p></li></ul><p>这3要素怎么得到？<br>在keil中，使用散列文件来描述。<br>散列？分散排列？<br>是的，在STM32F103这类资源紧缺的单片机芯片中，</p><ul><li>代码段保存在Flash上，直接在Flash上运行(当然也可以重定位到内存里)</li><li>数据段保存在Flash上，使用前被复制到内存里</li></ul><h2 id="2-散列文件示例"><a href="#2-散列文件示例" class="headerlink" title="2. 散列文件示例"></a>2. 散列文件示例</h2><h3 id="2-1-示例代码"><a href="#2-1-示例代码" class="headerlink" title="2.1 示例代码"></a>2.1 示例代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; *************************************************************</span><br><span class="line">; *** Scatter-Loading Description File generated by uVision ***</span><br><span class="line">; *************************************************************</span><br><span class="line"></span><br><span class="line">LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08000000 0x00080000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x20000000 0x00010000  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-散列文件语法"><a href="#2-2-散列文件语法" class="headerlink" title="2.2 散列文件语法"></a>2.2 散列文件语法</h3><p>一个散列文件由一个或多个<code>Load region</code>组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">load_region_description ::=</span><br><span class="line">load_region_name (base_address | (&quot;+&quot; offset)) [attribute_list] [max_size]</span><br><span class="line">&quot;&#123;&quot;</span><br><span class="line">execution_region_description+</span><br><span class="line">&quot;&#125;</span><br></pre></td></tr></table></figure><p><code>Load region</code>中含有一个或多个<code>Execution region</code>，<br><code>Execution region</code>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execution_region_description ::=</span><br><span class="line">exec_region_name (base_address | &quot;+&quot; offset) [attribute_list] [max_size | length]</span><br><span class="line">&quot;&#123;&quot;</span><br><span class="line">input_section_description*</span><br><span class="line">&quot;&#125;</span><br></pre></td></tr></table></figure><p><code>Execution region</code>中含有一个或多个<code>Input section</code>，<br><code>Input section</code>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input_section_description ::=</span><br><span class="line">module_select_pattern [ &quot;(&quot; input_section_selector ( &quot;,&quot;</span><br><span class="line">input_section_selector )* &quot;)&quot; ]</span><br><span class="line">input_section_selector ::=</span><br><span class="line">&quot;+&quot; input_section_attr |</span><br><span class="line">input_section_pattern |</span><br><span class="line">input_section_type |</span><br><span class="line">input_symbol_pattern |</span><br><span class="line">section_properties</span><br></pre></td></tr></table></figure><h2 id="3-散列文件解析"><a href="#3-散列文件解析" class="headerlink" title="3. 散列文件解析"></a>3. 散列文件解析</h2><p><img src="/2023/10/23/%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/001_sct_example.png"></p><p><img src="/2023/10/23/%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/image-20231016192932240.png" alt="image-20231016192932240"></p><p>*.o ：所有objects文件</p><p>*：所有objects文件和库，在一个散列文件中只能使用一个*</p><p>.ANY：等同于*，优先级比*低；在一个散列文件的多个可执行域中可以有多个<code>.ANY</code></p><h2 id="4-怎么获得region的信息"><a href="#4-怎么获得region的信息" class="headerlink" title="4. 怎么获得region的信息"></a>4. 怎么获得region的信息</h2><h3 id="4-1-可执行域的信息"><a href="#4-1-可执行域的信息" class="headerlink" title="4.1 可执行域的信息"></a>4.1 可执行域的信息</h3><p><img src="/2023/10/23/%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/002_execution_region_symbol.png"></p><h3 id="4-2-加载域的信息"><a href="#4-2-加载域的信息" class="headerlink" title="4.2 加载域的信息"></a>4.2 加载域的信息</h3><p><img src="/2023/10/23/%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/003_load_region_symbol.png"></p><h3 id="4-3-汇编代码里怎么使用这些信息（数据段重定位）"><a href="#4-3-汇编代码里怎么使用这些信息（数据段重定位）" class="headerlink" title="4.3 汇编代码里怎么使用这些信息（数据段重定位）"></a>4.3 汇编代码里怎么使用这些信息（数据段重定位）</h3><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IMPORT |Image$$RW_IRAM1$$Base|</span><br><span class="line">IMPORT |Image$$RW_IRAM1$$Length|</span><br><span class="line">IMPORT |Load$$RW_IRAM1$$Base|</span><br><span class="line"></span><br><span class="line">LDR R0, = |Image$$RW_IRAM1$$Base|    ; DEST</span><br><span class="line">LDR R1, = |Load$$RW_IRAM1$$Base|     ; SORUCE</span><br><span class="line">LDR R2, = |Image$$RW_IRAM1$$Length|  ; LENGTH</span><br></pre></td></tr></table></figure><h3 id="4-4-C语言里怎么使用这些信息"><a href="#4-4-C语言里怎么使用这些信息" class="headerlink" title="4.4 C语言里怎么使用这些信息"></a>4.4 C语言里怎么使用这些信息</h3><h4 id="4-4-1-方法1"><a href="#4-4-1-方法1" class="headerlink" title="4.4.1 方法1"></a>4.4.1 方法1</h4><p>声明为外部变量。<br>注意：使用时<strong>需要</strong>使用取址符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern int Image$$RW_IRAM1$$Base;</span><br><span class="line">extern int Load$$RW_IRAM1$$Base;</span><br><span class="line">extern int Image$$RW_IRAM1$$Length;</span><br><span class="line"></span><br><span class="line">memcpy(&amp;Image$$RW_IRAM1$$Base, &amp;Image$$RW_IRAM1$$Length, &amp;Load$$RW_IRAM1$$Base);</span><br></pre></td></tr></table></figure><h4 id="4-4-2-方法2"><a href="#4-4-2-方法2" class="headerlink" title="4.4.2 方法2"></a>4.4.2 方法2</h4><p>声明为外部数组。<br>注意：使用时<strong>不需要</strong>使用取址符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern char Image$$RW_IRAM1$$Base[];</span><br><span class="line">extern char Load$$RW_IRAM1$$Base[];</span><br><span class="line">extern int Image$$RW_IRAM1$$Length;</span><br><span class="line"></span><br><span class="line">memcpy(Image$$RW_IRAM1$$Base, Image$$RW_IRAM1$$Length, &amp;Load$$RW_IRAM1$$Base);</span><br></pre></td></tr></table></figure><h1 id="五、清除BSS段-ZI段"><a href="#五、清除BSS段-ZI段" class="headerlink" title="五、清除BSS段(ZI段)"></a>五、清除BSS段(ZI段)</h1><h2 id="1-C语言中的BSS段"><a href="#1-C语言中的BSS段" class="headerlink" title="1. C语言中的BSS段"></a>1. C语言中的BSS段</h2><p>程序里的全局变量，如果它的初始值为0，或者没有设置初始值，这些变量被放在BSS段里，也叫ZI段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> g_Char = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_Char2 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>;  <span class="comment">// 放在BSS段</span></span><br><span class="line"><span class="type">int</span> g_B;      <span class="comment">// 放在BSS段</span></span><br></pre></td></tr></table></figure><p>BSS段并不会放入bin文件中，否则也太浪费空间了。<br>在使用BSS段里的变量之前，把BSS段所占据的内存清零就可以了。</p><ul><li><p>注意：对于keil来说，一个本该放到BSS段的变量，如果它所占据的空间小于等于8字节自己，keil仍然会把它放在data段里。只有当它所占据的空间大于8字节时，才会放到BSS段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g_A[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;   <span class="comment">// 放在BSS段</span></span><br><span class="line"><span class="type">char</span> g_B[<span class="number">9</span>];           <span class="comment">// 放在BSS段</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_A[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;   <span class="comment">// 放在data段</span></span><br><span class="line"><span class="type">char</span> g_B[<span class="number">8</span>];           <span class="comment">// 放在data段</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-清除BSS段"><a href="#2-清除BSS段" class="headerlink" title="2. 清除BSS段"></a>2. 清除BSS段</h2><h3 id="2-1-BSS段在哪？多大？"><a href="#2-1-BSS段在哪？多大？" class="headerlink" title="2.1 BSS段在哪？多大？"></a>2.1 BSS段在哪？多大？</h3><p>在散列文件中，BSS段(ZI段)在可执行域<code>RW_IRAM1</code>中描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08000000 0x00080000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x20000000 0x00010000  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BSS段(ZI段)的链接地址(基地址)、长度，使用下面的符号获得：<br><img src="/2023/10/23/%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/004_bss_section_symbol.png"></p><h3 id="2-2-怎么清除BSS段"><a href="#2-2-怎么清除BSS段" class="headerlink" title="2.2  怎么清除BSS段"></a>2.2  怎么清除BSS段</h3><h4 id="2-2-1-汇编码"><a href="#2-2-1-汇编码" class="headerlink" title="2.2.1 汇编码"></a>2.2.1 汇编码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IMPORT |Image$$RW_IRAM1$$ZI$$Base|</span><br><span class="line">IMPORT |Image$$RW_IRAM1$$ZI$$Length|</span><br><span class="line"></span><br><span class="line">LDR R0, = |Image$$RW_IRAM1$$ZI$$Base|       ; DEST</span><br><span class="line">LDR R1, = |Image$$RW_IRAM1$$ZI$$Length|     ; Length</span><br><span class="line">BL memset</span><br></pre></td></tr></table></figure><h4 id="2-2-2-C语言"><a href="#2-2-2-C语言" class="headerlink" title="2.2.2 C语言"></a>2.2.2 C语言</h4><ul><li>方法1<br>声明为外部变量，使用时<strong>需要</strong>使用取址符：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> Image$$RW_IRAM1$$ZI$$Base;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> Image$$RW_IRAM1$$ZI$$Length;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;Image$$RW_IRAM1$$ZI$$Base, <span class="number">0</span>, &amp;Image$$RW_IRAM1$$ZI$$Length);</span><br></pre></td></tr></table></figure><ul><li>方法2<br>声明为外部数组，使用时<strong>不需要</strong>使用取址符：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> Image$$RW_IRAM1$$ZI$$Base[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> Image$$RW_IRAM1$$ZI$$Length[];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(Image$$RW_IRAM1$$ZI$$Base[], <span class="number">0</span>, Image$$RW_IRAM1$$ZI$$Length);</span><br></pre></td></tr></table></figure><h1 id="六、代码段重定位"><a href="#六、代码段重定位" class="headerlink" title="六、代码段重定位"></a>六、代码段重定位</h1><h2 id="1-加载地址等于链接地址"><a href="#1-加载地址等于链接地址" class="headerlink" title="1. 加载地址等于链接地址"></a>1. 加载地址等于链接地址</h2><p>在默认散列文件中，代码段的<code>load address = execution address</code>，<br>也就是加载地址和执行地址(链接地址)一致，所以无需重定位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08000000 0x00080000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x20000000 0x00010000  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-加载地址不等于链接地址"><a href="#2-加载地址不等于链接地址" class="headerlink" title="2.加载地址不等于链接地址"></a>2.加载地址不等于链接地址</h2><p>有时候，我们需要把程序复制到内存里运行，比如：</p><ul><li>想让程序执行得更快：需要把代码段复制到内存里</li><li>程序很大，保存在片外SPI Flash中，SPI Flash上的代码无法直接执行，需要复制到内存里</li></ul><p>这时候，需要修改散列文件，把代码段的可执行域放在内存里。<br>那么程序运行时，需要尽快把代码段重定位到内存。<br>散列文件示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x20000000   &#123;  ; load address != execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 +0   &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>改完之后出现报错（6个error）：</p><p>1.删除*(InRoot$$Sections)</p><p>2.将启动文件中的main改成mymain</p><p>不能打印：</p><p>将最开始执行的第二条指令改成 0x08000009</p></blockquote><p>上面的散列文件中：</p><ul><li>可执行域ER_IROM1<ul><li>加载地址为0x08000000，可执行地址为0x20000000，两者不相等</li><li>板子上电后，从0x08000000处开始运行，需要尽快把代码段复制到0x20000000</li></ul></li><li>可执行域RW_IRAM1<ul><li>加载地址：紧跟着ER_IROM1的加载地址</li><li>可执行地址：紧跟着ER_IROM1的可执行地址</li><li>需要尽快把数据段复制到可执行地址处</li></ul></li></ul><p>数据段的重定位我们做过实验，<br>如果代码段不重定位的话，会发生什么事？</p><h2 id="3-代码段不重定位的后果"><a href="#3-代码段不重定位的后果" class="headerlink" title="3. 代码段不重定位的后果"></a>3. 代码段不重定位的后果</h2><p>不能使用链接地址来调用函数</p><ul><li><p>汇编中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr  pc, =main   ; 这样调用函数时，用到main函数的链接地址，如果代码段没有重定位，则跳转失败</span><br></pre></td></tr></table></figure></li><li><p>C语言中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*funcptr)(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">int</span> val);</span><br><span class="line">funcptr = put_s_hex;</span><br><span class="line">funcptr(<span class="string">&quot;hello, test function ptr&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-代码段重定位"><a href="#4-代码段重定位" class="headerlink" title="4. 代码段重定位"></a>4. 代码段重定位</h2><h3 id="4-1-代码段在哪？多大？"><a href="#4-1-代码段在哪？多大？" class="headerlink" title="4.1 代码段在哪？多大？"></a>4.1 代码段在哪？多大？</h3><p>在散列文件中，代码段在可执行域<code>ER_IROM1</code>中描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08000000 0x00080000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x20000000 0x00010000  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码段的链接地址(基地址)、长度，使用下面的符号获得：</p><p>005_text_section_execution_symbol.png)</p><p>代码段的加载地址，使用下面的符号获得：</p><p><img src="/2023/10/23/%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/006_text_section_load_symbol.png"></p><h3 id="4-2-怎么重定位"><a href="#4-2-怎么重定位" class="headerlink" title="4.2 怎么重定位"></a>4.2 怎么重定位</h3><h4 id="4-2-1-汇编代码"><a href="#4-2-1-汇编代码" class="headerlink" title="4.2.1 汇编代码"></a>4.2.1 汇编代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IMPORT |Image$$ER_IROM1$$Base|</span><br><span class="line">IMPORT |Image$$ER_IROM1$$Length|</span><br><span class="line">IMPORT |Load$$ER_IROM1$$Base|</span><br><span class="line"></span><br><span class="line">LDR R0, = |Image$$ER_IROM1$$Base|    ; DEST</span><br><span class="line">LDR R1, = |Load$$ER_IROM1$$Base|     ; SORUCE</span><br><span class="line">LDR R2, = |Image$$ER_IROM1$$Length|  ; LENGTH</span><br><span class="line">BL memcpy</span><br></pre></td></tr></table></figure><h4 id="4-2-2-C语言代码"><a href="#4-2-2-C语言代码" class="headerlink" title="4.2.2 C语言代码"></a>4.2.2 C语言代码</h4><ul><li>方法1</li></ul><p>声明为外部变量，使用时<strong>需要</strong>使用取址符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern int Image$$ER_IROM1$$Base;</span><br><span class="line">extern int Load$$ER_IROM1$$Base;</span><br><span class="line">extern int Image$$ER_IROM1$$Length;</span><br><span class="line"></span><br><span class="line">memcpy(&amp;Image$$ER_IROM1$$Base, &amp;Image$$ER_IROM1$$Length, &amp;Load$$ER_IROM1$$Base);</span><br></pre></td></tr></table></figure><ul><li>方法2</li></ul><p>声明为外部数组，使用时<strong>不需要</strong>使用取址符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern char Image$$ER_IROM1$$Base[];</span><br><span class="line">extern char Load$$ER_IROM1$$Base[];</span><br><span class="line">extern int Image$$ER_IROM1$$Length;</span><br><span class="line"></span><br><span class="line">memcpy(Image$$ER_IROM1$$Base, Image$$ER_IROM1$$Length, &amp;Load$$ER_IROM1$$Base);</span><br></pre></td></tr></table></figure><h2 id="5-为什么重定位之前的代码也可以正常运行？"><a href="#5-为什么重定位之前的代码也可以正常运行？" class="headerlink" title="5. 为什么重定位之前的代码也可以正常运行？"></a>5. 为什么重定位之前的代码也可以正常运行？</h2><p>因为重定位之前的代码是使用<strong>位置无关码</strong>写的：</p><ul><li><p>只使用相对跳转指令：B、BL</p></li><li><p>不只用绝对跳转指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, =main</span><br><span class="line">BLX R0</span><br></pre></td></tr></table></figure></li><li><p>不访问全局变量、静态变量、字符串、数组</p></li><li><p>重定位完后，使用绝对跳转指令跳转到XXX函数的链接地址去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BL main         ; bl相对跳转，程序仍在Flash上运行</span><br><span class="line"></span><br><span class="line">LDR R0, =main   ; 绝对跳转，跳到链接地址去，就是跳去内存里执行</span><br><span class="line">BLX R0</span><br></pre></td></tr></table></figure></li></ul><h1 id="七、重定位的纯C函数实现"><a href="#七、重定位的纯C函数实现" class="headerlink" title="七、重定位的纯C函数实现"></a>七、重定位的纯C函数实现</h1><h2 id="1-难点"><a href="#1-难点" class="headerlink" title="1. 难点"></a>1. 难点</h2><p>难点在于，怎么得到各个域的加载地址、链接地址、长度。</p><ul><li>方法1</li></ul><p>声明为外部变量，使用时<strong>需要</strong>使用取址符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern int Image$$ER_IROM1$$Base;</span><br><span class="line">extern int Load$$ER_IROM1$$Base;</span><br><span class="line">extern int Image$$ER_IROM1$$Length;</span><br><span class="line"></span><br><span class="line">memcpy(&amp;Image$$ER_IROM1$$Base, &amp;Image$$ER_IROM1$$Length, &amp;Load$$ER_IROM1$$Base);</span><br></pre></td></tr></table></figure><ul><li>方法2</li></ul><p>声明为外部数组，使用时<strong>不需要</strong>使用取址符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern char Image$$ER_IROM1$$Base[];</span><br><span class="line">extern char Load$$ER_IROM1$$Base[];</span><br><span class="line">extern int Image$$ER_IROM1$$Length;</span><br><span class="line"></span><br><span class="line">memcpy(Image$$ER_IROM1$$Base, Image$$ER_IROM1$$Length, &amp;Load$$ER_IROM1$$Base);</span><br></pre></td></tr></table></figure><h2 id="2-怎么理解上述代码"><a href="#2-怎么理解上述代码" class="headerlink" title="2. 怎么理解上述代码"></a>2. 怎么理解上述代码</h2><p> 对于这样的C变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g_a;</span><br></pre></td></tr></table></figure><p>编译的时候会有一个符号表(symbol table)，如下：</p><table><thead><tr><th>Name</th><th>Address</th></tr></thead><tbody><tr><td>g_a</td><td>xxxxxxxx</td></tr></tbody></table><p>对于散列文件中的各类Symbol，有2中声明方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> Image$$ER_IROM1$$Base;     <span class="comment">// 声明为一般变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> Image$$ER_IROM1$$Base[];  <span class="comment">// 声明为数组</span></span><br></pre></td></tr></table></figure><p>不管是哪种方式，它们都会保存在符号表里，比如：</p><table><thead><tr><th>Name</th><th>Address</th></tr></thead><tbody><tr><td>g_a</td><td>xxxxxxxx</td></tr><tr><td>Image$$ER_IROM1$$Base</td><td>yyyyyyyy</td></tr></tbody></table><ul><li>对于<code>int g_a</code>变量<ul><li>使用<code>&amp;g_a</code>得到符号表里的地址。</li></ul></li><li>对于<code>extern int Image$$ER_IROM1$$Base</code>变量<ul><li>要得到符号表中的地址，也是使用<code>&amp;Image$$ER_IROM1$$Base</code>。</li></ul></li><li>对于<code>extern char Image$$ER_IROM1$$Base[]</code>变量<ul><li>要得到符号表中的地址，直接使用<code>Image$$ER_IROM1$$Base</code>，不需要加<code>&amp;</code></li><li>为什么？mage$$ER_IROM1$$Base本身就表示地址啊</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> 架构 </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四轴飞行器</title>
      <link href="/2023/10/21/%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8/"/>
      <url>/2023/10/21/%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32启动文件解析</title>
      <link href="/2023/10/21/STM32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/10/21/STM32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM体系架构</title>
      <link href="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
      <url>/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下内容部分摘录自《ARM Cortex-M3 权威指南》、《ARM Cortex-M3与Cortex-M4权威指南》、《ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition》、韦东山老师的课程《深入理解ARM架构》，仅用于个人交流与学习，如涉及侵权请联系站长删除！</p></blockquote><h1 id="第一章-ARM架构版本及处理器系列介绍"><a href="#第一章-ARM架构版本及处理器系列介绍" class="headerlink" title="第一章 ARM架构版本及处理器系列介绍"></a>第一章 ARM架构版本及处理器系列介绍</h1><h2 id="1-ARM背景"><a href="#1-ARM背景" class="headerlink" title="1.ARM背景"></a>1.ARM背景</h2><p>ARM在1990年成立，当初的名字是“Advanced RISC Machines Ltd.,”，当时它是三家公司的合资——它们分别是苹果电脑，Acorn电脑公司，以及VLSI技术（公司）。</p><p>ARM的版本分为两类，一个是内核版本，一个处理器版本。</p><ul><li>内核版本也就是ARM架构，如ARMv1、ARMv2、ARMv3、ARMv4、ARMv5、ARMv6、ARMv7、ARMv8等。</li><li>处理器版本也就是ARM处理器，如ARM1、ARM9、ARM11、ARM Cortex-A（A7、A9、A15），ARM Cortex-M（M1、M3、M4）、ARM Cortex-R，这个也是我们通常意义上所指的ARM版本。</li></ul><h2 id="2-ARM架构与处理器的关系"><a href="#2-ARM架构与处理器的关系" class="headerlink" title="2.ARM架构与处理器的关系"></a>2.ARM架构与处理器的关系</h2><p>基于不同的ARM架构可以设计出不同特点的ARM处理器。比如基于ARMv3架构设计出的处理器ARM6、ARM7，这两款处理器适用于不同的场景，硬件可能不同，但是架构指令集是一样的。</p><p>举个例子，比如说盖房子，早期因为发展落后，盖的都是平房，这就是一种架构(ARMv5)，然后这种平房架构你可以设计出一款三室一厅的款式， 这叫ARM7处理器。 然后其他人(芯片设计公司)想盖房子的就买你这个款式去盖，接着过一段时间，有人觉得光三室一厅的不好， 我还想每个房间有独立卫! 于是，ARM就满足你们的要求，出个独卫的款式(ARM9)。</p><p>即ARMv5等是指令集的架构，ARM7&#x2F;9等是基于架构设计出的内核处理器。ARM的架构都是基于RISC指令集而设计的，内核处理器是实现这一指令集的硬件架构的基础。</p><h2 id="3-ARM版本"><a href="#3-ARM版本" class="headerlink" title="3.ARM版本"></a>3.ARM版本</h2><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/a.png"></p><p>最近的几年，基于从ARMv6开始的新设计理念，ARM进一步扩展了它的CPU设计，成果 就是ARMv7架构的闪亮登场。在这个版本中，内核架构首次从单一款式变成3种款式。 </p><ul><li><p>款式A：设计用于高性能的“开放应用平台”——越来越接近电脑了 </p></li><li><p>款式R：用于高端的嵌入式系统，尤其是那些带有实时要求的——又要快又要实时。 </p></li><li><p>款式M：用于深度嵌入的，单片机风格的系统中——本文章主要讲解的知识。</p></li></ul><p>让我们再进距离地考察这3种款式： </p><ul><li>款式A（ARMv7‐A）：需要运行复杂应用程序的“应用处理器” 。支持大型嵌入式操作系统，比如Symbian（诺基亚智能手机用），Linux，以及微软 的Windows CE和智能手机操作系统Windows Mobile。这些应用需要劲爆的处理性能，并 且需要硬件MMU实现的完整而强大的虚拟内存机制，还基本上会配有Java支持，有时 还要求一个安全程序执行环境。典型的产品包括高端手机和手持仪器，电子钱包以及金融事务处理机。 </li><li>款式R（ARMv7‐R）：硬实时且高性能的处理器。标的是高端实时市场。那些高级的玩意，像高档轿车的组件，大型发电机控制器，机器手臂控制器等，它们使用的处理 器不但要很好很强大，还要极其可靠，对事件的反应也要极其敏捷。 </li><li>款式M（ARMv7‐M）：认准了旧世代单片机的应用而量身定制。在这些应用中，尤其是 对于实时控制系统，低成本、低功耗、极速中断反应以及高处理效率，都是至关重要的。  Cortex系列是v7架构的第一次亮相，其中Cortex‐M3就是按款式M设计的。</li></ul><h1 id="第二章-ARM基础知识"><a href="#第二章-ARM基础知识" class="headerlink" title="第二章 ARM基础知识"></a>第二章 ARM基础知识</h1><h2 id="1-哈弗架构与冯诺伊曼架构"><a href="#1-哈弗架构与冯诺伊曼架构" class="headerlink" title="1.哈弗架构与冯诺伊曼架构"></a>1.<strong>哈弗架构与冯诺伊曼架构</strong></h2><p>CPU架构可以分为哈弗架构与冯诺伊曼架构，如下图所示。</p><ul><li><p><strong>哈弗架构</strong>中指令与数据分开存放，CPU可以同时读入指令、读写数据。</p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/b.png"></p></li><li><p><strong>冯诺伊曼架构</strong>中指令、数据混合存放，CPU依次读取指令、读写数据，不可同时操作指令和数据。</p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/c.png"></p></li></ul><blockquote><p>Cortex‐M3采用了哈佛结构，拥有独立的指令总线和数据总线，可以让取指与数据访问 并行不悖。</p></blockquote><h2 id="2-RISC与CISC"><a href="#2-RISC与CISC" class="headerlink" title="2. RISC与CISC"></a>2. RISC与CISC</h2><ul><li><strong>复杂指令集CISC</strong>:   以Intel、AMD的X86 CPU为代表，CISC也是要通过操作内存、寄存器、运算器来完成复杂指令的。它在实现时，是将复杂指令转换成了一个微程序，微程序在制造CPU时就已存储于微服务存储器。一个微程序包含若干条微指令（也称微码），执行复杂指令时，实际上是在执行一个微程序。这也带来两种指令集的一个差别，微程序的执行是不可被打断的，而RISC指令之间可以被打断，所以理论上RISC可更快响应中断。特点：</li><li><strong>精简指令集RISC</strong>：以ARM、IBM Power为代表，设计初衷针对CISC CPU复杂的弊端，选择一些可以在单个CPU周期完成的指令，以降低CPU的复杂度，将复杂性交给编译器</li></ul><blockquote><p><strong>ARM公司的芯片都使用RISC指令集，对内存只有load&#x2F;store操作，数据的处理是在CPU寄存器上进行。</strong></p></blockquote><ul><li>二者的比较：<ul><li>CISC的指令能力强，单多数指令使用率低却增加了CPU的复杂度，指令是可变长格式；</li><li>RISC的指令大部分为单周期指令，指令长度固定，操作寄存器，对于内存只有Load&#x2F;Store操作</li><li>CISC支持多种寻址方式；RISC支持的寻址方式</li><li>CISC通过微程序控制技术实现；</li><li>RISC增加了通用寄存器，硬布线逻辑控制为主，采用流水线</li><li>CISC的研制周期长</li><li>RISC优化编译，有效支持高级语言</li></ul></li></ul><h1 id="第三章-ARM-寄存器"><a href="#第三章-ARM-寄存器" class="headerlink" title="第三章 ARM 寄存器"></a>第三章 ARM 寄存器</h1><p>这里以Cortex‐M3 &#x2F;Cortex‐M4&#x2F;Cortex‐A7处理器为例，他们拥有 R0‐R15 的寄存器组。其中 R13 作为堆栈指针 SP。SP 有两个，但在同一 时刻只能有一个可以看到，这也就是所谓的“banked”寄存器。</p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20231021162714042.png" alt="image-20231021162714042"></p><ul><li>R0-R12：通用寄存器 ，R0‐R12 都是 32 位通用寄存器，用于数据操作。但是注意：绝大多数 16 位 Thumb 指令只能访 问 R0‐R7，而 32 位 Thumb‐2 指令可以访问所有寄存器。</li><li>Banked R13: 两个堆栈指针 <ul><li>主堆栈指针（MSP）：复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程（包 括中断服务例程） </li><li>进程堆栈指针（PSP）：由用户的应用程序代码使用。</li></ul></li><li>R14：连接寄存器，当呼叫一个子程序时，由 R14 存储返回地址 </li><li>R15：程序计数寄存器 ，指向当前的程序地址。如果修改它的值，就能改变程序的执行流</li><li>特殊功能寄存器 <ul><li>程序状态字寄存器组（PSRs）  </li><li>中断屏蔽寄存器组（PRIMASK, FAULTMASK, BASEPRI）  </li><li>控制寄存器（CONTROL）</li></ul></li></ul><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20231021163136833.png" alt="image-20231021163136833"></p><p>功能如下表：</p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20231021163233661.png" alt="image-20231021163233661"></p><h1 id="第四章-ARM汇编"><a href="#第四章-ARM汇编" class="headerlink" title="第四章 ARM汇编"></a>第四章 ARM汇编</h1><h2 id="1-ARM汇编概述"><a href="#1-ARM汇编概述" class="headerlink" title="1.ARM汇编概述"></a>1.ARM汇编概述</h2><p>①最初，ARM公司发布两类指令集：</p><ul><li><p><strong>Thumb指令集：</strong>这是16位的，每条指令占据16位，节省空间</p></li><li><p><strong>ARM指令集：</strong>这是32位的，每条指令占据32位，高效，但是太占空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R1, #1;Thumb指令：len(mov) + len(r1) + len(立即数) = 16bit</span><br><span class="line">MOV R1, #1;ARM指令：len(mov) + len(r1) + len(立即数) = 32bit</span><br></pre></td></tr></table></figure></li></ul><p>要节省空间时用Thumb指令，要效率时用ARM指令</p><p>②一个CPU既可以运行Thumb指令，也能运行ARM指令。怎么区分当前指令是Thumb还是ARM指令呢？</p><p>​程序状态寄存器中有一位，名为“T”，它等于1时表示当前运行的是Thumb指令。</p><p>③假设函数A是使用Thumb指令写的，函数B是使用ARM指令写的，怎么调用A&#x2F;B？</p><p>​我们可以往PC寄存器里写入函数A或B的地址，就可以调用A或B，</p><p>④但是怎么让CPU在执行A函数是进入Thumb状态，在执行B函数时进入ARM状态？</p><p>​做个手脚：</p><p>​调用函数A时，让PC寄存器的BIT0等于1，即：PC&#x3D;函数A地址+(1&lt;&lt;0)；</p><p>​调用函数B时，让PC寄存器的BIT0等于0:，即：PC&#x3D;函数B地址</p><p>⑤但是这样做太麻烦，于是引入Thumb2指令集</p><ul><li><strong>Thumb2指令集：</strong>它支持16位指令、32位指令混合编程。</li></ul><h2 id="2-区分指令集"><a href="#2-区分指令集" class="headerlink" title="2.区分指令集"></a>2.区分指令集</h2><p>ARM公司推出了： Unified Assembly Language UAL，统一汇编语言，我们不需要去区分这些指令集</p><p>我们只需要在程序前面用CODE32&#x2F;CODE16&#x2F;THUMB表示指令集:ARM&#x2F;Thumb&#x2F;Thumb2</p><h2 id="3-汇编指令格式"><a href="#3-汇编指令格式" class="headerlink" title="3.汇编指令格式"></a>3.汇编指令格式</h2><blockquote><p>参考《DEN0013D_cortex_a_series_PG.pdf》P70</p><p>《ARM Cortex-M3与Cortex-M4权威指南.pdf》第5章汇编指令可以分为几大类：数据处理、内存访问、跳转、饱和运算、其他指令</p></blockquote><p>以“数据处理”指令为例，UAL汇编格式为：</p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20231021175310394.png" alt="image-20231021175310394"></p><ul><li><p>Operation表示各类汇编指令，比如ADD、MOV；</p></li><li><p>cond表示conditon，即该指令执行的条件；</p></li><li><p>S表示该指令执行后，会去修改程序状态寄存器；</p></li><li><p>Rd为目的寄存器，用来存储运算的结果；</p></li><li><p>Rn、Operand2是两个源操作数</p></li></ul><h2 id="4-常用汇编指令"><a href="#4-常用汇编指令" class="headerlink" title="4.常用汇编指令"></a>4.常用汇编指令</h2><h3 id="1-内存访问指令"><a href="#1-内存访问指令" class="headerlink" title="1.内存访问指令"></a>1.内存访问指令</h3><p>加载指令LDR：Load Register</p><p>读多个寄存器</p><p>存储指令STR：Store Register</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, =0X20000</span><br><span class="line">LDR R1, =0X1234</span><br><span class="line">STR R1,[R0]      ;将R1里面的值写入到R0指向的地址里</span><br><span class="line"></span><br><span class="line">LDMIA R0!, &#123; R4-R11 &#125;;lrmia: ldr mutiple inc after</span><br><span class="line">;ldr r0 [r4]   r0 = r0 + 4</span><br><span class="line">;ldr r0 [r5]   r0 = r0 + 4</span><br></pre></td></tr></table></figure><h3 id="2-数据处理指令"><a href="#2-数据处理指令" class="headerlink" title="2.数据处理指令"></a>2.数据处理指令</h3><p>加法指令ADD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV R2,#1</span><br><span class="line">MOV R3,#2</span><br><span class="line">ADD R1,R2,R3;R1 = R2 + R3</span><br></pre></td></tr></table></figure><p>减法指令SUB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV R2,#1</span><br><span class="line">MOV R3,#2</span><br><span class="line">ADD R1,R3,R2;R1 = R3 - R2</span><br></pre></td></tr></table></figure><p>位操作指令AND&#x2F;BIC&#x2F;ORR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, =0XFFFFFFFF</span><br><span class="line">AND R0,R0,#(1&lt;&lt;4);与：只保留第四位</span><br><span class="line">LDR R0, =0XFFFFFFFF</span><br><span class="line">BIC R0,R0,#(1&lt;&lt;4);位清除：清除第四位</span><br><span class="line">LDR R0, =0</span><br><span class="line">ORR R0,#(1&lt;&lt;2|1&lt;&lt;3);或：设置第2、3位为1</span><br></pre></td></tr></table></figure><p>比较指令CMP&#x2F;TST</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, =0X12</span><br><span class="line">LDR R1, =0X12</span><br><span class="line">CMP R0,R1;比较R0-R1里面的结果，结果存放在程序装载寄存器</span><br><span class="line">MOVEQ R0, #2；如果相等，执行这条指令，R0=2</span><br><span class="line"></span><br><span class="line">TST R0,R1;测试R0&amp;R1的结果</span><br></pre></td></tr></table></figure><h3 id="3-跳转指令"><a href="#3-跳转指令" class="headerlink" title="3.跳转指令"></a>3.跳转指令</h3><ul><li><p>B：Branch，跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B Delay</span><br><span class="line">Delay</span><br><span class="line">MOV R0, #5</span><br><span class="line">Loop</span><br><span class="line">SUBS R0,R0,#1</span><br><span class="line">BNE Loop;不等于0就一直循环</span><br><span class="line">MOV PC, LR;结束，将LR值返回给PC</span><br></pre></td></tr></table></figure></li><li><p>BL：Branch with Link，跳转前先把返回地址保持在LR寄存器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BL Delay</span><br><span class="line">MOV R1, #1;执行完之后会直接跳转到这条指令 PC=LR+4</span><br><span class="line">Delay</span><br><span class="line">MOV R0, #5</span><br><span class="line">Loop</span><br><span class="line">SUBS R0,R0,#1</span><br><span class="line">BNE Loop;不等于0就一直循环</span><br><span class="line">MOV PC, LR;结束，将LR值返回给PC</span><br></pre></td></tr></table></figure></li><li><p>BX：Branch and eXchange，根据跳转地址的BIT0切换为ARM或Thumb状态(0：ARM状态，1：Thumb状态)</p></li><li><p>BLX：Branch with Link and eXchange ，根据跳转地址的BIT0切换为ARM或Thumb状态(0：ARM状态，1：Thumb状态)#</p></li></ul><h3 id="4-CPU操作指令"><a href="#4-CPU操作指令" class="headerlink" title="4.CPU操作指令"></a>4.CPU操作指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;开启CPU接收中断</span><br><span class="line">cpsie i</span><br><span class="line">cpsie f</span><br><span class="line"></span><br><span class="line">;存储器屏蔽指令:确保前面的指令和数据都处理完成</span><br><span class="line">dsb;数据同步屏蔽</span><br><span class="line">isb;指令同步屏蔽</span><br></pre></td></tr></table></figure><h1 id="五、异常与中断"><a href="#五、异常与中断" class="headerlink" title="五、异常与中断"></a>五、异常与中断</h1><h2 id="1-异常与中断的概念引入与处理流程"><a href="#1-异常与中断的概念引入与处理流程" class="headerlink" title="1.异常与中断的概念引入与处理流程"></a>1.异常与中断的概念引入与处理流程</h2><h3 id="1-1-使用生活实例引入中断"><a href="#1-1-使用生活实例引入中断" class="headerlink" title="1.1 使用生活实例引入中断"></a>1.1 使用生活实例引入中断</h3><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/001_mother_son.png"></p><p>假设有个大房间里面有小房间，婴儿正在睡觉，他的妈妈在外面看书。<br>问：这个母亲怎么才能知道这个小孩醒？</p><ol><li>过一会打开一次房门，看婴儿是否睡醒，然后接着看书</li><li>一直等到婴儿发出声音以后再过去查看，期间都在读书</li></ol><p>第一种方法叫做<strong>查询方式</strong>：</p><ul><li>优点：简单 </li><li>缺点： 累</li></ul><p>如何写程序？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span> read <span class="title function_">book</span><span class="params">(读书)</span></span><br><span class="line">2 open <span class="title function_">door</span><span class="params">(开门)</span></span><br><span class="line">  <span class="title function_">if</span><span class="params">(小孩还在睡)</span></span><br><span class="line"> <span class="title function_">return</span><span class="params">(继续读书)</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line"> 照顾小孩</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法叫<strong>中断方式</strong>：</p><ul><li>优点：不累</li><li>缺点：复杂</li></ul><p>如何写程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">read book</span><br><span class="line">&#125;</span><br><span class="line">中断服务程序() <span class="comment">//核心问题：如何被调用？</span></span><br><span class="line">&#123;</span><br><span class="line">处理照顾小孩</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-母亲如何处理中断"><a href="#1-2-母亲如何处理中断" class="headerlink" title="1.2 母亲如何处理中断"></a>1.2 母亲如何处理中断</h3><p>我们还是看看母亲被小孩哭声打断如何照顾小孩？</p><p>母亲的处理过程</p><ul><li>平时看书</li><li>发生了各种声音，如何处理这些声音<ul><li>有远处的猫叫（听而不闻，忽略）</li><li>门铃声有快递（开门收快递）</li><li>小孩哭声（打开房门，照顾小孩）</li></ul></li><li>母亲的处理<ul><li>只会处理门铃声和小孩哭声<ul><li>先在书中放入书签，合上书(保存现场)</li><li>去处理 (调用对应的中断服务程序)</li><li>继续看书(恢复现场)</li></ul></li></ul></li></ul><p>不同情况，不同处理</p><ul><li>对于门铃：开门取快件</li><li>对于哭声:照顾小孩</li></ul><h3 id="1-3-ARM系统中异常与中断处理流程"><a href="#1-3-ARM系统中异常与中断处理流程" class="headerlink" title="1.3 ARM系统中异常与中断处理流程"></a>1.3 ARM系统中异常与中断处理流程</h3><p>我们将母亲的处理过程抽象化：</p><ul><li>母亲的头脑相当于CPU<ul><li>耳朵听到声音会发送信号给脑袋</li><li>声音来源有很多种<ul><li>有远处的猫叫，门铃声，小孩哭声</li></ul></li><li>这些声音传入耳朵，再由耳朵传给大脑</li><li>除了这些可以中断母亲的看书，还有其他情况，比如：<ul><li>身体不舒服</li><li>有只蜘蛛掉下来</li><li>对于特殊情况无法回避，必须立即处理</li></ul></li></ul></li></ul><p>对于arm系统，异常与中断的硬件框图如下：</p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/002_exception_on_arm.png"></p><p>所有的中断源(按键、定时器等)，它们发出的中断汇聚到<strong>中断控制器</strong>，<br>再由中断控制器发信号给CPU，告诉它发生了那些紧急情况。</p><p>除了这些中断，还有什么可以打断CPU的运行？</p><ul><li>指令不对</li><li>数据访问有问题</li><li>reset信号</li><li>等等，这些都可以打断断CPU，这些被称为<strong>异常</strong></li><li>中断属于一种异常</li></ul><p>ARM系统中如何处理异常与中断？重点在于<strong>保存现场</strong>以及<strong>恢复现场</strong>，<br>处理过程如下：</p><ul><li>保存现场(各种寄存器)</li><li>处理异常(中断属于一种异常)</li><li>恢复现场</li></ul><p>细化一下，在ARM系统中如何使用异常(中断)？</p><ul><li><p>初始化</p><ul><li>设置中断源，让它可以产生中断</li><li>设置中断控制器(可以屏蔽某个中断，优先级)</li><li>设置CPU总开关，使能中断</li></ul></li><li><p>执行其他程序：正常程序</p></li><li><p>产生中断，举例：按下按键—&gt;中断控制器—&gt;CPU</p></li><li><p>cpu每执行完一条指令都会检查有无中断&#x2F;异常产生</p></li><li><p>发现有中断&#x2F;异常产生，开始处理：</p><ul><li>保存现场</li><li>分辨异常&#x2F;中断，调用对于异常&#x2F;中断的处理函数</li><li>恢复现场</li></ul></li></ul><p>不同的芯片，不同的架构，在这方面的处理稍有差别：</p><ul><li><p>保存&#x2F;恢复现场：cortex M3&#x2F;M4是硬件实现的，cortex A7是软件实现的</p></li><li><p>CPU中止当前执行，跳转去执行处理异常的代码：也有差异</p><ul><li><p>cortex M3&#x2F;M4在向量表上放置的是函数地址</p></li><li><p>cortex A7在向量表上放置的是跳转指令</p></li></ul></li></ul><h2 id="2-ARM架构中异常与中断的处理"><a href="#2-ARM架构中异常与中断的处理" class="headerlink" title="2.ARM架构中异常与中断的处理"></a>2.ARM架构中异常与中断的处理</h2><h3 id="1-1-处理流程是一样的"><a href="#1-1-处理流程是一样的" class="headerlink" title="1.1 处理流程是一样的"></a>1.1 处理流程是一样的</h3><ul><li>每执行完一条指令都会检查有无中断&#x2F;异常产生</li><li>发现有中断&#x2F;异常产生，开始处理：<ul><li>保存现场</li><li>分辨异常&#x2F;中断，调用对应的异常&#x2F;中断处理函数</li><li>恢复现场</li></ul></li></ul><p>不同的芯片，不同的架构，在这方面的处理稍有差别：</p><ul><li><p>CPU中止当前执行，跳转去执行处理异常的代码：也有差异</p><ul><li>cortex M3&#x2F;M4在向量表上放置的是函数地址</li><li>cortex A7在向量表上放置的是跳转指令</li></ul></li><li><p>保存&#x2F;恢复现场：cortex M3&#x2F;M4是硬件实现的，cortex A7是软件实现的</p></li></ul><h3 id="1-2-cortex-M3-M4"><a href="#1-2-cortex-M3-M4" class="headerlink" title="1.2 cortex M3&#x2F;M4"></a>1.2 cortex M3&#x2F;M4</h3><p>参考资料：<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>PM0056.pdf</code></p><p>要想理解这个处理流程，需要从向量表说起。<br>向量，在数学定义里是<strong>有方向的量</strong>，在程序里可以认为向量就是一个数组，里面有多个项。<br>在ARM架构里，对于异常&#x2F;中断，它们的<strong>处理入口</strong>会整齐地排放在一起。</p><h4 id="1-2-1-M3-M4的向量表"><a href="#1-2-1-M3-M4的向量表" class="headerlink" title="1.2.1 M3&#x2F;M4的向量表"></a>1.2.1 M3&#x2F;M4的向量表</h4><p>M3&#x2F;M4的向量表中，放置的是具体异常&#x2F;中断的处理函数的地址。<br>比如发生<code>Reset</code>异常时，CPU就会从向量表里找到第1项，得到Reset_Handler函数的地址，跳转去执行。<br>比如发生<code>EXTI Line 0</code>中断时，CPU就会从向量表里找到第22项，得到EXTI0_IRQHandler函数的地址，跳转去执行。</p><ul><li>跳转之前，硬件会保存现场</li><li>函数执行完毕，返回之后，硬件会恢复现场</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler            ; Window Watchdog</span><br><span class="line">                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect</span><br><span class="line">                DCD     TAMPER_IRQHandler          ; Tamper</span><br><span class="line">                DCD     RTC_IRQHandler             ; RTC</span><br><span class="line">                DCD     FLASH_IRQHandler           ; Flash</span><br><span class="line">                DCD     RCC_IRQHandler             ; RCC</span><br><span class="line">                DCD     EXTI0_IRQHandler           ; EXTI Line 0</span><br><span class="line">                DCD     EXTI1_IRQHandler           ; EXTI Line 1</span><br><span class="line">                DCD     EXTI2_IRQHandler           ; EXTI Line 2</span><br><span class="line">                DCD     EXTI3_IRQHandler           ; EXTI Line 3</span><br><span class="line">                DCD     EXTI4_IRQHandler           ; EXTI Line 4</span><br><span class="line">                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1</span><br><span class="line">                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2</span><br><span class="line">                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3</span><br><span class="line">                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4</span><br><span class="line">                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5</span><br><span class="line">                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6</span><br><span class="line">                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7</span><br><span class="line">                DCD     ADC1_2_IRQHandler          ; ADC1 &amp; ADC2</span><br><span class="line">                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX</span><br><span class="line">                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0</span><br><span class="line">                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1</span><br><span class="line">                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE</span><br><span class="line">                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5</span><br><span class="line">                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break</span><br><span class="line">                DCD     TIM1_UP_IRQHandler         ; TIM1 Update</span><br><span class="line">                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation</span><br><span class="line">                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare</span><br><span class="line">                DCD     TIM2_IRQHandler            ; TIM2</span><br><span class="line">                DCD     TIM3_IRQHandler            ; TIM3</span><br><span class="line">                DCD     TIM4_IRQHandler            ; TIM4</span><br><span class="line">                DCD     I2C1_EV_IRQHandler         ; I2C1 Event</span><br><span class="line">                DCD     I2C1_ER_IRQHandler         ; I2C1 Error</span><br><span class="line">                DCD     I2C2_EV_IRQHandler         ; I2C2 Event</span><br><span class="line">                DCD     I2C2_ER_IRQHandler         ; I2C2 Error</span><br><span class="line">                DCD     SPI1_IRQHandler            ; SPI1</span><br><span class="line">                DCD     SPI2_IRQHandler            ; SPI2</span><br><span class="line">                DCD     USART1_IRQHandler          ; USART1</span><br><span class="line">                DCD     USART2_IRQHandler          ; USART2</span><br><span class="line">                DCD     USART3_IRQHandler          ; USART3</span><br><span class="line">                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10</span><br><span class="line">                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line</span><br><span class="line">                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend</span><br><span class="line">                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break</span><br><span class="line">                DCD     TIM8_UP_IRQHandler         ; TIM8 Update</span><br><span class="line">                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation</span><br><span class="line">                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare</span><br><span class="line">                DCD     ADC3_IRQHandler            ; ADC3</span><br><span class="line">                DCD     FSMC_IRQHandler            ; FSMC</span><br><span class="line">                DCD     SDIO_IRQHandler            ; SDIO</span><br><span class="line">                DCD     TIM5_IRQHandler            ; TIM5</span><br><span class="line">                DCD     SPI3_IRQHandler            ; SPI3</span><br><span class="line">                DCD     UART4_IRQHandler           ; UART4</span><br><span class="line">                DCD     UART5_IRQHandler           ; UART5</span><br><span class="line">                DCD     TIM6_IRQHandler            ; TIM6</span><br><span class="line">                DCD     TIM7_IRQHandler            ; TIM7</span><br><span class="line">                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1</span><br><span class="line">                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2</span><br><span class="line">                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3</span><br><span class="line">                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 &amp; Channel5</span><br><span class="line">__Vectors_End</span><br></pre></td></tr></table></figure><h4 id="1-2-2-M3-M4的异常-中断处理流程"><a href="#1-2-2-M3-M4的异常-中断处理流程" class="headerlink" title="1.2.2 M3&#x2F;M4的异常&#x2F;中断处理流程"></a>1.2.2 M3&#x2F;M4的异常&#x2F;中断处理流程</h4><p>发生异常&#x2F;中断时，硬件上实现了这些事情：</p><ul><li><p>保存现场：把被中断瞬间的寄存器的值保存进栈里</p></li><li><p>根据异常&#x2F;中断号，从向量表中得到<strong>函数地址</strong>，跳转过去执行</p></li><li><p>函数执行完后，从栈中恢复现场</p></li></ul><p>保存现场、分辨异常&#x2F;中断、跳转执行，都是硬件实现的。<br>我们只需要在向量表中，把处理函数的地址填进去就可以了。</p><p><strong>硬件</strong>承包了大部分的工作。</p><p>M3&#x2F;M4的向量表中，存放的是<strong>函数地址</strong>。</p><h3 id="1-3-cortex-A7"><a href="#1-3-cortex-A7" class="headerlink" title="1.3 cortex A7"></a>1.3 cortex A7</h3><p>参考资料：<code>ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf</code></p><p>实际上，以前的S3C2440属于ARM9处理器，它的异常&#x2F;中断处理流程给cortex A7是一样的。</p><h4 id="1-3-1-A7的向量表"><a href="#1-3-1-A7的向量表" class="headerlink" title="1.3.1 A7的向量表"></a>1.3.1 A7的向量表</h4><p>A7的向量表中，放置的是某类异常的<strong>跳转指令</strong>。<br>比如发生<code>Reset</code>异常时，CPU就会从向量表里找到第0项，得到<code>b reset</code>指令，执行后就跳转到reset函数。<br>比如发生任何的中断时，CPU就会从向量表里找到第6项，得到<code>ldrpc, _irq</code>指令，执行后就跳转到_irq函数。</p><ul><li>跳转之前，硬件只会保存CPSR寄存器</li><li>跳转之后，软件要保存现场</li><li>函数执行完毕，返回之前，软件恢复现场</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_start: </span><br><span class="line">    breset</span><br><span class="line">ldrpc, _undefined_instruction</span><br><span class="line">ldrpc, _software_interrupt</span><br><span class="line">ldrpc, _prefetch_abort</span><br><span class="line">ldrpc, _data_abort</span><br><span class="line">ldrpc, _not_used</span><br><span class="line">ldrpc, _irq</span><br><span class="line">ldrpc, _fiq</span><br></pre></td></tr></table></figure><h4 id="1-3-2-A7的异常-中断处理流程"><a href="#1-3-2-A7的异常-中断处理流程" class="headerlink" title="1.3.2 A7的异常&#x2F;中断处理流程"></a>1.3.2 A7的异常&#x2F;中断处理流程</h4><p>发生异常&#x2F;中断时，硬件上实现了这些事情：</p><ul><li><p>CPU切换到对应的异常模式，比如IRQ模式、未定义模式、SVC模式</p></li><li><p>保存被中断时的CPSR到SPSR</p><ul><li>CPSR：current program status register，当前程序状态寄存器</li><li>SRSR：saved program status register，保存的程序状态寄存器</li></ul></li><li><p>跳到这个异常的入口地址去，执行<strong>指令</strong>，这通常是一条跳转指令</p></li></ul><p>软件要做的事情就比较多了：</p><ul><li>保存现场</li><li>分辨异常&#x2F;中断</li><li>调用对应的处理函数</li><li>恢复现场</li></ul><p>A7的向量表中，存放的是<strong>跳转指令</strong>。</p><h2 id="3-异常处理深入分析-保存现场"><a href="#3-异常处理深入分析-保存现场" class="headerlink" title="3.异常处理深入分析_保存现场"></a>3.异常处理深入分析_保存现场</h2><h3 id="1-1-回顾一下处理流程"><a href="#1-1-回顾一下处理流程" class="headerlink" title="1.1 回顾一下处理流程"></a>1.1 回顾一下处理流程</h3><p>CPU每执行完一条指令都会检查有无中断&#x2F;异常产生，发现有中断&#x2F;异常产生，开始处理：</p><ul><li>保存现场</li><li>分辨异常&#x2F;中断，调用对应的异常&#x2F;中断处理函数</li><li>恢复现场</li></ul><p>对于不用的处理器，具体的处理工作有差别：</p><ul><li>保存现场：cortex M3&#x2F;M4里是硬件完成，cortex A7等是软件实现</li><li>分辨异常&#x2F;中断：cortex M3&#x2F;M4里是硬件完成，cortex A7等是软件实现</li><li>调用处理函数：cortex M3&#x2F;M4里是硬件来调用，cortex A7等是软件自己去调用</li><li>恢复现场：cortex M3&#x2F;M4里是软件触发、硬件实现，cortex A7等是软件实现</li></ul><p>不管是硬件还是软件实现，第一步都是<strong>保存现场</strong>。</p><h3 id="1-2-为什么要保存现场"><a href="#1-2-为什么要保存现场" class="headerlink" title="1.2 为什么要保存现场"></a>1.2 为什么要保存现场</h3><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/008_save_register.png"></p><p>任何程序，最终都会转换为机器码，上述C代码可以转换为右边的汇编指令。<br>对于这4条指令，它们可能随时被异常打断，怎么保证异常处理完后，被打断的程序还能正确运行？</p><ul><li><p>这4条指令涉及R0、R1寄存器，程序被打断时、恢复运行时，R0、R1要保持不变</p></li><li><p>执行完第3条指令时，比较结果保存在<strong>程序状态寄存器</strong>里，程序被打断时、恢复运行时，程序状态寄存器保持不变</p></li><li><p>这4条指令，读取a、b内存，程序被打断时、恢复运行时，a、b内存保持不变</p></li></ul><p>内存保持不变，这很容易实现，程序不越界就可以。<br>所以，关键在于R0、R1、程序状态寄存器要保持不变(当然不止这些寄存器)：</p><ul><li>在处理异常前，把这些寄存器保存在栈中，这称为<strong>保存现场</strong></li><li>在处理完异常后，从栈中恢复这些寄存器，这称为<strong>恢复现场</strong></li></ul><h3 id="1-3-保存现场"><a href="#1-3-保存现场" class="headerlink" title="1.3 保存现场"></a>1.3 保存现场</h3><p>ARM处理器中有这些寄存器：<br><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/003_cpu_register.png"></p><p>在arm中有个ATPCS规则(ARM-THUMB procedure call standard（ARM-Thumb过程调用标准）。<br>约定R0-R15寄存器的用途：</p><ul><li><p>R0-R3</p><p>调用者和被调用者之间传参数</p></li><li><p>R4-R11</p><p>函数可能被使用，所以在函数的入口保存它们，在函数的出口恢复它们。</p></li></ul><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/004_atpcs.png"></p><p>还有一个<strong>程序状态寄存器</strong>，对于M3&#x2F;M4它被称为<strong>XPSR</strong>，对于A7它被称为<strong>CPSR</strong>，我们简称为PSR。<br>R0-R15、PSR，就是所谓的<strong>现场</strong>。<br>发生异常&#x2F;中断后，在处理异常&#x2F;中断前，需要<strong>保存现场</strong>，难道需要保存所有这些寄存器吗？<br>不需要！<br>在C函数中，可以修改R0-R3、R12、R14(LR)以及PSR。如果C函数要用到这些寄存器，就要把它们保存到栈里，在函数结束前在从栈中恢复它们。<br>这些寄存器被拆分成2部分：**调用者保存的寄存器(R0-R3,R12,LR,PSR)<strong>、</strong>被调用者保存的寄存器(R4-R11)**。<br>比如函数A调用函数B，函数A应该知道：</p><ul><li>R0-R3是用来传参数给函数B的</li><li>函数B可以肆意修改R0-R3</li><li>函数A不要指望函数B帮你保存R0-R3</li><li>保存R0-R3，是函数A的事情</li><li>对于LR、PSR也是同样的道理，保存它们是函数A的责任</li></ul><p>对于函数B：</p><ul><li>我用到R4-R11中的某一个，我都会在函数入口保存、在函数返回前恢复</li><li>保证在B函数调用前后，函数A看到的R4-R11保存不变</li></ul><p>假设函数B就是异常&#x2F;中断处理函数，函数B本身能保证R4-R11不变，那么保存现场时，只需要保存这些：</p><ul><li>调用者保存的寄存器(R0-R3,R12,LR,PSR)</li><li>PC</li></ul><h3 id="1-4-对于M3-M4"><a href="#1-4-对于M3-M4" class="headerlink" title="1.4 对于M3&#x2F;M4"></a>1.4 对于M3&#x2F;M4</h3><p>参考资料：<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>PM0056.pdf</code></p><h4 id="1-4-1-硬件保存现场"><a href="#1-4-1-硬件保存现场" class="headerlink" title="1.4.1 硬件保存现场"></a>1.4.1 硬件保存现场</h4><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/005_saved_register_for_exception.png"></p><h4 id="1-4-2-然后调用C函数"><a href="#1-4-2-然后调用C函数" class="headerlink" title="1.4.2 然后调用C函数"></a>1.4.2 然后调用C函数</h4><p>C函数执行完后，它返回LR所指示的位置。<br>难道把LR设置为被中断的程序的地址就行了吗？<br>如果只是返回LR所指示的地方，硬件帮我们保存在栈里的寄存器，怎么恢复？<br>M3&#x2F;M4在调用异常处理函数前，把LR设置为一个特殊的值，转给特殊的值被称为<strong>EXC_RETURN</strong>。<br>当PC寄存器的值等于<strong>EXC_RETURN</strong>时，会触发异常返回机制，简单地说：会从栈里恢复R0-R3,R12,LR,PC,PSR等寄存器。<br><strong>EXC_RETURN</strong>的值，请参考<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>，截图如下：<br><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/006_exc_return.png"></p><p>补充2个知识点：</p><ul><li><p>操作模式：M3&#x2F;M4有两个操作模式</p><ul><li>处理模式：执行中断服务程序等异常处理时，处于<strong>处理模式</strong></li><li>线程模式：执行普通应用程序代码时，处于<strong>线程模式</strong></li></ul></li><li><p>M3&#x2F;M4有连个SP寄存器：SP_process、SP_main</p><ul><li>有些RTOS在运行用户程序时会使用SP_process，默认使用SP_main。</li></ul></li></ul><h3 id="1-5-对于A7"><a href="#1-5-对于A7" class="headerlink" title="1.5 对于A7"></a>1.5 对于A7</h3><p>它寄存器如下：<br><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/007_bank_register.png"></p><p>处理器有9中模式：User、Sys、FIQ、IRQ、ABT、SVC、UND、MON、HYP。<br>上图中深色的寄存器，表示该模式下的”Banked”寄存器，比如SPSR寄存器，在很多模式下都有自己的、单独的寄存器。<br>比如IRQ模式下访问SPSR时，访问到的是IRQ模式下自己的SPSR_irq，别的模式下无法访问SPSR_irq。</p><p>比较值得关注的是FIQ模式，名为”快中断”，它有很多”Banked”寄存器：R8-R12,SP,LR。<br>在FIQ模式下，它既然能使用自己的R8-R12,SP,LR，自然不需要去保存被中断的程序的”R8-R12,SP,LR”了。<br>省去保存这几个寄存器的时间，处理中断时自然就快很多，所以被称为”FIQ”。</p><p>从上图也看到，几乎每个模式下都有自己是SP寄存器，意味着这些模式下有自己的栈。</p><p>当发生异常时，以IRQ为例：</p><ul><li>CPU会自动切换进入对应的模式，比如进入IRQ模式</li><li>并且会把被中断是的CPSR保存到SPSR_irq里</li></ul><p>所以发生异常&#x2F;中断时，在保存现场时，只需要保存：</p><ul><li>调用者保存的寄存器(R0-R3,R12,LR)</li><li>PC</li></ul><h2 id="4-实战-未定义指令异常"><a href="#4-实战-未定义指令异常" class="headerlink" title="4.实战_未定义指令异常"></a>4.实战_未定义指令异常</h2><p>参考资料：<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>PM0056.pdf</code></p><h3 id="1-1-M3-M4支持哪些异常"><a href="#1-1-M3-M4支持哪些异常" class="headerlink" title="1.1 M3_M4支持哪些异常"></a>1.1 M3_M4支持哪些异常</h3><p>从向量表可以看出，M3&#x2F;M4支持哪些异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class="line">                </span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler            ; Window Watchdog</span><br><span class="line">                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect   </span><br></pre></td></tr></table></figure><p>前面几个对应各类错误：</p><ul><li>Hard Fault</li><li>MPU Fault</li><li>Bus Fault</li><li>Usage Fault</li></ul><p>这几类错误产生的原因入下图所示，这个图来自<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>:<br><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/009_m3m4_fault.png"></p><p>以未定义指令为例，它属于”处理器操作相关的错误”，如果没有使能”Usage Fault”，发就会触发”Hard Fault”。</p><h3 id="1-2-什么是未定义指令？"><a href="#1-2-什么是未定义指令？" class="headerlink" title="1.2 什么是未定义指令？"></a>1.2 什么是未定义指令？</h3><p>未定义指令，即使”还没有定义的指令”，也就是CPU不认识的指令。<br>很多时候，我们故意在代码里插入一些伪造的指令，故意让CPU执行到它时触发错误。<br>这在调试时很有用，比如想打断点：怎么实现呢？<br>有很多种方法：硬件监视点(watch point，数量有限)、软件断点(数量无限)。<br>软件断点就是使用<code>未定义指令</code>来实现的，比如想让程序执行到某个地址A时停下来，可以这样做：</p><ul><li>地址A上原来的指令是<code>xxx</code></li><li>我们故意把它改成<code>yyy</code>，改成一条CPU无法识别的指令</li><li>当CPU执行到地址A上的<code>yyy</code>指令时，触发异常</li><li>在异常处理函数里，打印更多调试信息</li><li>调试完毕后，恢复地址A上的指令为<code>xxx</code></li><li>从地址A重新执行程序</li></ul><p>本节教程并不打算制作调试器，这里只是讲述一下未定义指令的作用，使用它来深入理解异常处理流程。</p><h3 id="1-3-在汇编代码里插入未定义指令"><a href="#1-3-在汇编代码里插入未定义指令" class="headerlink" title="1.3 在汇编代码里插入未定义指令"></a>1.3 在汇编代码里插入未定义指令</h3><p>在代码中插入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DCD  0xffffffff；在main函数之前插入</span><br><span class="line">LDR PC,=mymain;绝对跳转</span><br></pre></td></tr></table></figure><h4 id="1-3-1-先不使能”HardFault”、”Usage-Fault”"><a href="#1-3-1-先不使能”HardFault”、”Usage-Fault”" class="headerlink" title="1.3.1 先不使能”HardFault”、”Usage Fault”"></a>1.3.1 先不使能”HardFault”、”Usage Fault”</h4><p> 结果：不会进入main函数</p><h4 id="1-3-2-使能”HardFault”"><a href="#1-3-2-使能”HardFault”" class="headerlink" title="1.3.2 使能”HardFault”"></a>1.3.2 使能”HardFault”</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__VectorsDCD(0X20000000+0X10000);设置栈大小</span><br><span class="line">DCDReset_Handler;Reset_Handler 伪指令,一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化</span><br><span class="line">DCD     0                   ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HardFault_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;HardFault!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：只打印异常处理函数HardFault_Handler（）里面实现的 <strong>HardFault!</strong></p><h4 id="1-3-3-使能”Usage-Fault”"><a href="#1-3-3-使能”Usage-Fault”" class="headerlink" title="1.3.3 使能”Usage Fault”"></a>1.3.3 使能”Usage Fault”</h4><ul><li><p>设置SCB寄存器的第18位，才能使能Usage Fault</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__VectorsDCD(0X20000000+0X10000);设置栈大小</span><br><span class="line">DCDReset_Handler;Reset_Handler 伪指令,一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化</span><br><span class="line">DCD     0                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     0          ; MPU Fault Handler</span><br><span class="line">                DCD     0           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br></pre></td></tr></table></figure></li><li><p>初始化UsageFault，实现对应的异常处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UsageFaultInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SCB_Type * SCB = (SCB_Type *)SCB_BASE_ADDR;</span><br><span class="line">SCB-&gt;SHCSR |= (SCB_SHCSR_USGFAULTENA_Msk);  <span class="comment">//UsageFault Enable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsageFault_Handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> * <span class="built_in">stack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SCB_Type * SCB = (SCB_Type *)SCB_BASE_ADDR;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;UsageFault!\r\n&quot;</span>);</span><br><span class="line">SCB-&gt;CFSR = SCB-&gt;CFSR;    <span class="comment">//1.清除标志位，否则会一直触发</span></span><br><span class="line"><span class="built_in">stack</span>[<span class="number">6</span>] += <span class="number">4</span>;  <span class="comment">//2.设置返回地址，指向下一条指令,否则返回之后又会执行这条指令，还是会一直触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：打印异常处理函数UsageFault_Handler（）里面实现的 <strong>UsageFault!<strong>之后，紧接着</strong>进去main函数中去</strong></p></li></ul><h2 id="5-实战-SVC异常"><a href="#5-实战-SVC异常" class="headerlink" title="5.实战_SVC异常"></a>5.实战_SVC异常</h2><p>参考资料：<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>PM0056.pdf</code></p><h3 id="1-1-M3-M4支持哪些异常-1"><a href="#1-1-M3-M4支持哪些异常-1" class="headerlink" title="1.1 M3_M4支持哪些异常"></a>1.1 M3_M4支持哪些异常</h3><p>从向量表可以看出，M3&#x2F;M4支持哪些异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class="line">                </span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler            ; Window Watchdog</span><br><span class="line">                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect   </span><br></pre></td></tr></table></figure><p>在上述代码中，可以看到<code>SVC_Handler</code>，它对应SVC异常，当执行<code>SVC</code>指令时，会导致<code>SVC_Handler</code>被调用。</p><h3 id="1-2-什么是SVC指令？"><a href="#1-2-什么是SVC指令？" class="headerlink" title="1.2 什么是SVC指令？"></a>1.2 什么是SVC指令？</h3><p>在ARM指令中，有一条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SVC #VAL</span><br></pre></td></tr></table></figure><p>它会触发一个异常。<br>在操作系统中，比如各类RTOS或者Linux，都会使用<code>SVC</code>指令故意触发异常，从而导致内核的异常处理函数被调用，进而去使用内核的服务。<br>比如Linux中，各类文件操作的函数<code>open</code>、<code>read</code>、<code>write</code>，它的实质都是<code>SVC</code>指令。<br>本节课程不讲解<code>SVC</code>在内核中的使用，我们只是看看如何处理<code>SVC</code>触发的异常。</p><h3 id="1-3-在汇编代码里插入SVC指令"><a href="#1-3-在汇编代码里插入SVC指令" class="headerlink" title="1.3 在汇编代码里插入SVC指令"></a>1.3 在汇编代码里插入SVC指令</h3><p>在代码中插入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SVC #1</span><br></pre></td></tr></table></figure><p>看看会发生什么事情。</p><p> 结果：只打印异常处理函数HardFault_Handler（）里面实现的 <strong>HardFault!</strong></p><h4 id="1-3-1-提供SVC异常处理函数"><a href="#1-3-1-提供SVC异常处理函数" class="headerlink" title="1.3.1 提供SVC异常处理函数"></a>1.3.1 提供SVC异常处理函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SVC_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;SVC!\r\n&quot;</span>);  <span class="comment">//执行完这条指令，会自动执行下一条指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：只打印异常处理函数SVC_Handler（）里面实现的 <strong>HardFault!<strong>之后，紧接着</strong>进去main函数中去</strong></p><h2 id="6-实战-SysTick异常"><a href="#6-实战-SysTick异常" class="headerlink" title="6.实战_SysTick异常"></a>6.实战_SysTick异常</h2><p>使用CPU自带的SysTick定时器，让它产生周期性的中断，用来操作LED。</p><p>参考资料：<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>PM0056.pdf</code></p><h3 id="1-1-M3-M4支持哪些异常-2"><a href="#1-1-M3-M4支持哪些异常-2" class="headerlink" title="1.1 M3_M4支持哪些异常"></a>1.1 M3_M4支持哪些异常</h3><p>从向量表可以看出，M3&#x2F;M4支持哪些异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class="line">                </span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler            ; Window Watchdog</span><br><span class="line">                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect   </span><br></pre></td></tr></table></figure><h3 id="1-2-SysTick操作"><a href="#1-2-SysTick操作" class="headerlink" title="1.2 SysTick操作"></a>1.2 SysTick操作</h3><p>Cortex-M处理器内部集成了一个小型的、名为SysTick的定时器。可以使用它来为操作系统提供系统时钟，也可以把它当做一般的定时器。<br>之所以在处理器内增加这样的定时器，是为了提高软件的可以移植性。<br>它是一个24位的定时器，向下计数。<br>在时钟源的驱动下，计数值到达0时，可以触发异常。<br>它的框图如下：<br><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/010_systick.png"></p><p>在本程序中，只需要设置这几个寄存器：</p><h4 id="1-2-1-SysTick-CTRL"><a href="#1-2-1-SysTick-CTRL" class="headerlink" title="1.2.1 SysTick-&gt;CTRL"></a>1.2.1 SysTick-&gt;CTRL</h4><p>  <img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/011_stk_ctrl.png"></p><h4 id="1-2-2-SysTick-VAL"><a href="#1-2-2-SysTick-VAL" class="headerlink" title="1.2.2 SysTick-&gt;VAL"></a>1.2.2 SysTick-&gt;VAL</h4><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/012_stk_val.png"></p><h4 id="1-2-3-SysTick-LOAD"><a href="#1-2-3-SysTick-LOAD" class="headerlink" title="1.2.3 SysTick-&gt;LOAD"></a>1.2.3 SysTick-&gt;LOAD</h4><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/013_stk_load.png"></p><h3 id="1-3-清除SysTick异常"><a href="#1-3-清除SysTick异常" class="headerlink" title="1.3 清除SysTick异常"></a>1.3 清除SysTick异常</h3><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/014_clear_systick_pending.png"></p><h1 id="第六章-操作模式和特权等级"><a href="#第六章-操作模式和特权等级" class="headerlink" title="第六章 操作模式和特权等级"></a>第六章 操作模式和特权等级</h1><h2 id="1-CPU模式和状态以及栈寄存器"><a href="#1-CPU模式和状态以及栈寄存器" class="headerlink" title="1.CPU模式和状态以及栈寄存器"></a>1.CPU模式和状态以及栈寄存器</h2><h3 id="1-模式和状态"><a href="#1-模式和状态" class="headerlink" title="1. 模式和状态"></a>1. 模式和状态</h3><h4 id="1-1-状态"><a href="#1-1-状态" class="headerlink" title="1.1 状态"></a>1.1 状态</h4><p>ARM芯片支持Thumb指令集、ARM指令集，处理器运行Thumb指令时处于Thumb状态，运行ARM指令时处于ARM状态。</p><p>CortexM3&#x2F;M4只支持Thumb指令集，所以处理器运行时只有Thumb状态。除此之外，还有一个调试状态：比如通过调试器或触发断点后，处理器就会进入调试状态并停止指令执行。</p><p>本课程不涉及调试状态，所以处理器只处于Thumb状态。</p><h4 id="1-2-模式-访问等级-栈"><a href="#1-2-模式-访问等级-栈" class="headerlink" title="1.2 模式&#x2F;访问等级&#x2F;栈"></a>1.2 模式&#x2F;访问等级&#x2F;栈</h4><p>CortexM3&#x2F;M4处理器有两种模式：</p><ul><li>处理模式：执行中断服务程序等异常处理，在处理模式下，处理器有最大权限(具有特权访问等级)</li><li>线程模式：执行普通程序。这是处理器可以处于特权访问等级，也可以处于非特权访问等级。</li></ul><p>不同模式下，处理权限可能不同，最大的不同就是：栈寄存器可能也不同。</p><p>ARM处理器的通用寄存器有R0、R1、……、R15，其中的R13也被称为SP，即栈寄存器。对于SP，它有两个实体：MSP(Main SP)、PSP(Process SP)。</p><p>在处理模式下，使用MSP，也就是说指令中使用SP时，它对应的物理寄存器是MSP。</p><p>在线程模式下，根据CONTROL寄存器的设置，处理器可能用的是MSP，也可能用的是PSP。</p><p>图示如下：</p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/06_spsel.png" alt="image-20220326170811105"></p><p>栈寄存器的选择：</p><ul><li>① 启动时，CONTROL寄存器的SPSEL等于0，默认使用MSP。注意：启动时是线程模式，使用的仍然是MSP</li><li>② 程序可以修改CONTROL寄存器让SPSEL等于1，以使用PSP</li><li>③ 发生异常时，异常处理函数中使用的必定是MSP</li><li>④ 异常返回时，可以控制返回之后使用MSP还是PSP</li></ul><p>所谓访问等级，有两种：</p><ul><li>特权访问等级：可以访问所有寄存器、所有存储器。</li><li>非特权访问等级：无法访问某些寄存器，比如无法访问NVIC寄存器(嵌套向量中断控制器)。</li></ul><p>在一般的单片机系统中，RTOS、各类应用之间是无法隔离的：某个应用程序崩溃了，整个系统也就崩溃了。如果能让RTOS、各类应用程序彼此之间隔离开，那么可以增强系统的健壮性。这需要硬件的支持，比如需要有MPU(Memory Protection Unit)。</p><p>没有MPU时，访问等级的用处不大，只能用来限制应用程序无法访问某些寄存器。</p><h4 id="1-3-转换图"><a href="#1-3-转换图" class="headerlink" title="1.3 转换图"></a>1.3 转换图</h4><p>处理器状态和模式转换图如下：</p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/04_mode_status.png" alt="image-20220326164725625"></p><p>注意：</p><ul><li>① 上电启动时，处理处于线程模式，处于特权访问等级</li><li>② 在特权模式下，它自然可以设置某些寄存器降低自己的等级，进入非特权访问等级</li><li>③ 在非特权模式下，无法自行提升自己的等级</li><li>④ 发生异常时，处理器进入处理模式</li><li>⑤ 在处理模式下永远都是特权访问等级</li><li>⑥ 异常放回时，可以返回到特权访问等级，也可以返回到非特权访问等级</li></ul><h4 id="1-4-CONTROL寄存器"><a href="#1-4-CONTROL寄存器" class="headerlink" title="1.4 CONTROL寄存器"></a>1.4 CONTROL寄存器</h4><p>上图中，第②那里，怎么从特权访问等级降级为非特权访问等级？通过设置CONTROL寄存器。</p><p>CONTROL寄存器定义如下：</p><ul><li>SPSEL：用来选择线程模式使用的是MSP还是PSP</li><li>nPRIV：用来设置线程模式的访问等级(特权&#x2F;非特权)</li></ul><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/07_control_reg.png" alt="image-20220326171250026"></p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/08_control_reg_bits.png" alt="image-20220326171338515"></p><p>两种等级、两种栈，组合起来就有4种情况：</p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/13_control_bit_table.png" alt="image-20220326162610884"></p><p>怎么读写CONTROL寄存器？使用如下汇编指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRS r0, CONTROL  ; 将CONTROL寄存器的值读入R0</span><br><span class="line">MSR CONTROL, r0  ; 将R0写入CONTROL寄存器</span><br></pre></td></tr></table></figure><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/10_process_mode_switch.png" alt="image-20220326180056270"></p><h4 id="1-5-EXC-RETURN"><a href="#1-5-EXC-RETURN" class="headerlink" title="1.5 EXC_RETURN"></a>1.5 EXC_RETURN</h4><p>通过设置CONTROL寄存器，可以选择MSP或PSP，可以把特权访问等级降为非特权访问等级。</p><p>但是无法把非特权等级提升为特权访问等级，为什么？如果可以这样简单地提升等级的话，等级也就失去了意义。</p><p>线程模式下无法自行提升等级，只能借助异常处理来提升等级：</p><ul><li>在异常的处理函数中，LR等于一个特殊的值EXC_RETURN</li><li>EXC_RETURN决定里异常返回后，处理器处于什么模式、使用什么栈</li></ul><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/09_exc_return.png" alt="image-20220326174011909"></p><h3 id="2-编程"><a href="#2-编程" class="headerlink" title="2. 编程"></a>2. 编程</h3><p>调试本节程序时，在Keil自带的模拟器上调试，这样更容易看清楚。</p><p>工程需要如下设置：</p><p><img src="/2023/10/21/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/01_use_emulator.png" alt="image-20220326183856624"></p><h2 id="2-提升访问等级"><a href="#2-提升访问等级" class="headerlink" title="2.提升访问等级"></a>2.提升访问等级</h2><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="3-MSP和PSP"><a href="#3-MSP和PSP" class="headerlink" title="3.MSP和PSP"></a>3.MSP和PSP</h2>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法基础教程</title>
      <link href="/2023/10/19/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2023/10/19/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h1><p>快捷键：</p><ul><li>一级标题：ctrl+1</li><li>二级标题：ctrl+2</li><li>三级标题：ctrl+3</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><h1 id="2、加黑"><a href="#2、加黑" class="headerlink" title="2、加黑"></a>2、加黑</h1><p>快捷键：ctrl+B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**加黑**</span><br></pre></td></tr></table></figure><h1 id="3、高亮"><a href="#3、高亮" class="headerlink" title="3、高亮"></a>3、高亮</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==高亮==</span><br></pre></td></tr></table></figure><h1 id="4、输入代码"><a href="#4、输入代码" class="headerlink" title="4、输入代码"></a>4、输入代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​```markdown </span><br></pre></td></tr></table></figure><h1 id="5、图片选项"><a href="#5、图片选项" class="headerlink" title="5、图片选项"></a>5、图片选项</h1><ul><li>点击左上角“文件”</li><li>进入“偏好设置”</li><li>点击图像，选择复制图像到当前文件夹</li><li>勾选下面的前三个选项</li></ul><h1 id="6、实心黑点（实心圆圈和空心圆）"><a href="#6、实心黑点（实心圆圈和空心圆）" class="headerlink" title="6、实心黑点（实心圆圈和空心圆）"></a>6、实心黑点（实心圆圈和空心圆）</h1><ul><li>先按shift+tab，让光标回到行首</li><li>按下一个减号（-），然后再按一个空格即可</li><li><strong>空心圆：</strong>在按下适应黑点后，再按一个tab键即可</li></ul><h1 id="7、更改字体大小和样式"><a href="#7、更改字体大小和样式" class="headerlink" title="7、更改字体大小和样式"></a>7、更改字体大小和样式</h1><ul><li><strong>字体大小</strong>：偏好设置里面自定义设置</li><li><strong>字体样式</strong>：打开主题文件夹。我们需要打开 .css文件更改里面的内容才可以！<strong>可以使用 notepad++编辑！</strong></li></ul><h1 id="8、小条状标题：-加空格"><a href="#8、小条状标题：-加空格" class="headerlink" title="8、小条状标题：&gt; 加空格"></a>8、小条状标题：&gt; 加空格</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; </span><br></pre></td></tr></table></figure><ul><li>打开<strong>github.css</strong>文件</li><li>找到blockquote，修改solid的值即可</li></ul><h1 id="9、图片"><a href="#9、图片" class="headerlink" title="9、图片"></a>9、图片</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 本地图片</span><br><span class="line">&lt;img src=&quot;/assets/pusheencode.webp&quot; alt=&quot;示例图片&quot; style=&quot;zoom:50%;&quot; /&gt;  #无法使用</span><br><span class="line">![](图片名)</span><br><span class="line"># 在线图片</span><br><span class="line">![code](https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png)</span><br><span class="line">#hexo插入图片的方法</span><br><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
